<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hanks&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="android,web,node,python">
<meta property="og:type" content="website">
<meta property="og:title" content="Hanks' Blog">
<meta property="og:url" content="http://hanks-zyh.github.io/page/14/index.html">
<meta property="og:site_name" content="Hanks' Blog">
<meta property="og:description" content="android,web,node,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hanks' Blog">
<meta name="twitter:description" content="android,web,node,python">
  
  
    <link rel="icon" href="/images/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'> -->
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo"></a>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      
        <a class="main-nav-link" href="/archives">归档</a>
      
        <a class="main-nav-link" href="/daily">日报</a>
      
        <a class="main-nav-link" href="/eye-video">开眼</a>
      
        <a class="main-nav-link" href="/joke">joke</a>
      
        <a class="main-nav-link" href="/picture-fight">斗图</a>
      
        <a class="main-nav-link" href="/atom.xml">RSS</a>
      
    </nav>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/daily" class="mobile-nav-link">日报</a>
  
    <a href="/eye-video" class="mobile-nav-link">开眼</a>
  
    <a href="/joke" class="mobile-nav-link">joke</a>
  
    <a href="/picture-fight" class="mobile-nav-link">斗图</a>
  
    <a href="/atom.xml" class="mobile-nav-link">RSS</a>
  
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="info">
     <div class="content">
       <div>
         <a href="https://github.com/hanks-zyh"><img class="avatar" src="https://avatars2.githubusercontent.com/u/6268322?v=3&s=460" alt="" /></a>
       </div>
       <div class="name">
         <h2 >Hanks</h2>
       </div>
       <p>90后，奋青，Android ……</p>
       <div class="account">
         <div class="account-item">
           <a href="http://weibo.com/u/2359002991"><img src="http://ww1.sinaimg.cn/large/8c9b876fjw1f3ik9y4q7hj205k05kdfx.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
              <a href="http://www.zhihu.com/people/yuhan-zhang-36"><img src="http://ww2.sinaimg.cn/large/8c9b876fjw1f3ik7sv63wj205k05k3yg.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
           <a href="http://hanks.xyz/atom.xml"> <img src="http://ww3.sinaimg.cn/large/8c9b876fjw1f3ik9kk2ctj205k05kt8n.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
       </div>
     </div>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">最新发布</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/26/node-image-recognition/">Node 识别图片中的文字</a>
          </li>
        
          <li>
            <a href="/2017/03/22/proxy-test/">请求代理</a>
          </li>
        
          <li>
            <a href="/2017/02/16/android-customview-inputmethod/">Android 自定义 view 连接输入法</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-lua/">Android 与 Lua</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-markdown-render/">Android 下 Markdown 渲染</a>
          </li>
        
          <li>
            <a href="/2017/01/09/android-webview-font/">Android 中 webview 自定义字体</a>
          </li>
        
          <li>
            <a href="/2016/09/25/slack-bot/">slack bot</a>
          </li>
        
          <li>
            <a href="/2016/09/19/webapp/">让网页更适配移动设备</a>
          </li>
        
          <li>
            <a href="/2016/09/05/weex-2333/">体验 weex —— 写一个表情包应用</a>
          </li>
        
          <li>
            <a href="/2016/08/31/nestedscrollchild/">WebView 实现 NestedScrollingChild</a>
          </li>
        
          <li>
            <a href="/2016/08/29/nestedchildparent/">NestedScrollingParent 实现复杂交互效果</a>
          </li>
        
          <li>
            <a href="/2016/08/04/telegram-bot/">写一个福利 Telegram 机器人</a>
          </li>
        
          <li>
            <a href="/2016/07/31/write-butterkinfe/">写一个 ButterKnife</a>
          </li>
        
          <li>
            <a href="/2016/07/24/edittext-cursor/">多行 EditText 的光标高度问题</a>
          </li>
        
          <li>
            <a href="/2016/07/22/textview-lineheight/">TextView 设置行高并垂直居中</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Atom/" style="font-size: 10px;">Atom</a> <a href="/tags/Dagger2/" style="font-size: 10px;">Dagger2</a> <a href="/tags/EditText/" style="font-size: 10px;">EditText</a> <a href="/tags/Express/" style="font-size: 11.67px;">Express</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/Framework/" style="font-size: 11.67px;">Framework</a> <a href="/tags/HTML-CSS/" style="font-size: 10px;">HTML/CSS</a> <a href="/tags/Jade/" style="font-size: 10px;">Jade</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/LAMP/" style="font-size: 10px;">LAMP</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Lua/" style="font-size: 10px;">Lua</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/NestedScrolling/" style="font-size: 13.33px;">NestedScrolling</a> <a href="/tags/Node-js/" style="font-size: 13.33px;">Node.js</a> <a href="/tags/OS-X/" style="font-size: 10px;">OS X</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Python/" style="font-size: 11.67px;">Python</a> <a href="/tags/React-Native/" style="font-size: 18.33px;">React-Native</a> <a href="/tags/Refactoring/" style="font-size: 10px;">Refactoring</a> <a href="/tags/Rx/" style="font-size: 10px;">Rx</a> <a href="/tags/RxJava/" style="font-size: 13.33px;">RxJava</a> <a href="/tags/Rxandroid/" style="font-size: 10px;">Rxandroid</a> <a href="/tags/Rxjava/" style="font-size: 11.67px;">Rxjava</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Scrapy/" style="font-size: 11.67px;">Scrapy</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/SwipeRefreshLayout/" style="font-size: 10px;">SwipeRefreshLayout</a> <a href="/tags/Telegram/" style="font-size: 10px;">Telegram</a> <a href="/tags/TextView/" style="font-size: 10px;">TextView</a> <a href="/tags/Ubuntu/" style="font-size: 16.67px;">Ubuntu</a> <a href="/tags/VPS/" style="font-size: 10px;">VPS</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/WebView/" style="font-size: 11.67px;">WebView</a> <a href="/tags/bot/" style="font-size: 10px;">bot</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/interpolator/" style="font-size: 10px;">interpolator</a> <a href="/tags/leancloud/" style="font-size: 10px;">leancloud</a> <a href="/tags/mac-os/" style="font-size: 10px;">mac os</a> <a href="/tags/slack/" style="font-size: 10px;">slack</a> <a href="/tags/virtualBox/" style="font-size: 10px;">virtualBox</a> <a href="/tags/weex/" style="font-size: 10px;">weex</a> <a href="/tags/代理/" style="font-size: 10px;">代理</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/学习/" style="font-size: 10px;">学习</a> <a href="/tags/必备知识/" style="font-size: 10px;">必备知识</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/热修复/" style="font-size: 11.67px;">热修复</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/自动化/" style="font-size: 10px;">自动化</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/hanks-zyh">hanks-zyh</a>
          </li>
        
          <li>
            <a href="http://kiya.space">Kiya‘s space</a>
          </li>
        
          <li>
            <a href="http://rocko.xyz/">Rocko&#39;s blog</a>
          </li>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="wx">
      <h3 class="widget-title">微信公众号</h3>
      <img src='http://ww1.sinaimg.cn/large/8c9b876fly1fe0nnlvokpj20by0bywfi.jpg' height="100%" width="100%" >
      <p>搜索公众号: CodeProvider</p>
    </div>
  </div>


  
</aside>
        
        <section id="main" class="mdl-shadow--2dp">
  
    <article id="post-NYOJ_题目20吝啬的国度（DFS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/08/NYOJ_题目20吝啬的国度（DFS）/">NYOJ 题目20吝啬的国度（DFS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h4 class="problem-display"></h4>
<h2 class="problem-display" align="center"><span style="color:#3366ff">吝啬的国度</span></h2>
<div class="problem-ins" align="center"><span style="color:#009900">时间限制：<span id="problem[time_limit]" class="editable highlight">1000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB
</span></div>
<div class="problem-ins" align="center"><span style="color:#009900">难度：<span class="editable highlight">3</span></span></div>
<div class="clr"></div>
<dl class="problem-display"><dt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 描述 </dt></dl>
<blockquote dir="ltr" style="margin-right:0px">
<p>在一个吝啬的国度里有N个城市，这N个城市间只有N-1条路把这个N个城市连接起来。现在，Tom在第S号城市，他有张该国地图，他想知道如果自己要去参观第T号城市，必须经过的前一个城市是几号城市（假设你不走重复的路）。
</p>
<p class="clr">&nbsp;</p>
<p>输入 </p>
<p>第一行输入一个整数M表示测试数据共有M(1&lt;=M&lt;=5)组<br>
每组测试数据的第一行输入一个正整数N(1&lt;=N&lt;=100000)和一个正整数S(1&lt;=S&lt;=100000)，N表示城市的总个数，S表示参观者所在城市的编号<br>
随后的N-1行，每行有两个正整数a,b(1&lt;=a,b&lt;=N)，表示第a号城市和第b号城市之间有一条路连通。 </p>
<p>输出 </p>
<p>每组测试数据输N个正整数，其中，第i个数表示从S走到i号城市，必须要经过的上一个城市的编号。（其中i=S时，请输出-1） </p>
<p>样例输入 </p>
<pre id="sample_input">1
10 1
1 9
1 8
8 10
10 3
8 6
1 2
10 4
9 5
3 7
</pre>
<p>样例输出 </p>
<pre id="sample_output">-1 1 10 10 9 8 3 1 1 8
</pre>
</blockquote>
<dl class="others">
<p><strong><span style="font-size:18px"><span style="font-family:SimHei">首先想到的是使用邻接矩阵（菜鸟！没办法o(╯□╰)o）， 差不多快写完了，然后看题目中N的范围，100000，开一个二维数组city[N][N],根本没办法编译，==！于是放弃邻接矩阵，改用邻接表存储，我把代码那个写啊。。。。指针，结构体，头结点什么的一会儿就晕了， 后来看到有人使用STL中的 vector ，可以用来代替二维数组，不过差不多，于是我就试着用vector
 （第一次用也不知道理解的对不对，，以前见过没用）， vector &lt;int&gt; city[N];&nbsp; 相当于N个vector，跟二维数组差不多</span></span></strong></p>
<p><strong><span style="font-size:18px"><span style="font-family:SimHei"></span></span></strong>&nbsp;</p>
<p><strong><span style="font-size:18px"><span style="font-family:SimHei">代码：</span></span></strong></p>
<p><strong><span style="font-size:18px"><span style="font-family:SimHei"></span></span></strong></p>
<pre class="cpp" name="code"> 

#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#define N 100005
using namespace std;

vector &lt;int&gt; city[N];
int p[N];
bool vis[N];


void DFS(int x)
{
	vis[x] = 1;
	int i=0,len;
	len = city[x].size();
	for(i=0;i&lt;len;i++)
	{
		if(!vis[city[x][i]])
		{
			p[city[x][i]]=x;
			DFS(city[x][i]);
		}
	//	i++;
	}
}
int main()
{
	int m,n,s,i,x,y;
	
	scanf(&quot;%d&quot;,&amp;m);
	
	while(m--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;s);
		for(i=0;i&lt;=n;i++) city[i].clear();//这里初始化清空，第一次没写WA了
		for(i=0;i&lt;n-1;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			city[x].push_back(y);
			city[y].push_back(x);
		}
		memset(vis,0,sizeof(vis));
		p[s]=-1;
		DFS(s);
		for(i=1;i&lt;n;i++) printf(&quot;%d &quot;,p[i]); printf(&quot;%d\n&quot;,p[n]);
	}
	return 0;
}
        </pre>
<p><br>
&nbsp;</p>
</dl>
<dl class="problem-display">
<p></p>
</dl>
<p>别人优秀代码，用的map，还没用过，改天研究研究！</p>
<p></p>
<pre class="cpp" name="code"> 
#include &lt;stdio.h&gt;
#include &lt;memory.h&gt;

int map[100005];

void Adjust(int currentCity)
{
	int priorCity = map[currentCity];
	if (priorCity != 0)
	{
		Adjust(priorCity);
		map[priorCity] = currentCity;
	}
}

int main()
{
	int i, testNum, cityNum, startCity, cityA, cityB;
	scanf(&quot;%d&quot;, &amp;testNum);
	while (testNum-- != 0)
	{
		scanf(&quot;%d%d&quot;, &amp;cityNum, &amp;startCity);
		memset(map, 0, sizeof(int)*cityNum + 1);
		for (i = 1; i &lt; cityNum; i++)
		{
			scanf(&quot;%d%d&quot;, &amp;cityA, &amp;cityB);
			if (map[cityB] == 0)
			{
				map[cityB] = cityA;
			}
			else
			{
				Adjust(cityA);
				map[cityA] = cityB;
			}
		}
		Adjust(startCity);
		map[startCity] = - 1;
		for (i = 1; i &lt; cityNum; i++)
		{
			printf(&quot;%d &quot;, map[i]);
		}
		printf(&quot;%d\n&quot;, map[i]);
	}
	return 0;
}        </pre>
<p><br>
&nbsp;</p>
<dl></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1236_排名" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/08/hdu_题目1236_排名/">hdu 题目1236 排名</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">排名</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 12775&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 4761<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">今天的上机考试虽然有实时的Ranklist，但上面的排名只是根据完成的题数排序，没有考虑 <br>
每题的分&#20540;，所以并不是最后的排名。给定录取分数线，请你写程序找出最后通过分数线的 <br>
考生，并将他们的成绩按降序打印。 <br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">测试输入包含若干场考试的信息。每场考试信息的第1行给出考生人数N ( 0 &lt; N <br>
&lt; 1000 )、考题数M ( 0 &lt; M &lt; = 10 )、分数线（正整数）G；第2行排序给出第1题至第M题的正整数分&#20540;；以下N行，每行给出一 <br>
名考生的准考证号（长度不超过20的字符串）、该生解决的题目总数m、以及这m道题的题号 <br>
（题目号由1到M）。 <br>
当读入的考生人数为0时，输入结束，该场考试不予处理。 <br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">对每场考试，首先在第1行输出不低于分数线的考生人数n，随后n行按分数从高 <br>
到低输出上线考生的考号与分数，其间用1空&#26684;分隔。若有多名考生分数相同，则按他们考 <br>
号的升序输出。 <br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">4 5 25
10 10 12 13 15
CS004 3 5 1 3
CS003 5 2 4 1 3 5
CS002 2 1 2
CS001 3 2 3 5
1 2 40
10 30
CS001 1 2
2 3 20
10 10 10
CS000000000000000001 0
CS000000000000000002 2 1 2
0</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">3
CS003 60
CS001 37
CS004 37
0
1
CS000000000000000002 20

</div></pre>
</div>
<p>简单结构体排序</p>
<p>1.创建结构体stu[]，存放每个考生记录</p>
<p>2.对于每个考生，输入时计算他的总分，对于没有大于等于分数线G的，不给于记录</p>
<p>3，结构体数组排序sort</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#define N 1002
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;

typedef struct student
{
	char name[22];
	int grade;
}Stu;

Stu stu[N];
bool cmp(Stu a,Stu b)
{
	if(a.grade&gt;b.grade) return true;//首先按分数
	else if(a.grade == b.grade)//分数相等按考号
	{
		if(strcmp(a.name,b.name)&lt;0) return true;
		return false;
	}
	else return false;
}
int main()
{
	int i,j,k,num,c,n,m,g;
	int val[11];
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		scanf(&quot;%d%d&quot;,&amp;m,&amp;g);
		for(i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;val[i]);
		k=0;
		for(i=0;i&lt;n;i++)
		{
			stu[k].grade =0;
			scanf(&quot;%s%d&quot;,stu[k].name,&amp;num);
			for(j=0;j&lt;num;j++)
			{
				scanf(&quot;%d&quot;,&amp;c);
				stu[k].grade += val[c];
			}
			if(stu[k].grade&gt;=g) k++;
		}
		printf(&quot;%d\n&quot;,k);
		sort(stu,stu+k,cmp);
		for(i=0;i&lt;k;i++)
		{
			printf(&quot;%s %d\n&quot;,stu[i].name,stu[i].grade);
		}
	}
	return 0;
} </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-HDU_题目1106_排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/08/HDU_题目1106_排序/">HDU 题目1106 排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">排序</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 27858&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 7682<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">输入一行数字，如果我们把这行数字中的‘5’都看成空&#26684;，那么就得到一行用空&#26684;分割的若干非负整数（可能有些整数以‘0’开头，这些头部的‘0’应该被忽略掉，除非这个整数就是由若干个‘0’组成的，这时这个整数就是0）。<br>
<br>
你的任务是：对这些分割得到的整数，依从小到大的顺序排序输出。<br>
<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">输入包含多组测试用例，每组输入数据只有一行数字（数字之间没有空&#26684;），这行数字的长度不大于1000。&nbsp;&nbsp;<br>
<br>
输入数据保证：分割得到的非负整数不会大于100000000；输入数据不可能全由‘5’组成。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">对于每个测试用例，输出分割得到的整数排序的结果，相邻的两个整数之间用一个空&#26684;分开，每组输出占一行。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">0051231232050775</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">0 77 12312320</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px; color:#cc6600">1.将各个数分离（字符串形式存储），（以为‘5’为分界线）</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px; color:#cc6600">2.去除数前面的‘0’ ，然后放在二维数组 a[][]</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px; color:#cc6600">3.将a数组排序，先按长度排序（位数多，数&#20540;大） ，长度相等再按大小排序</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px; color:#cc6600">4.将a数组输出</span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
using namespace std;

void change(char s[])
{
    int i,j,k;
    char shu[1002];
    char a[1002][1002];
    int m=0;
    for(i=0;i&lt;strlen(s);i++)
    {
        k=0;
        while(s[i]=='5') i++; //去除前面的‘5’
        
        while(s[i]!='5'&amp;&amp;i&lt;strlen(s))//将数分离出来（包含0），为字符串 
        {
            shu[k++]=s[i];
            i++;    
        }
        shu[k]='\0'; //数（字符串）末尾添加‘\0’ 
        j=0;
        
        for(j=0;j&lt;strlen(shu);j++) //找到数（字符串）前面0的个数 
            if(shu[j]!='0') break;    
    
        if(shu[j]=='\0'&amp;&amp; i != strlen(s))//全部为0的情况 
        {
            shu[0]='0';
            shu[1]='\0';    
        }
        else   sscanf(shu+j,&quot;%s&quot;,shu);   //实际的数（字符串） 
        strcpy(a[m],shu);
        m++;
    }    

     
    char temp[1002];
    for(i=0;i&lt;m-1;i++) //简单选择排序 
        for(j=i+1;j&lt;m;j++)
        {
            if(strlen(a[i])&gt;strlen(a[j])) //先按长度排序 
            {
                strcpy(temp,a[i]);
                strcpy(a[i],a[j]);
                strcpy(a[j],temp);
            }
            else if(strlen(a[i])==strlen(a[j]))
            {
                if(strcmp(a[i],a[j])&gt;0)
                {
                    strcpy(temp,a[i]);
                    strcpy(a[i],a[j]);
                    strcpy(a[j],temp);    
                }
            }
            
        }
        
    for(i=0;i&lt;m-1;i++)
    if(a[i][0]!='\0')
     printf(&quot;%s &quot;,a[i]);
     printf(&quot;%s\n&quot;,a[m-1]);
}
int main()
{
    char s[1002];
    while(scanf(&quot;%s&quot;,s)!=EOF)
    {
        change(s);        
    }
    return 0;
}
</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1445_Stick（DFS_剪枝）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/07/hdu_题目1445_Stick（DFS_剪枝）/">hdu 题目1445 Stick（DFS+剪枝）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 align="center" style="color:#1a5cc8">Sticks</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 4753&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1316<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were
 originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero.
<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the
 file contains zero.<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">The output file contains the smallest possible length of original sticks, one per line.
<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">9
5 2 1 5 2 1 5 2 1
4
1 2 3 4
0</div></pre>
</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">6
5</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>黑书P181上面有分析</p>
<p>DFS&#43;剪枝</p>
<p>参考黑书分析之后的个人算法：</p>
<p>1.初始木棍的长度必须是所有木棍长度之和的约数</p>
<p>2.按木棍的递减顺序搜索</p>
<p>3.构造一根初始木棍的第一根木棍必须是最长的</p>
<p>4.2根长度相同的木棍没必要重复搜索</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
int n,a[66],sum; bool vis[66];
int cmp(const void* a,const void *b)
{
	return *(int *)b - *(int *)a;
}
bool dfs(int x,int p,int len,int num)//num代表当前找到的边长数目，len代表要找的长度 
{
    bool flag; //标记是否找到符合题意的 
    if(num==sum/len-1) return 1; //需要找到的数目为 sum/len ，只需找到 sum/len-1剩下的一定是组合成一根 
    for(int i=p+1;i&lt;=n;i++)	
        if(!vis[i] &amp;&amp; x&gt;=a[i]) 
        {
            vis[i]=1;
            if (x==a[i]) flag = dfs(len,0,len,num+1); //找到一根，x复原 
            else flag = dfs(x-a[i],i,len,num); //找到一根len长的还需要 x-a[i] 长度 
            vis[i]=0;
            if (p==0) return flag;//当搜索返回到最开始的一层时， 
            else if (flag) return 1;
            while (a[i]==a[i+1]) i++;//相同的木棍不需要再继续判断 
        }	
		return 0;
}
int main()
{
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int i;  sum=0;
		for(i=1;i&lt;=n;i++){
			scanf(&quot;%d&quot;,&amp;a[i]);
			sum += a[i];
		}
		qsort(a+1,n,sizeof(int),cmp); //按递减序列进行查找 
		memset(vis,0,sizeof(vis)); 
		int ans = sum;
		for(i=a[1];i&lt;=sum/2;i++)
			if(sum%i==0 &amp;&amp; dfs(i,0,i,0)){ ans = i; break; }
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目488_素数环（DFS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/07/NYOJ_题目488_素数环（DFS）/">NYOJ 题目488 素数环（DFS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h4 class="problem-display"></h4>
<h2 class="problem-display" align="center"><span style="color:#3366ff">素数环</span></h2>
<div class="problem-ins" align="center"><span style="color:#009900">时间限制：<span id="problem[time_limit]" class="editable highlight">1000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB
</span></div>
<div class="problem-ins" align="center"><span style="color:#009900">难度：<span class="editable highlight">2</span></span></div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>
<p>有一个整数n，把从1到n的数字无重复的排列成环，且使每相邻两个数（包括首尾）的和都为素数，称为素数环。</p>
<p>为了简便起见，我们规定每个素数环都从1开始。例如，下图就是6的一个素数环。</p>
<p><img border="0" alt="" src="http://acm.nyist.net/JudgeOnline/admin/kind/attached/20120315192417_81102.gif"></p>
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>有多组测试数据，每组输入一个n(0&lt;n&lt;20)，n=0表示输入结束。 </dd><dt>输出 </dt><dd>每组第一行输出对应的Case序号，从1开始。<br>
如果存在满足题意叙述的素数环，从小到大输出。<br>
否则输出No Answer。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">6
8
3
0</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">Case 1:
1 4 3 2 5 6
1 6 5 2 3 4
Case 2:
1 2 3 8 5 6 7 4
1 2 5 8 3 4 7 6
1 4 7 6 5 8 3 2
1 6 7 4 3 8 5 2
Case 3:
No Answer</pre>
</dd></dl>
</dd></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">1.创建数组a[21]用来存放当前素数环，a[0]存放1<br>
2.循环变量i从2开始搜索，if （isprime（a[cur]&#43;i）&nbsp; ）&nbsp; a[cur&#43;1] = i ;并标记i被访问， 然后搜索第 cur&#43;1 个素数，如果搜索第cur&#43;1个素数不成功，再次把i标记为1
<br>
3.如果 cur（当前素数个数）== n-1 ，判断最后一个元素和 1 是否相加为素数，是则输出数组 a<br>
</span></strong></p>
<pre class="cpp" name="code"> 
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

using namespace std;

int a[21]={1};
bool visit[21];
int n;

bool isprime(int x)
{
	int i;
	for(i=2;i*i&lt;=x;i++)
	{
		if(x%i==0)return false;
	}
	return true;
}
void DFS(int x)
{
	int i;
	if(x==n-1) 
	{
		if(isprime(a[x]+1))
		{
			printf(&quot;1&quot;);
			for(i=1;i&lt;n;i++)
				printf(&quot; %d&quot;,a[i]);
				puts(&quot;&quot;); 
			return;
		}
	}
	
	for(i=2;i&lt;=n;i++)
	{
		
		if(!visit[i] &amp;&amp; isprime(a[x]+i))
		{
			visit[i]=1;
			a[x+1]=i;
			DFS(x+1);
			visit[i]=0;
		}		
	}
}
int main()
{	
	int i;
	int Case=1;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		memset(visit,0,sizeof(visit));
		
		printf(&quot;Case %d:\n&quot;,Case++);
		if(n%2==0 || n==1 )
			DFS(0);			
		else printf(&quot;No Answer\n&quot;);		
	}
	return 0;
}        </pre>
<p><br>
&nbsp;</p>
<p>别人的改进代码，时间0</p>
<p>素数较少，打表给出，减少判断时间</p>
<pre class="cpp" name="code"> 
# include &lt;iostream&gt;
# include &lt;algorithm&gt;
using namespace std;
bool sushu[]={0,
0,1,1,0,1,0,1,0,
0,0,1,0,1,0,0,0,
1,0,1,0,0,0,1,0,
0,0,0,0,1,0,1,0,
0,0,0,0,1,0,1,0
};
int a[21], res[21], n, flag;
void dfs(int now)
{
	int i;
	if (now==n&amp;&amp;sushu[a[n-1]+a[n]])
	{
		flag = 0;
		for (i = 0; i&lt;n; i++)
			cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
		cout&lt;&lt;endl;
	}
	else
	{
		for (i = 2; i&lt;=n; i++)
			if (!res[i]&amp;&amp;sushu[i+a[now-1]])
			{
				res[i] = 1;
				a[now] = i;
				dfs(now+1);
				res[i] = 0;
			}
	}
}
int main()
{
	int N;
	N=1;
	while (cin&gt;&gt;n&amp;&amp;n)
	{
		flag = 1;
		a[0]=a[n]=1;
		cout&lt;&lt;&quot;Case &quot;&lt;&lt;N++&lt;&lt;&quot;:&quot;&lt;&lt;endl;
		if ((n-1)&amp;1||n==1)
			dfs(1);
		if (flag)
			cout&lt;&lt;&quot;No Answer\n&quot;;
	}
	return 0;
}        </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1241_Oil_Deposits（简单DFS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/07/hdu_题目1241_Oil_Deposits（简单DFS）/">hdu 题目1241 Oil Deposits（简单DFS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">Oil Deposits</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 8179&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 4792</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots.
 It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large
 and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.
<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100
 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either `*', representing the absence of oil, or `@', representing an oil pocket.<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">1 1
*
3 5
*@*@*
**@**
*@*@*
1 8
@@****@*
5 5 
****@
*@@*@
*@**@
@@@*@
@@**@
0 0 </div></pre>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">0
1
2
2</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>&nbsp;</p>
<p>原理和<a target="_blank" href="http://blog.csdn.net/hpu_zyh/article/details/9816053">HDU1312 一样</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;

using namespace std;


int m,n,cnt;
char a[102][102];

void DFS(int x,int y)
{
	a[x][y] = '*';
	
	if( x+1&lt;m &amp;&amp; a[x+1][y]=='@' ) DFS(x+1,y);
	if( y+1&lt;n &amp;&amp; a[x][y+1]=='@' ) DFS(x,y+1);
	if( x-1&gt;=0 &amp;&amp; a[x-1][y]=='@' ) DFS(x-1,y);
	if( y-1&gt;=0 &amp;&amp; a[x][y-1]=='@' ) DFS(x,y-1);
	
	if( x+1&lt;m &amp;&amp; y+1&lt;n  &amp;&amp; a[x+1][y+1]=='@' ) DFS(x+1,y+1);
	if( x-1&gt;=0 &amp;&amp; y-1&gt;=0  &amp;&amp; a[x-1][y-1]=='@' ) DFS(x-1,y-1);
	if( x+1&lt;m &amp;&amp; y-1&gt;=0  &amp;&amp; a[x+1][y-1]=='@' ) DFS(x+1,y-1);
	if( x-1&gt;=0 &amp;&amp; y+1&lt;n  &amp;&amp; a[x-1][y+1]=='@' ) DFS(x-1,y+1);
		
}
int main()
{
	int i,j;
	while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n),m)
	{
		for(i=0;i&lt;m;i++)
			scanf(&quot;%s&quot;,a[i]);	
		
		
		cnt=0;
		for(i=0;i&lt;m;i++)
		{
			for(j=0;j&lt;n;j++)
			{
				if(a[i][j]=='@')
				{
					DFS(i,j);cnt++;
				}				
			}
		}
	
		printf(&quot;%d\n&quot;,cnt);
	}
	return 0;
}

</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1181_变形课_（简单DFS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/07/hdu_题目1181_变形课_（简单DFS）/">hdu 题目1181 变形课 （简单DFS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">变形课</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 131072/65536 K (Java/Others)<br>
Total Submission(s): 10088&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 3759<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">呃......变形课上Harry碰到了一点小麻烦,因为他并不像Hermione那样能够记住所有的咒语而随意的将一个棒球变成刺猬什么的,但是他发现了变形咒语的一个统一规律:如果咒语是以a开头b结尾的一个单词,那么它的作用就恰好是使A物体变成B物体.
<br>
Harry已经将他所会的所有咒语都列成了一个表,他想让你帮忙计算一下他是否能完成老师的作业,将一个B(ball)变成一个M(Mouse),你知道,如果他自己不能完成的话,他就只好向Hermione请教,并且被迫听一大堆好好学习的道理.</div>
<p>&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">测试数据有多组。每组有多行，每行一个单词,仅包括小写字母,是Harry所会的所有咒语.数字0表示一组输入结束.<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">如果Harry可以完成他的作业,就输出&quot;Yes.&quot;,否则就输出&quot;No.&quot;(不要忽略了句号)<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">so
soon
river
goes
them
got
moon
begin
big
0</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">Yes.

<div style="border-bottom:#b7cbff 1px dashed; border-left:#b7cbff 1px dashed; padding-bottom:6px; background-color:#f4fbff; padding-left:6px; padding-right:6px; font-family:Times New Roman; font-size:14px; border-top:#b7cbff 1px dashed; border-right:#b7cbff 1px dashed; padding-top:6px"><div style="border-bottom:#b7cbff 1px dashed; font-family:Arial; color:#7ca9ed; font-weight:bold"><em>Hint</em></div>Hint</div><em style="font-size:1px"> </em>
Harry 可以念这个咒语:&quot;big-got-them&quot;.</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">简单递归：DFS</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px; color:#cc0000">1.将单词的首尾存在一个二维数组里a[N][2];&nbsp; 每行的a[i][0]代表第一个字母</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px; color:#cc0000">2. 从 DFS（‘b’）开始，每次都从0到单词个数k，进行DFS，找不到则返回上一级，（相同的字母可能有好多个，都必须要搜索到）</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:18px; color:#cc0000"></span></strong>&nbsp;</p>
<p><span style="font-size:18px; color:#333333"><strong>第一次代码 <span style="color:#009900">
Output LImit Exceeded </span>,有学习到了，这一般原因是</strong></span></p>
<p><strong><span style="font-size:18px">你这个<span style="color:#ff0000"> </span><span style="color:#ff0000">while() 循环没有终止条件</span>，所以没法终止程序，就会报Output Limit Exceeded<br>
</span></strong></p>
<p>
<table class="table_text " border="0" cellspacing="2" width="100%" align="center" style="border-bottom:#879bff 1px dashed">
<tbody>
<tr class="table_header" bgcolor="#1a5cc">
<td height="22" width="8%">Run ID</td>
<td width="15%">Submit Time</td>
<td>Judge Status</td>
<td width="50">Pro.ID</td>
<td width="74">Exe.Time</td>
<td width="90">Exe.Memory</td>
<td width="76">Code Len.</td>
<td width="80">Language</td>
<td width="16%">Author</td>
</tr>
<form method="get" action="/status.php" style="margin-bottom:0px">From <input class="text40" maxlength="10" name="first" style="width:70px"> Problem ID
<input class="text40" maxlength="5" name="pid"> Author <input class="text60" value="18236887539" maxlength="20" name="user"> Language
<span style="border-bottom:#879bff 1px dashed; border-left:#879bff 1px dashed; width:80px; height:22px; overflow:hidden; border-top:#879bff 1px dashed; border-right:#879bff 1px dashed">
<select name="lang" style="margin:-1px; width:81px; font-family:Arial; height:22px; font-size:14px"><option selected="selected" value="0">
All</option><option value="1">G&#43;&#43;</option><option value="2">GCC</option><option value="3">
C&#43;&#43;</option><option value="4">C</option><option value="5">Pascal</option><option value="6">
Java</option></select></span> Status <span style="border-bottom:#879bff 1px dashed; border-left:#879bff 1px dashed; width:157px; height:22px; overflow:hidden; border-top:#879bff 1px dashed; border-right:#879bff 1px dashed">
<select name="status" style="margin:-1px; width:158px; font-family:Arial; height:23px; font-size:14px"><option selected="selected" value="0">
All</option><option value="5">Accepted</option><option value="6">Wrong Answer</option><option value="8">
Presentation Error</option><option value="12">Compilation Error</option><option value="7">
Runtime Error</option><option value="9">Time Limit Exceeded</option><option value="10">
Memory Limit Exceeded</option><option value="11">Output Limit Exceeded</option></select></span>
<input class="button40" value="Go" type="submit" style="margin-top:-3px; height:22px">
<center></center>
</form>
<tr align="middle">
<td height="22">8857531</td>
<td>2013-08-07 14:21:58</td>
<td><span style="color:red">Accepted</span></td>
<td><a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=1181">1181</a></td>
<td>15MS</td>
<td>336K</td>
<td><a target="_blank" href="http://acm.hdu.edu.cn/viewcode.php?rid=8857531">785 B</a></td>
<td>C&#43;&#43;</td>
<td class="fixedsize"><a target="_blank" href="http://acm.hdu.edu.cn/userstatus.php?user=18236887539">月光“雪</a></td>
</tr>
<tr align="middle" bgcolor="#d7ebff">
<td height="22">8857485</td>
<td>2013-08-07 14:17:17</td>
<td><span style="color:green">Output Limit Exceeded</span></td>
<td><a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=1181">1181</a></td>
<td>359MS</td>
<td>216K</td>
<td><a target="_blank" href="http://acm.hdu.edu.cn/viewcode.php?rid=8857485">855 B</a></td>
<td>C&#43;&#43;</td>
<td class="fixedsize"><a target="_blank" href="http://acm.hdu.edu.cn/userstatus.php?user=18236887539">月光“雪</a></td>
</tr>
</tbody>
</table>
</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
using namespace std;

const int N=1000001;

char a[N][2];
bool vis[N];
int k;

bool DFS(char ch)
{
	int i;
	for(i=0;i&lt;k;i++)
	{
		if(!vis[i] &amp;&amp; a[i][0]==ch )
		{
			vis[i]=1;
			if(a[i][1]=='m') return true;
			if(DFS(a[i][1]))
			{
				return true;
			} 
			vis[i]=0;
		}
	}
	return false;

}
int main()
{
	char s[100002];
	int i,index=-1;
	k=0;
	while(scanf(&quot;%s&quot;,s)!=EOF)//第一次是忘了添加 ！= EOF 结果<strong><span style="font-size:12px;color:#009900;">Output LImit Exceede</span></strong>	                                                                                                                                  {
		if(s[0]=='0')
		{
		//	for(i=0;i&lt;k;i++) printf(&quot;%d: %c    %c\n&quot;,i,a[i][0],a[i][1]);
	
			for(i=0;i&lt;k;i++) vis[i]=0;
			if( DFS('b') )   printf(&quot;Yes.\n&quot;);
			else printf(&quot;No.\n&quot;);
			k=0;
			continue;
		}

		a[k][0] = s[0];
		a[k++][1] = s[strlen(s)-1];
	}
	return 0;
}

</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1312_Red_and_Black_(_DFS_)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/07/hdu_题目1312_Red_and_Black_(_DFS_)/">hdu 题目1312 Red and Black ( DFS )</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">Red and Black</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green"><strong>Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 6594&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 4184<br>
</strong></span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can't move on red tiles, he can move
 only on black tiles.<br>
<br>
Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>
<br>
There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>
<br>
'.' - a black tile <br>
'#' - a red tile <br>
'@' - a man on a black tile(appears exactly once in a data set) <br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">6 9
....#.
.....#
......
......
......
......
......
#@...#
.#..#.
11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
11 6
..#..#..#..
..#..#..#..
..#..#..###
..#..#..#@.
..#..#..#..
..#..#..#..
7 7
..#.#..
..#.#..
###.###
...@...
###.###
..#.#..
..#.#..
0 0</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">45
59
6
13</div></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">简单深搜，</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">1。获取@的位置</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">2。将@变为‘0’</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">3。从@的位置开始，设为当前位置，将与当前位置相连的‘.’都变为‘0’</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">4。计算最后看字符‘0’的个数，</span></strong></p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;

using namespace std;

char a[21][21];


void DFS(int x,int y,int w,int h)
{
	if(a[x][y]=='.')  a[x][y]='0';
	
	if(a[x+1][y]=='.'&amp;&amp;x+1&lt;h) DFS(x+1,y,w,h);
	if(a[x-1][y]=='.'&amp;&amp;x-1&gt;=0) DFS(x-1,y,w,h);	
	if(a[x][y+1]=='.'&amp;&amp;y+1&lt;w) DFS(x,y+1,w,h);
	if(a[x][y-1]=='.'&amp;&amp;y-1&gt;=0) DFS(x,y-1,w,h);
}

void count(int w,int h)
{
	int i,j,num=0;
	for(i=0;i&lt;h;i++)
		for(j=0;j&lt;w;j++)
		{
			if(a[i][j] == '0')
				num++;
		}
	printf(&quot;%d\n&quot;,num);
}

int main() 
{
	int i,j,x,y,w,h;
	while(scanf(&quot;%d%d&quot;,&amp;w,&amp;h),w&amp;&amp;h)
	{
		getchar();
		for(i=0;i&lt;h;i++)
		{
			for(j=0;j&lt;w;j++)
			{
				scanf(&quot;%c&quot;,&amp;a[i][j]);
				if(a[i][j]=='@')
				{
					x=i;
					y=j;
				}
			}	
			getchar();	
		}	

		a[x][y]='0';
		DFS(x,y,w,h);	
		count(w,h);
	}
	return 0;
}

</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1518_Square_（DFS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/07/hdu_题目1518_Square_（DFS）/">hdu 题目1518 Square （DFS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">Square</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 10000/5000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 5893&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1878<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">Given a set of sticks of various lengths, is it possible to join them end-to-end to form a square?<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The first line of input contains N, the number of test cases. Each test case begins with an integer 4 &lt;= M &lt;= 20, the number of sticks. M integers follow; each gives the length of a stick - an integer between 1 and 10,000.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each case, output a line containing &quot;yes&quot; if is is possible to form a square; otherwise output &quot;no&quot;.<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">3
4 1 1 1 1
5 10 20 30 40 50
8 1 7 2 6 4 4 3 5</div></pre>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">yes
no
yes</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">从第一个开始，搜索后面的看是否能正好凑够边长，小鱼的话继续深搜，大于则返回上一级，等于的话，找的的边长数&#43;&#43;，直到边长数到达3（剩下一个不用找了，肯定也是一个边长）！！</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">第一次<span style="color:#ff0000">超时</span>，每次都从第一个查找到最后一个，数据多的话超时</span></strong></p>
<strong><span style="font-family:楷体_GB2312; font-size:18px"></span></strong><pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int  n,a[21];
bool visit[21];
int sign;

bool DFS(int sum,int cnt,int x,int adv)
{
    if(cnt == 3) //找到3个边长了，剩下一个不用再找    
        return true;    
        
    if(sum == adv) //组合成一个边长 
    {
        if(DFS(0,cnt+1,x+1,adv)) //组合下一个边长 
            return true;
        else return false;
    }
    else //当前边不能组成一个边长，需要向下继续组合 
    {    
        int i;
        for(i = 0; i &lt; n; ++i)
        {
            if(!visit[i])
            {    
                if(sum + a[i] &lt;= adv)
                {
                    visit[i]=1;
                    if(DFS(sum+a[i],cnt,i+1,adv))
                    {
                        return true;
                    } 
                    visit[i] = 0;
                }
            }
        }
    }
    return false; 
}
int main()
{
    int t,i,len;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        len = 0;
        int max=0;
        for(i=0;i&lt;n;i++)
        {
            scanf(&quot;%d&quot;,&amp;a[i]);
            len += a[i];
            if(max&lt;a[i]) max = a[i];
        }
        if(len%4==0&amp;&amp; max&lt;= len/4)
        {
            for(i=0;i&lt;n;i++) visit[i]=0;
            if(DFS(0,0,0,len/4)) printf(&quot;yes\n&quot;);
            else printf(&quot;no\n&quot;);    
        }
        else
        {
            printf(&quot;no\n&quot;);
        }    
    }
    return 0;
} </pre>
<p><br>
&nbsp;</p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px"></span></strong>&nbsp;</p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px"></span></strong>&nbsp;</p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">第二次改进，将每次的查找起点变为边长个数（从前往后找的话，每次都能将当前的元素个后面的组成一个边长，所以找到一个边长，则该元素肯定被用过了visit，）</span></strong></p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
using namespace std;
 
int  n,a[21];
bool visit[21];

bool DFS(int sum,int cnt,int x,int adv)
{
	if(cnt == 3) //找到3个边长了，剩下一个不用再找	
		return true;	
		
	if(sum == adv) //组合成一个边长 
	{
		if(DFS(0,cnt+1,cnt+1,adv)) //组合下一个边长 
			return true;
		else return false;
	}
	else //当前边不能组成一个边长，需要向下继续组合 
	{	
		int i;
		for(i = x; i &lt; n; ++i)
		{
			if(!visit[i])
			{	
				if(sum + a[i] &lt;= adv) //和不能大于边长 
				{
					visit[i]=1;
					if(DFS(sum+a[i],cnt,i+1,adv))
					{
						return true;
					} 
					visit[i] = 0;
				}
			}
		}
	}
	return false; 
}
int main()
{
	int t,i,len;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		len = 0;
		int max=0;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i]);
			len += a[i];
			if(max&lt;a[i]) max=a[i];//寻找最大值。 
		}

		if(len%4==0&amp;&amp; max&lt;=len/4) //如果和不是4的倍数，或者最大的数超过了边长 
		{
			for(i=0;i&lt;n;i++) visit[i]=0;//初始化visit数组 
			
			if(DFS(0,0,0,len/4)) printf(&quot;yes\n&quot;);
			else printf(&quot;no\n&quot;);	
		}
		else
		{
			printf(&quot;no\n&quot;);
		}	
	}
	return 0;
} </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_1075_What_Are_You_Talking_About(字典树)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/07/hdu_1075_What_Are_You_Talking_About(字典树)/">hdu 1075 What Are You Talking About(字典树)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">What Are You Talking About</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 10000/5000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 102400/204800 K (Java/Others)<br>
Total Submission(s): 10368&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 3305<br>
</span></strong></span><br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">Ignatius is so lucky that he met a Martian yesterday. But he didn't know the language the Martians use. The Martian gives him a history book of Mars and a dictionary when it leaves. Now Ignatius want to translate the history book
 into English. Can you help him?<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The problem has only one test case, the test case consists of two parts, the dictionary part and the book part. The dictionary part starts with a single line contains a string &quot;START&quot;, this string should be ignored, then some lines
 follow, each line contains two strings, the first one is a word in English, the second one is the corresponding word in Martian's language. A line with a single string &quot;END&quot; indicates the end of the directory part, and this string should be ignored. The book
 part starts with a single line contains a string &quot;START&quot;, this string should be ignored, then an article written in Martian's language. You should translate the article into English with the dictionary. If you find the word in the dictionary you should translate
 it and write the new word into your translation, if you can't find the word in the dictionary you do not have to translate it, and just copy the old word to your translation. Space(' '), tab('\t'), enter('\n') and all the punctuation should not be translated.
 A line with a single string &quot;END&quot; indicates the end of the book part, and that's also the end of the input. All the words are in the lowercase, and each word will contain at most 10 characters, and each line will contain at most 3000 characters.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">In this problem, you have to output the translation of the history book.<br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">START
from fiwo
hello difh
mars riwosf
earth fnnvk
like fiiwj
END
START
difh, i'm fiwo riwosf.
i fiiwj fnnvk!
END</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">hello, i'm from mars.
i like earth!

<div style="border-bottom:#b7cbff 1px dashed; border-left:#b7cbff 1px dashed; padding-bottom:6px; background-color:#f4fbff; padding-left:6px; padding-right:6px; font-family:Times New Roman; font-size:14px; border-top:#b7cbff 1px dashed; border-right:#b7cbff 1px dashed; padding-top:6px"><div style="border-bottom:#b7cbff 1px dashed; font-family:Arial; color:#7ca9ed; font-weight:bold"><em>Hint</em></div>
Huge input, scanf is recommended.
</div><em style="font-size:1px"> </em></div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">利用字典建立字典树，（前面的字符串放在字典树中后面字符串的最后一个字母出，其他字母处赋&#20540;“#”）然后依次取出输入字符串中的单词，在字典树中查找，没有找到输出原字符串，还有不是字母的按原来的输出<br>
</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">第一次WA，没有考虑到输入的字符串中 是 字典中单词的前缀的情况，改正了一下AC了</span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct Tire
{
    Tire * child[26];
    char word[12];
}Tire;

Tire * root;

void insert(char *s1,char *s2)
{
    int i,j;
    Tire *p,*q;
    q = root;
    
    for(i=0;i&lt;strlen(s2);i++)
    {
        if(q-&gt;child[s2[i]-'a']) q = q-&gt;child[s2[i]-'a'];
        else 
        {
            p = (Tire *)malloc(sizeof(Tire));
        	strcpy(p-&gt;word,&quot;#&quot;);
            for(j=0;j&lt;26;j++) p-&gt;child[j] = NULL;
            
            q-&gt;child[s2[i]-'a'] = p;
            q = p;    
        }
    }
    strcpy(q-&gt;word,s1);
}
bool find(Tire *q,char *s,int m)
{
    if(m==strlen(s) )
    { 
    //	printf(&quot;cmp=%d\n&quot;,strcmp(q-&gt;word,&quot;#&quot;));
		if(strcmp(q-&gt;word,&quot;#&quot;)==0) return false;//这里考虑s是字典树中单词的前缀情况
        printf(&quot;%s&quot;,q-&gt;word);
        return true;
    }
    if(q-&gt;child[s[m]-'a']) find(q-&gt;child[s[m]-'a'],s,m+1);
    else return false;
}

int main()
{
    char s[3003];
    char s1[12],s2[12],temp[12];
    int i,k;
    root = (Tire*)malloc(sizeof(Tire));
    for(i=0;i&lt;26;i++) root-&gt;child[i]=NULL;
    
    gets(s1);//START 
    while(scanf(&quot;%s&quot;,s1),s1[0]!='E')
    {
        scanf(&quot;%s&quot;,s2);
        insert(s1,s2);    
    }
    getchar();//回车 
    gets(s);//STARAT

    while(gets(s) ,s[0]!='E')
    {
        for(i=0;i&lt;strlen(s);i++)
        {
            if(s[i]==' ') //处理空格 
            {
                printf(&quot; &quot;);
                continue;
            }
            k=0;
            if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z')//单词 
            {
                while(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z')
                {
                    temp[k++] = s[i++];
                }
                temp[k]='\0';i--;
                //    printf(&quot;*%s*&quot;,temp);
                if(!find(root,temp,0)) printf(&quot;%s&quot;,temp);
            }
            else if(s[i]=='\t')     printf(&quot;\t&quot;);
     		else  printf(&quot;%c&quot;,s[i]);  //其他字符 
        }
        puts(&quot;&quot;); 
    }

    return 0;
}</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1251_统计难题_（字典树）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/06/hdu_题目1251_统计难题_（字典树）/">hdu 题目1251 统计难题 （字典树）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<h1 align="center" style="color:#1a5cc8">统计难题</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 4000/2000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 131070/65535 K (Java/Others)<br>
Total Submission(s): 13654&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 5856<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.<br>
<br>
注意:本题只有一组测试数据,处理到文件结束.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">对于每个提问,给出以该字符串为前缀的单词的数量.<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">banana
band
bee
absolute
acm

ba
b
band
abc</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">2
3
1
0</div></pre>
</div>
<div class="panel_bottom"><strong><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></strong></div>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:24px">思路：</span></strong></p>
<p><strong><span style="font-size:18px"><span style="font-family:KaiTi_GB2312">1.首先建立字典树，建树的时候<span style="color:#ff0000">统计每个单词出现的次数（这里和NYOJ 题目290 不同）</span></span></span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">2.从字典树根节点开始，查找的要查询的字符串最后一个字母，输出其出现次数即可；</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">3.题目中要求一个空行结束单词表的输入，用：<span style="color:#33cc00">while(gets(s),(strcmp(s,&quot;&quot;)!=0))</span></span></strong></p>
<strong><span style="font-family:KaiTi_GB2312; font-size:24px"><span style="color:#ff0000"></span></span></strong><pre class="cpp" name="code">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

typedef struct dictree
{
    dictree * child[26];
    int cnt;
}dictree;

int num;

void insert (dictree * &amp;root,char * s)
{
    int i,j;
    dictree *p,*q;
    q = root;
    
    for(i=0;i&lt;strlen(s);i++)//在这里要统计每个字母出现次数
    {
        if(q-&gt;child[s[i]-'a'])
        {
            
            q = q-&gt;child[s[i]-'a'];
            q-&gt;cnt++;//已有的字母，次数++
        }    
        else //新的字母cnt = 1；
        {
            p = (dictree *)malloc(sizeof(dictree));
            for(j=0;j&lt;26;j++) p-&gt;child[j]=NULL;
            p-&gt;cnt = 1;
            
            q-&gt;child[s[i]-'a'] = p;
            q = p;
        }
    }
} 

void count(dictree * root,char * s)
{
    dictree * p,* q;
    q = root;
    int i;
    
    for(i=0;i&lt;strlen(s);i++)
    {
        if( !q-&gt;child[s[i]-'a'] )//字典树中没有该字母 
        {
            printf(&quot;0\n&quot;);
            return; 
        }
        else q = q-&gt;child[s[i]-'a'];
    }
    if(i==strlen(s))  printf(&quot;%d\n&quot;,q-&gt;cnt);//q指向要查询单词的最后一个字母 
    else
    {
        printf(&quot;0\n&quot;);
        return;
    } 
}

int main()
{
    int i;
    char s[11];
    
    dictree * root;//根结点初始化 
    root = (dictree *)malloc(sizeof(dictree));
    for(i=0;i&lt;26;i++) root-&gt;child[i]=NULL;
    
    while(gets(s),(strcmp(s,&quot;&quot;)!=0))//空行结束 单词表的输入
    {
        insert(root,s);
    }
    num = 0;
    while(scanf(&quot;%s&quot;,s)!=EOF)
        count(root,s);
        
     return 0;
}</pre>
<p><br>
<br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目290_动物统计加强版" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/06/NYOJ_题目290_动物统计加强版/">NYOJ 题目290 动物统计加强版</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h4 class="problem-display"></h4>
<h2 class="problem-display" align="center">动物统计加强版</h2>
<div class="problem-ins" align="center">时间限制：<span id="problem[time_limit]" class="editable highlight">3000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">150000</span> KB</div>
<div class="problem-ins" align="center">难度：<span class="editable highlight">4</span></div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>在美丽大兴安岭原始森林中存在数量繁多的物种，在勘察员带来的各种动物资料中有未统计数量的原始动物的名单。科学家想判断这片森林中哪种动物的数量最多，但是由于数据太过庞大，科学家终于忍受不了，想请聪明如你的ACMer来帮忙。
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>第一行输入动物名字的数量N(1&lt;= N &lt;= 4000000),接下来的N行输入N个字符串表示动物的名字（字符串的长度不超过10,字符串全为小写字母，并且只有一组测试数据）。<br>
</dd><dt>输出 </dt><dd>输出这些动物中最多的动物的名字与数量，并用空&#26684;隔开（数据保证最多的动物不会出现两种以上）。 <br>
</dd><dt>样例输入 </dt><dd>
<pre id="sample_input">10
boar
pig
sheep
gazelle
sheep
sheep
alpaca
alpaca
marmot
mole</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">sheep 3</pre>
</dd></dl>
</dd></dl>
<dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px; color:#ff0000">字典树的应用</span></p>
<div><span style="font-size:24px"><span style="color:red">字典树</span>：是一种用于快速检索的<span style="color:red">多叉树</span>结构。字典树把要查找的关键词看作一个字符序列，并根据构成关键词字符的先后顺序构造用于检索的树结构；一棵m度的字典树树或者为空，或者由m棵m度的Trie树构成。</span></div>
<div><span style="font-size:24px"><img alt="" src="http://img.blog.csdn.net/20130806124709484" width="627" height="534"></span></div>
<div>
<div><span style="font-size:24px; color:red">特点： </span></div>
<div><span style="font-size:24px">利用串的公共前缀-&gt;<span style="color:red">节约</span>内存 </span>
</div>
<div><span style="font-size:24px"><span style="color:red">根</span>结点<span style="color:red">不</span>包含任何字母</span></div>
<div><span style="font-size:24px">其余结点仅包含<span style="color:red">一个</span>字母(<span style="color:red">非元素</span>)</span></div>
<div><span style="font-size:24px">每个结点的子节点包含字母<span style="color:red">不同</span></span></div>
<div><span style="font-size:24px; color:#ff0000"></span>&nbsp;</div>
</div>
<div><span style="font-size:24px"><span style="color:red">字典树</span><span style="color:#333399">的查找（最主要的操作）</span></span></div>
<div>
<div><span style="font-size:24px">(1)在trie树上进行检索<span style="color:red">总是始于根结点</span>。</span></div>
<div><span style="font-size:24px">(2)取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索。 </span>
</div>
<div><span style="font-size:24px">(3)在某个结点处，关相应的子树上，取得要查找关键词的第二个字母，并进一步选择对应的子树进行检索。</span></div>
<div><span style="font-size:24px">(4) ... </span></div>
<div><span style="font-size:24px">键词的所有字母已被取出，则读取<span style="color:red">附在该结点上的信</span><span style="color:red">息</span>，即完成查找。</span></div>
<div>
<div><span style="font-size:24px; color:#333399"></span>&nbsp;</div>
<div><span style="font-size:24px"><span style="color:#333399">Trie</span><span style="color:#333399">的数据结构定义</span></span></div>
</div>
<div>
<div>
<div><span style="font-size:24px">struct dictree&nbsp;&nbsp; </span></div>
<div><span style="font-size:24px">{&nbsp;&nbsp; </span></div>
<div><span style="font-size:24px">&nbsp;&nbsp;&nbsp; dictree *child[26];&nbsp;&nbsp; </span></div>
<div><span style="font-size:24px">&nbsp;&nbsp;&nbsp; int n;&nbsp;&nbsp; <span style="color:red">//</span><span style="color:red">根据需要变化</span></span></div>
<div><span style="font-size:24px">};&nbsp;&nbsp; </span></div>
<div><span style="font-size:24px"></span></div>
<div><span style="font-size:24px">dictree *root; </span></div>
</div>
</div>
</div>
<p><span style="font-size:24px"></span>&nbsp;</p>
<span style="font-family:KaiTi_GB2312"></span>
<div>
<div><span style="font-size:24px">特点：数据量大 </span></div>
<div><span style="font-size:24px">主要任务：查找单词 </span></div>
<div><span style="font-size:24px">解决方法：字典树 </span></div>
<div><span style="font-size:24px">字典树结构（除指针）：单词信息（英文）&nbsp;</span><span style="font-size:24px">&nbsp;</span></div>
</div>
<p><span style="font-size:24px"></span>&nbsp;</p>
<div>
<div><span style="font-size:24px">HDOJ-1075 What Are You Talking About </span></div>
<div><span style="font-size:24px">HDOJ-1251 统计难题 </span></div>
<div><span style="font-size:24px">HDOJ-1298 T9 </span></div>
<div><span style="font-size:24px">HDOJ-1800&nbsp;&nbsp; Flying to the Mars </span></div>
<div><span style="font-size:24px">ZOJ-1109&nbsp;&nbsp;&nbsp;&nbsp; </span><a target="_blank" href="http://acm.zju.edu.cn/show_problem.php?pid=1109"><span style="font-size:24px; color:#ff0000">Language of FatMouse</span></a></div>
</div>
<p>&nbsp;</p>
<strong><span style="font-family:楷体_GB2312; font-size:18px"></span></strong>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">第一步：1.建立字典树，</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></strong></p>
<span style="font-family:楷体_GB2312; font-size:18px"></span>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">第一次思想（<span style="color:#ff0000">错误</span>）：</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">从第一层向下统计，每次都找到每层次数最多的（这里错误！！）</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:18px">如测试数据：</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:18px">5</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:18px">abc</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:18px">ade</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:18px">afr</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:18px">bb</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:18px">bb</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:18px"></span></strong>&nbsp;</p>
<p>&nbsp;错误代码：</p>
<pre class="cpp" name="code"> 
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
using namespace std;

typedef struct dictree
{
	dictree * child[26];
	int  cnt;
}dictree;

void find(dictree * root)
{	
	int i,j;
	int flag = 1;
	for(i=0;i&lt;26;i++) if(root-&gt;child[i]) flag = 0;
	
	if(flag){
		printf(&quot; %d\n&quot;,root-&gt;cnt);
		return;	
	} 
	
	
	dictree *p;
	dictree *q;
	q = root;
	int index;
	int max = 0;
	for(i=0;i&lt;26;i++)//寻找该层次数最大的然后向下查找，！！！这里错误 r如： abc acd aef bb bb 则先从a向下找了，错误！！！！
	{
		p=q-&gt;child[i];
		if(p)
		{
			if(max&lt;p-&gt;cnt)
			{
				max=p-&gt;cnt;
				index = i;
			} 
		}
		
			
	}
	p = q-&gt;child[index];
	if(p)
	{
		printf(&quot;%c&quot;,index+'a');
		find(p);
	}
}
void insert(dictree * &amp;root,char s[])//建立字典树
{
	int j,i;
	dictree *p;
	dictree *q;
	q = root;
	for(i=0;i&lt;strlen(s);i++)
	{
		if(q-&gt;child[s[i]-'a'])
		{
			
			q = q-&gt;child[s[i]-'a'];
			q-&gt;cnt++;
		}
		else
		{
			p = (dictree * )malloc(sizeof(dictree));//分配p 
			p-&gt;cnt = 1;  
			for(j=0;j&lt;26;j++)	p-&gt;child[j] = NULL;
			
			q-&gt;child[s[i]-'a'] = p;
			q = p;			
		}
	}
}

int main()
{
	int i;
	dictree * root;
	root=(dictree *)malloc(sizeof(dictree));
	for(i=0;i&lt;26;i++)	root-&gt;child[i] = NULL;
		
	int n;
	char s[11];
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		scanf(&quot;%s&quot;,s);
		insert(root,s);
	}
	find(root);
 	return 0;
}
        </pre>
<p><br>
</p>
<p>&nbsp;</p>
<p><strong><span style="font-size:18px">第二次：</span></strong></p>
<p><strong><span style="font-size:18px">统计每个单词最后一个字母的出现次数，找最多的，但是找的过程中<span style="color:#ff0000">错误</span></span></strong></p>
<p><strong><span style="font-size:18px">建树过程中只统计最后一个单词出现次数，不能每个字母都统计次数</span></strong></p>
<p><strong><span style="font-size:18px">如：</span></strong></p>
<p><strong><span style="font-size:18px">5</span></strong></p>
<p><strong><span style="font-size:18px">abcde</span></strong></p>
<p><strong><span style="font-size:18px">abcde</span></strong></p>
<p><strong><span style="font-size:18px">abcde</span></strong></p>
<p><strong><span style="font-size:18px">ab</span></strong></p>
<p><strong><span style="font-size:18px">ab</span></strong></p>
<p><strong><span style="font-size:18px">此时b是5词，但ab不是最多的，所以会出错。。。！！！！</span></strong></p>
<pre class="cpp" name="code"> 
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
using namespace std;


typedef struct dictree
{
	dictree * child[26];
	int  cnt;
}dictree;

char str[12];
int num;

void insert(dictree * &amp;root,char s[])
{

	int j,i;
	dictree *p;
	dictree *q;
	q = root;
	for(i=0;i&lt;strlen(s);i++)
	{
		if(q-&gt;child[s[i]-'a'])
		{
			
			q = q-&gt;child[s[i]-'a'];
			q-&gt;cnt++;//这里错误，应该放到外面++
		}
		else
		{
			p = (dictree * )malloc(sizeof(dictree));//分配p 
			p-&gt;cnt = 1;  
			for(j=0;j&lt;26;j++)	p-&gt;child[j] = NULL;
			
			q-&gt;child[s[i]-'a'] = p;
			q = p;			
		}
	}
	if(q-&gt;cnt&gt;num) {//单词结束后，看最后一个字母出现次数
		num = q-&gt;cnt;
		strcpy(str,s);	
	}

}

int main()
{
	int i;
	dictree * root;
	root=(dictree *)malloc(sizeof(dictree));
	for(i=0;i&lt;26;i++)	root-&gt;child[i] = NULL;
		
	int n;
	char s[12];
	scanf(&quot;%d&quot;,&amp;n);
	num=0;
	while(n--)
	{
		scanf(&quot;%s&quot;,s);
	//	puts(s);
		insert(root,s);
	}
	printf(&quot;%s %d\n&quot;,str,num);
 	return 0;
}        </pre>
<p><br>
&nbsp;</p>
<p>最后AC代码：</p>
<p>将前面的都改进</p>
<pre class="cpp" name="code"> 

#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
using namespace std;


typedef struct dictree
{
	dictree * child[26];
	int  cnt;
}dictree;

char str[11];
int num;

void insert(dictree * &amp;root,char s[])
{

	int j,i;
	dictree *p;
	dictree *q;
	q = root;
	for(i=0;i&lt;strlen(s);i++)
	{
		if(q-&gt;child[s[i]-'a'])
		{
			
			q = q-&gt;child[s[i]-'a'];	
		}
		else
		{
			p = (dictree * )malloc(sizeof(dictree));//分配p 
			p-&gt;cnt = 0;  
			for(j=0;j&lt;26;j++)	p-&gt;child[j] = NULL;
			
			q-&gt;child[s[i]-'a'] = p;
			q = p;			
		}
	}
	q-&gt;cnt++;//这里放到外面，只统计最后一个字母出现次数
	if(q-&gt;cnt&gt;num) {
		num = q-&gt;cnt;
		strcpy(str,s);	
	}

}

int main()
{
	int i;
	dictree * root;
	root=(dictree *)malloc(sizeof(dictree));
	for(i=0;i&lt;26;i++)	root-&gt;child[i] = NULL;
	
	int n;
	char s[11];
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		scanf(&quot;%s&quot;,s);
		insert(root,s);
	}
	printf(&quot;%s %d\n&quot;,str,num);
 	return 0;
}

                </pre>
<p><br>
&nbsp;</p>
</dl>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1116_Play_on_Words（并查集___欧拉路）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/05/hdu_题目1116_Play_on_Words（并查集___欧拉路）/">hdu 题目1116 Play on Words（并查集 + 欧拉路）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<h1 style="color:rgb(26,92,200); text-align:center; font-family:'Times New Roman'">
Play on Words</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green">Time Limit: 10000/5000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 4142&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1337<br>
</span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
Some of the secret doors contain a very interesting word puzzle. The team of archaeologists has to solve it to open that doors. Because there is no other way to open the doors, the puzzle is very important for us.&nbsp;<br>
<br>
There is a large number of magnetic plates on every door. Every plate has one word written on it. The plates must be arranged into a sequence in such a way that every word begins with the same letter as the previous word ends. For example, the word ``acm''
 can be followed by the word ``motorola''. Your task is to write a computer program that will read the list of words and determine whether it is possible to arrange all of the plates in a sequence (according to the given rule) and consequently to open the door.&nbsp;<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing a single integer number Nthat indicates the number of plates (1 &lt;= N &lt;= 100000). Then exactly Nlines follow,
 each containing a single word. Each word contains at least two and at most 1000 lowercase characters, that means only letters 'a' through 'z' will appear in the word. The same word may appear several times in the list.&nbsp;<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
Your program has to determine whether it is possible to arrange all the plates in a sequence such that the first letter of each word is equal to the last letter of the previous word. All the plates from the list must be used, each exactly once. The words mentioned
 several times must be used that number of times.&nbsp;<br>
If there exists such an ordering of plates, your program should print the sentence &quot;Ordering is possible.&quot;. Otherwise, output the sentence &quot;The door cannot be opened.&quot;.&nbsp;<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">3
2
acm
ibm
3
acm
malform
mouse
2
ok
ok</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">The door cannot be opened.
Ordering is possible.
The door cannot be opened.</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;<br>
<br>
<div class="panel_bottom"><strong><span style="font-size:18px">第一次用深搜做的，提交之后出现&nbsp;<span style="color:rgb(0,128,0)">Runtime Error</span><span style="color:rgb(0,128,0)">(STACK_OVERFLOW)</span></span></strong></div>
<div class="panel_bottom"><span style="color:rgb(0,128,0)">&nbsp;</span><strong><span style="font-size:18px">然后看到可以使用<span style="color:rgb(51,255,51)">#pragma comment(linker, &quot;/STACK:102400000,102400000&quot;)</span>来解决栈溢出，加了之后然后提交，结果超时了</span></strong></div>
<div class="panel_bottom"><strong><span style="font-size:18px">一下是超时代码：</span></strong></div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_bottom">等我改进。。。。。</div>
<p>&nbsp;</p>
<pre class="cpp" name="code">/*　　超时了、、、、
2013/08/04 16:02
author :zyh
*/

#define N 100003
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#pragma comment(linker, &quot;/STACK:102400000,102400000&quot;)//解决 STACK＿Overflow

using namespace std;

char a[N][3];
char s[1002];
bool visit[N];
int sign,n;

void DFS(int i,int num)
{
	if(sign || num == n) return;
//	printf(&quot;i=%d,num=%d,a=%c\n&quot;,i,num,a[i][1]);
	visit[i] = 1;	num++;
	int j,flag = 0;
	for(j=0; j&lt;n; j++)
	{
		if(j!= i &amp;&amp; !visit[j] &amp;&amp; a[i][1] == a[j][0] )  //找头 和第i行尾相同的 
		{
	//		printf(&quot;j=%d,a=%c\n&quot;,j,a[j][0]);
				flag = 1;
				DFS(j,num);		
		}	
	}
	if(!flag &amp;&amp; num == n ) //没有找到与末尾相同的，但是是序列最后一个结点 
	{
		sign = 1; return;
	}
	else {
		visit[i] = 0;	
		return;	
	}
}

int main()
{
	int i,t;

	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		getchar();
		for(i=0;i&lt;n;i++)
		{
			gets(s);
			a[i][0] = s[0];
			a[i][1] = s[strlen(s)-1];
		}	
	//	for(i=0;i&lt;n;i++) printf(&quot;%d : %c %c\n&quot;,i,a[i][0],a[i][1]);
		sign = 0;
		for(i=0;i&lt;n;i++) visit[i] = 0;
		
		for(i=0;i&lt;n;i++)	DFS(i,0); 	
		
		if(sign) printf(&quot;Ordering is possible.\n&quot;);
		else printf(&quot;The door cannot be opened.\n&quot;);
	}
	return 0;
}</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
</div>
<br>
<p></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">欧拉回路<br>
1、欧拉路：在无孤立顶点的图中，若存在一条路，经过图中每条边一次且仅一次，则称此路为欧拉路。如下图（左）中存在一条从顶点1到顶点6的欧拉路。后面的例题（一笔画问题）本质上就是判断一个图是否存在欧拉路。<br>
2、欧拉回路：在无孤立顶点的图中，若存在一条路，经过图中每条边一次且仅一次，且回到原来位置，则称此路为欧拉回路。如下图（右）中任意两个顶点之间都存在欧拉回路。著名的柯&#23612;斯堡七桥问题（图论起源）本质上就是讨论一个图的欧拉回路问题。<br>
3、欧拉图：存在欧拉回路的图，称为欧拉图，图（右）所示的图就是一个欧拉图。</span></strong><br>
</p>
<p><img src="http://img.blog.csdn.net/20130805233541468" alt=""><br>
</p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">定理1：存在欧拉路的条件：图是连通的，且存在0个或2个奇点。如果存在2个奇点，则欧拉路一定是从一个奇点出发，以另一个奇点结束。<br>
定理2：存在欧拉回路的条件：图是连通的，且不存在奇点。</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px"><br>
6、哈密尔顿图：在无孤立顶点的连通图中，若存在一条路，经过图中每个顶点一次且仅一次，则称此图为哈密尔顿图。<br>
7、哈密尔顿环：是一条沿着图的n条边环行的路径，它访问每一个顶点一次且仅一次，并且返回到它的开始位置。</span></strong><br>
<br>
<br>
</p>
<p><strong><span style="font-size:18px; color:#ff9900"><br>
</span></strong></p>
<p><strong><span style="font-size:18px; color:#ff9900">1.首先建立并查集，判断是否是一个根（是否有孤立顶点），首先必须满足一个根结点</span></strong></p>
<p><strong><span style="font-size:18px; color:#ff9900">2.判断各个点的入度和出度， 入度和出度 都为0 或1，欧拉路</span></strong></p>
<p><strong><span style="font-size:18px; color:#ff9900">3.中间结点的入度必须等于出度</span></strong></p>
<p><br>
</p>
<p>code：</p>
<p></p>
<pre name="code" class="cpp">/*Problem : 1116 ( Play on Words )     Judge Status : Accepted
RunId : 8840032    Language : C++    Author : 18236887539
Code Render Status : Rendered By HDOJ C++ Code Render Version 0.01 Beta*/</pre><pre name="code" class="cpp">#define N 30
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
using namespace std;

int father[N],in[N],out[N];
bool visit[N];

int find(int x)
{
    while( father[x] != x)
     x = father[x];
    return x;
}

int main()
{
    int i,t,n,a,b;
    char s[1002];
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        for(i=0;i&lt;N;i++)
        {
            father[i] = i;
            in[i] = out[i] = visit[i] = 0;
        }
        scanf(&quot;%d&quot;,&amp;n);
        getchar();
        while(n--)
        {
            gets(s);
            a = s[0]-'a';
            b = s[strlen(s)-1]-'a';
            in[b]++;
            out[a]++;
            father[a] = father[b] = find(a);
            visit[a] = visit[b] = 1;
        }
        
        int cnt=0;
        for(i=0;i&lt;N;i++)
        {
            if(visit[i] &amp;&amp; father[i]==i ) cnt++;
        }
        
        if(cnt&gt;1)//根节点个数大于1，不满足 
        {
            printf(&quot;The door cannot be opened.\n&quot;);
            continue;
        }
        
        int mid,front,rear;
        mid = front = rear = 0;
        
        for(i=0;i&lt;N;i++)
        {
            if(visit[i] &amp;&amp; in[i]!=out[i])//没有存的略过， 入度等于出度的 略过 
            {
                if( out[i]+1 == in[i] ) rear++;
                else if(out[i] == in[i]+1) front++;
                else mid++;
            }
        }
    //    printf(&quot;mid=%d,f=%d,r=%d\n&quot;,mid,front,rear);
        if(mid&gt;0)  
        {
            printf(&quot;The door cannot be opened.\n&quot;);
            continue;
        }
        if( (front==1&amp;&amp;rear==1) ||( front==0&amp;&amp;rear==0))
        {
            printf(&quot;Ordering is possible.\n&quot;);
            continue;
        }
        else     printf(&quot;The door cannot be opened.\n&quot;);                    
    }
    return 0;
}</pre><br>
<br>
<p></p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1272_小希的迷宫_（并查集）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/05/hdu_题目1272_小希的迷宫_（并查集）/">hdu 题目1272 小希的迷宫 （并查集）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">小希的迷宫</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 19645&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 6008<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。
<br>
<img src="http://acm.hdu.edu.cn/data/images/C20-1007-1.jpg" alt=""><br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。
<br>
整个文件以两个-1结尾。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出&quot;Yes&quot;，否则输出&quot;No&quot;。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">6 8  5 3  5 2  6 4
5 6  0 0

8 1  7 3  6 2  8 9  7 5
7 4  7 8  7 6  0 0

3 8  6 8  6 4
5 3  5 6  5 2  0 0

-1 -1</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">Yes
Yes
No</div></pre>
</div>
<p>&nbsp;</p>
<p>分析：使用并查集，两个判断，</p>
<p>1. 如果当前输入的两个点（本身就代表它们之间有一条路） 她们的根节点相同， 则不符合题目中的条件说明有环，</p>
<p>2.所有的点必须在一个集合内，即连通的，只要并查集的根节点个数为1&nbsp;即可</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">*
2013/08/04 17:59
author :zyh
*/

#define N 100010
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

using namespace std;

int a[N];
int flag[N];

int find1(int x)
{
    while( a[x]!=x)
        x=a[x];
    return x;
}

void merge(int x,int y)
{
    int xx=find1(x);
    int yy=find1(y);
    if(xx!=yy)    a[xx] = yy;
    
}


int main()
{
    int i,t,m,n,x1,x2;
    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n) &amp;&amp; (m!=-1&amp;&amp;n!=-1))
    {
        if(m==0 &amp;&amp; n==0 ) 
        {
            printf(&quot;Yes\n&quot;);
            continue;
        }
        
        for(i=1;i&lt;=N;i++) 
        {
            flag[i] = 0;
            a[i] = i;
        }    
        int min,max;
        int sign = 1;        
        while((m!=0 &amp;&amp; n!=0))
        {
            flag[m] = flag[n] = 1;
            x1 = find1(m);
            x2 = find1(n);
            
            if(x1==x2) sign = 0;
            else merge(m,n);
            scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
        }
        if(!sign) printf(&quot;No\n&quot;);
        else
        {
            int cnt = 0;
            for(i=1;i&lt;=N;i++)
            {
                if(flag[i] &amp;&amp; a[i]==i)
                cnt++;
            }
            printf(&quot;%s\n&quot;,cnt==1?&quot;Yes&quot;:&quot;No&quot;); 
        }
    }
    return 0;
}
</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目_题目1213_How_Many_Tables" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/05/hdu_题目_题目1213_How_Many_Tables/">hdu 题目 题目1213 How Many Tables</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">How Many Tables</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 9285&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 4568<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">Today is Ignatius' birthday. He invites a lot of friends. Now it's dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want
 to stay with strangers.<br>
<br>
One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.<br>
<br>
For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked
 from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">2
5 3
1 2
2 3
4 5

5 1
2 5</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">2
4</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<p>简单并查集，算根节点数目</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;stdio.h&gt;

int road[10001];

int find1(int a)
{
    while(road[a] != a) //寻找根节点 
     a = road[a];
    return road[a];
}

void merge(int a,int b) // a&lt;b
{
    int x1 = find1(a); //a 的根节点 
    int x2 = find1(b); // b 的根节点 
    if(x2 != x1)
    {    
        road[x2] = x1;     //根节点合并 
    }
}
int main()
{
    int t,n,m,i,a,b,temp,count;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        
        for(i=1;i&lt;=n;i++)
            road[i] = i;
        while(m--)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            if(b&lt;a) {
                temp = a;
                a = b;
                b = temp;
            }
            merge(a,b);
        }
        count = 0;
        for(i=1; i&lt;=n; i++)
        {
            if(road[i] == i) count++;
        }
        printf(&quot;%d\n&quot;,count);
    }
    return 0;
}
</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1233_还是畅通工程_（Prime算法）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/05/hdu_题目1233_还是畅通工程_（Prime算法）/">hdu 题目1233 还是畅通工程 （Prime算法）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">还是畅通工程</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 4000/2000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 20006&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 8874<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>
当N为0时，输入结束，该用例不被处理。<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">对每个测试用例，在1行里输出最小的公路总长度。<br>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">3
1 2 1
1 3 2
2 3 4
4
1 2 1
1 3 4
1 4 1
2 3 3
2 4 2
3 4 5
0</div><div style="font-family:Courier New,Courier,monospace">
&nbsp;</div></pre>
</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">3
5

</div></pre>
</div>
<p>&nbsp;</p>
<h2 class="title content-title">最小生成树——Prim和Kruskal算法</h2>
<div id="content" class="content mod-cs-content text-content clearfix">
<p></p>
<p>先从其它网站上转载了点算法：</p>
<p></p>
<p>&nbsp;&nbsp;&nbsp; 这里讨论的是无向图的最小生成树，有向图的最小生成树算法比较复杂，如果感兴趣可以参看清华大学的《信息学奥林</p>
<p></p>
<p>匹克竞赛指导－图论的算法与程序设计》。</p>
<p></p>
<p>所谓最小生成树，就是给定一个无向图，挑选若干条边，连成一个树行图（无圈），使得所选边的权至和最小。</p>
<p></p>
<p></p>
<p>一下算法中，n是点数，e是边数。</p>
<p></p>
<p>1.Prim</p>
<p></p>
<p>初始时任选一点s为树根，每次选出一条权最小的边[i,j]，使得点i在树中，点j不在树中，将j和[i,j]加入树中，重复n-1次</p>
<p></p>
<p>求出最小生成树。</p>
<p></p>
<p></p>
<p>我们用二叉堆来提高效率。二叉堆中存储边，初始时二叉堆中存储与s关联的边，每次取出一个权最小的边[i,j]，删除</p>
<p></p>
<p>[i,j]，同时将与j关联的边放入二叉堆中，注意判重。</p>
<p></p>
<p></p>
<p>因为所有边只放入和取出二叉堆一次，所以算法复杂度是(eloge)。</p>
<p></p>
<p>2.Kruskal</p>
<p></p>
<p></p>
<p>从所有边中找到一个最小的边，且将改变放入后不会生成圈，重复n-1次后求出最小生成树。</p>
<p></p>
<p></p>
<p>我们首先将所有边排序，然后从小到大判断，如果不产生圈就加入树中，当加入n-1条边时停止。</p>
<p></p>
<p></p>
<p>为了判断是否组成圈，我们要用到并查集，相关知识可以在本站或任一本竞赛书中找到，这里不赘述。</p>
<p></p>
<p></p>
<p>算法复杂度是(eloge&#43;eα)，α是做一次并查集的复杂度，可以认为是常数。</p>
<p></p>
<p>两种算法同样优秀。</p>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/*
	2013/08/04 11:03
	author : zyh
*/

#define N  101
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;

using namespace std;

int city[N][N],road[N];//road 存放当前集合所包含的顶点
bool visit[N];

int sum,n;

void Min(int count) 
{
	
 	int i,j,last,m;
	m = 999999;
 	for(i=1; i&lt;=count; i++)//在road的顶点内所连接的边寻找最小边
 	{	
 		for(j=1;j&lt;=n;j++)
		{
	 		if(!visit[j] &amp;&amp;  m&gt;city[road[i]][j]  &amp;&amp; city[road[i]][j] != 0)
	 		{
	 			last = j;// 标记最小边和 下标
				m = city[road[i]][j];
	 		}	
		} 
 	}
 //	printf(&quot;min=%d,index=%d\n&quot;,m,last);
	sum += m;
	road[++count] = last;
	visit[last] = 1;
}

void Prim()
{
	int i;	
	for(i=1;i&lt;=n;i++) visit[i] = 0;
	road[1] = 1;//从第一个城市开始 
	int count = 1;
	visit[1] = 1;
	while(count&lt;n)
	{
		Min(count);
		count++;
	}
}

int main()
{
	int i,j,a,b,c;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		for(i=1;i&lt;= n*(n-1)/2;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
			city[a][b] = city[b][a] = c; 
		}
//		for(i=1;i&lt;=n;i++)
//		{
//			for(j=1;j&lt;=n;j++)
//			printf(&quot;%d &quot;,city[i][j]);
//				printf(&quot;\n&quot;);
//		}		
		sum = 0;
		Prim();
		printf(&quot;%d\n&quot;,sum);
	}
	return 0;
}

</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-HDU_题目1232_畅通工程_（并查集）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/05/HDU_题目1232_畅通工程_（并查集）/">HDU 题目1232 畅通工程 （并查集）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">畅通工程</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 4000/2000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 22580&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 11790<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？
<br>
</div>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。
<br>
注意:两个城市之间可以有多条道路相通,也就是说<br>
3 3<br>
1 2<br>
1 2<br>
2 1<br>
这种输入也是合法的<br>
当N为0时，输入结束，该用例不被处理。 <br>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">对每个测试用例，在1行里输出最少还需要建设的道路数目。 <br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0
</div></pre>
</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">1
0
2
998

<div style="border-bottom:#b7cbff 1px dashed; border-left:#b7cbff 1px dashed; padding-bottom:6px; background-color:#f4fbff; padding-left:6px; padding-right:6px; font-family:Times New Roman; font-size:14px; border-top:#b7cbff 1px dashed; border-right:#b7cbff 1px dashed; padding-top:6px"><div style="border-bottom:#b7cbff 1px dashed; font-family:Arial; color:#7ca9ed; font-weight:bold"><em>Hint</em></div>Hint</div><em style="font-size:1px"> </em>
Huge input, scanf is recommended.</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>简单并查集，最后结果等于 根节点数目-1</p>
<pre class="cpp" name="code">int road[10001];

int find1(int a)
{
	while(road[a] != a) //寻找根节点 
	 a = road[a];
	return road[a];
}

void merge(int a,int b) // a&lt;b
{
	int x1 = find1(a); //a 的根节点 
	int x2 = find1(b); // b 的根节点 
	if(x2 != x1)
	{	
		road[x2] = x1;	 //根节点合并 
	}
}
int main()
{
	int n,m,i,a,b,temp,count;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		for(i=1;i&lt;=n;i++)
			road[i] = i;
		scanf(&quot;%d&quot;,&amp;m);
		while(m--)
		{
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			if(b&lt;a) {
				temp = a;
				a = b;
				b = temp;
			}
			merge(a,b);
		}
		count = 0;
		for(i=1; i&lt;=n; i++)
		{
			if(road[i] == i) count++;
		}
		printf(&quot;%d\n&quot;,count-1);
	}
	return 0;
}

</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-HDU_题目1166_敌兵布阵" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/04/HDU_题目1166_敌兵布阵/">HDU 题目1166 敌兵布阵</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p><br>
</p>
<p></p>
<h1 style="color:rgb(26,92,200); text-align:center; font-family:'Times New Roman'">
敌兵布阵</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 29945&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 12848<br>
</span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。<br>
中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:&quot;你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：&quot;我知错了。。。&quot;但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
第一行一个整数T，表示有T组数据。<br>
每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。<br>
接下来每行有一条命令，命令有4种形式：<br>
(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）<br>
(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;<br>
(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;<br>
(4)End 表示结束，这条命令在每组数据最后出现;<br>
每组数据最多有40000条命令<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
对第i组数据,首先输出“Case i:”和回车,<br>
对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">1
10
1 2 3 4 5 6 7 8 9 10
Query 1 3
Add 3 6
Query 2 7
Sub 10 2
Add 6 3
Query 3 10
End </div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">Case 1:
6
33
59</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<div><br>
</div>
<br>
<p></p>
<p><strong><span style="font-size:18px">分析：树状数组的典型应用</span></strong></p>
<p><strong><span style="font-size:18px">tree[ ] 存放树状数组，c[ ] 存放原始数据 ,</span></strong></p>
<p><strong><span style="font-size:18px">tree[1] = c[1]; &nbsp;&nbsp;</span></strong></p>
<p><strong><span style="font-size:18px">tree[2] = c[1]&#43;c[2]; &nbsp; &nbsp;&nbsp;</span><span style="font-size:18px">&nbsp;// lowbit( 2 ) = 2;</span></strong></p>
<p><strong><span style="font-size:18px">tree[3] = c[3];</span></strong></p>
<p><strong><span style="font-size:18px">tree[4] = c[1]&#43;c[2]&#43;c[3]&#43;c[4]; &nbsp;&nbsp;<strong><span style="font-size:18px">&nbsp;// lowbit( 4 ) = 4 ;</span></strong></span></strong></p>
<p><strong><span style="font-size:18px">tree[5] = c[5];</span></strong></p>
<p><strong><span style="font-size:18px">tree[6] = c[5]&#43;c[6]; &nbsp;&nbsp;<strong><span style="font-size:18px">&nbsp;// lowbit( 6 ) = 2;</span></strong></span></strong></p>
<p><strong><span style="font-size:18px">tree[7] = c[7];</span></strong></p>
<p><strong><span style="font-size:18px">tree[8] = c[1]&#43;c[2]&#43;c[3]&#43;c[4]&#43;c[5]&#43;c[6]&#43;c[7]&#43;c[8]; &nbsp; &nbsp;<strong><span style="font-size:18px">&nbsp;// lowbit(8 ) = 8;</span></strong></span></strong></p>
<p><strong><span style="font-size:18px">;;;;;一次AC&nbsp;</span></strong></p>
<p><br>
</p>
<p><pre name="code" class="cpp">/*
 2013/08/04 22:53
 author :zyh
 树状数组 
*/

#define N 50002
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
using namespace std;

int n;
int tree[N],c[N];

int lowbit(int x)
{
	return x&amp;(-x);//返回值代表tree[i] 里面 包含 c[]里面的几项
}

void build_tree()
{
	int i,j;
	for(i=1;i&lt;=n;i++)
	{
		if(i&amp;1) tree[i] = c[i];    //奇数
		else
		{
			int temp = 0;
			for(j=i-lowbit(i)+1;j&lt;=i;j++)
			{
				temp += c[j];
			}
			tree[i] = temp;
		} 	
	}
	
//	for(i=1;i&lt;=n;i++)  printf(&quot;%d &quot;,tree[i]);
}

void Add(int a,int b)
{
	int i;
	for(i=a;i&lt;=n;)
	{
	 	tree[i] += b;
	 	i += lowbit(i);
	}
//	for(i=1;i&lt;=n;i++)  printf(&quot;%d &quot;,tree[i]);
}

void Sub(int a,int b)
{
	int i;
	for(i=a;i&lt;=n;)
	{
	 	tree[i] -= b;
	 	i += lowbit(i);
	}
//	for(i=1;i&lt;=n;i++)  printf(&quot;%d &quot;,tree[i]);
}

int Sum(int b)
{
	int i,sum=0;
	for(i=b;i&gt;=1;)
	{
		sum += tree[i];
		i -= lowbit(i); 
	}
	return sum;
}

int main()
{
	int t,i,j,a,b;
	char s[6];
	scanf(&quot;%d&quot;,&amp;t);
	for(i=1;i&lt;=t;i++)
	{
		memset(tree,0,sizeof(tree));
		scanf(&quot;%d&quot;,&amp;n);
		for(j=1;j&lt;=n;j++)
			scanf(&quot;%d&quot;,&amp;c[j]);
		build_tree();
		
		printf(&quot;Case %d:\n&quot;,i);
		while(scanf(&quot;%s&quot;,s) &amp;&amp; s[0]!= 'E')
		{
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			
			switch(s[0])
			{
				case 'A':Add(a,b);break;
				case 'S':Sub(a,b);break;
				case 'Q':printf(&quot;%d\n&quot;,Sum(b)-Sum(a-1));break;
			}
		}
	}
	return 0;
}</pre><br>
<br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-HDU_题目3791_二叉搜索树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/04/HDU_题目3791_二叉搜索树/">HDU 题目3791 二叉搜索树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 style="">二叉搜索树</h1>
<p><span style=""><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 2075&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 926<br>
</span></strong></span><br style="">
<br style="">
</p>
<div class="panel_title" align="left" style="">Problem Description</div>
<p>&nbsp;</p>
<div class="panel_content" style="">判断两序列是否为同一二叉搜索树序列</div>
<div class="panel_bottom" style="">&nbsp;</div>
<p><br style="">
&nbsp;</p>
<div class="panel_title" align="left" style="">Input</div>
<p>&nbsp;</p>
<div class="panel_content" style="">开始一个数n，(1&lt;=n&lt;=20) 表示有n个需要判断，n= 0 的时候输入结束。<br>
接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，根据这个序列可以构造出一颗二叉搜索树。<br>
接下去的n行有n个序列，每个序列&#26684;式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉搜索树。</div>
<div class="panel_bottom" style="">&nbsp;</div>
<p><br style="">
&nbsp;</p>
<div class="panel_title" align="left" style="">Output</div>
<p>&nbsp;</p>
<div class="panel_content" style="">如果序列相同则输出YES，否则输出NO<br>
</div>
<div class="panel_bottom" style="">&nbsp;</div>
<p><br style="">
&nbsp;</p>
<div class="panel_title" align="left" style="">Sample Input</div>
<p>&nbsp;</p>
<div class="panel_content" style="">
<pre style="margin:0px; font-size:14px"><div style="font-family:'Courier New',Courier,monospace">2
567432
543267
576342
0</div></pre>
</div>
<div class="panel_bottom" style="">&nbsp;</div>
<p><br style="">
&nbsp;</p>
<div class="panel_title" align="left" style="">Sample Output</div>
<p>&nbsp;</p>
<div class="panel_content" style="">
<pre style="margin:0px; font-size:14px"><div style="font-family:'Courier New',Courier,monospace">YES
NO</div></pre>
</div>
<p><br>
&nbsp;</p>
<p>分析：二叉搜索树即二叉排序树，本题只要建立好儿茶排序树，然后两个从根节点进行比较即可比较完相同即为YES，否则NO</p>
<pre class="cpp" name="code">/*
时间：2013/08/04 15:36
author ：zyh 
*/

#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

using namespace std;

typedef struct node
{
 		char elem;
 		node * lchild;
		node * rchild;
}node,tree;

void Traverse(tree * t)
{
	if(!t) return;
	printf(&quot;** %c &quot;,t-&gt;elem);
	Traverse(t-&gt;lchild);
	Traverse(t-&gt;rchild);
}
void insert(tree* &amp;t,char e)
{	 
	 if( !t )
	 {
		node * p = (node *)malloc(sizeof(node));
 		p-&gt;elem = e;
 		p-&gt;lchild = p-&gt;rchild = NULL;
		t = p;
	 }
	 
	 else if(e&lt; t-&gt;elem)
	 {
		insert(t-&gt;lchild,e);
	 }
	 else insert(t-&gt;rchild,e);
//	 Traverse(t);
}
int flag ;
void same(tree * t1,tree * t2)
{
	if( (!t1 &amp;&amp; t2) || (t1 &amp;&amp; !t2 ) )
	{
		flag = 0;
		return;
	} 
	if(!t1 &amp;&amp; !t2) return;
	if(t1-&gt;elem != t2-&gt;elem ) 
	{
		flag = 0;
		return;
	}
	same(t1-&gt;lchild,t2-&gt;lchild);
	same(t1-&gt;rchild,t2-&gt;rchild);
}
int main()
{
 	tree * t;
 	tree * t1;
 	int i,n;
 	char s[12],s1[12];
 	while(scanf(&quot;%d&quot;,&amp;n),n)
 	{
		getchar();
		gets(s);
	//	puts(s);
		t=NULL;
		
		for(i=0;i&lt;strlen(s);i++)
		 insert(t,s[i]);
	//	Traverse(t);puts(&quot;&quot;);
		while(n--)
		{
			t1=NULL;
			flag = 1;
			gets(s1);
		//	puts(s1);
			for(i=0;i&lt;strlen(s1);i++)
		 		insert(t1,s1[i]);
		 //	Traverse(t1);puts(&quot;&quot;);
		 	same(t,t1);
		 	if(flag) printf(&quot;YES\n&quot;);
		 	else printf(&quot;NO\n&quot;);
		}
		
	}
 	return 0;
}
/*
2
567432
543267
576342
*/</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-错误总结（持续更新）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/04/错误总结（持续更新）/">错误总结（持续更新）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p><br>
</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong>首先声明：本人菜鸟。。。</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><br>
</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong>1。在写程序时，我总是爱在 定义一个全局变量 &nbsp;max &nbsp; ，结果程序一直调试正确，，，</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong>后来查了一下，max 是 algorithm 头文件中已经定义的函数， 我把它当做一个变量，来使用，总是出错，后来把max 改成 Max 就OK了（这点是女友指点的，一开始就是没想到是，万分感激女友(*^__^*) 嘻嘻……）。</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><br>
</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong>2.定义很多个大数组时比如说是1000000，可以#define N 1000000；或者 const int N = 1000000；</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong>然后定义数组 a[N],b[N]....</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong>以前总爱用到一个写一个 ，如果程序<span style="font-family:Tahoma; color:#0800">Runtime Error</span><span style="font-family:Tahoma; color:#0800">(ACCESS_VIOLATION)，</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span>一般需要改数组大小，，结果就悲催的一个一个改，小的话，再改。。。</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span><br>
</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span>3.尽量把程序里面一块一块的功能分成一个一个的子函数来写，</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span>然后在调用，这样做的好处在于调试程序的时候可以一个功能一个的调试，提高了效率，说道效率，这几天效率一直很低，，，有时候一天也调不对一个程序，整的都快要崩溃了，几乎想放弃，不过在你恍然大悟的那一刻，程序AC 了，然后就又有信心坚持下去了、、</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span><br>
</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span>4.。还是应该多做总结，发现前面已经弄懂的问题，如果不及时总结的话，还没过几天就忘了，记了个大概，真的用的时候又模糊了，无从下手，，</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span></span></strong></span>&nbsp;</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span></span></strong></span>&nbsp;</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span>5.全局变量，这几天写的程序都用到全局变量，，然后在写子函数时需要调用，有时候会发现，子函数里面调用了但是不管用，检查一下发现，既然定义了全局变量，就不能再在函数内部定义相同名字的变量了，否则容易出错，</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span></span></strong></span>&nbsp;</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span>6，今天又遇到一个错误，直接导致WA ，在使用数组时，每组测试数据都要将数组进行初始化， 递归函数要对第一次调用前初始化。。。。</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span></span></strong></span>&nbsp;</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span>7.二维数组访问时的下标问题，，！！</span></strong></span></p>
<p><br>
</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong>8、对于int a[N][N]，二维数组，定义到主函数外面，否则N较大时（&gt;1000）容易会出错</strong></span></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:24px"></span></strong>&nbsp;</p>
<p><strong><span style="font-family:楷体_GB2312; font-size:24px">9.对于栈，队列，能用数组尽量用数组，时间能减少不少，今天遇到一题，一直用G&#43;&#43;提交超时，后来用C&#43;&#43; 提交则前面几个全部通过。</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:24px"><br>
</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:24px">10.HDU oj 系统，对于 64位整型 要用__in64,输出用 %I64d</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:24px">不要用long long，可能会出错。。。。</span></strong></p>
<p><strong><span style="font-family:楷体_GB2312; font-size:24px"></span></strong>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span></span></strong></span>&nbsp;</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><strong><span></span></strong></span>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  

  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/13/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/">Next &raquo;</a>
    </nav>
  


</section>
      </div>
      <footer id="footer">
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      &copy; 2017 <a href="https://github.com/hanks-zyh"> Hanks</a>
	  </div>
  </div>
 <div id="share">
  <a id="totop" title="" style="display: block;">返回顶部</a>
 </div>
</footer>

    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
