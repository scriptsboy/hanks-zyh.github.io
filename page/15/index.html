<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hanks&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="android,web,node,python">
<meta property="og:type" content="website">
<meta property="og:title" content="Hanks' Blog">
<meta property="og:url" content="http://hanks-zyh.github.io/page/15/index.html">
<meta property="og:site_name" content="Hanks' Blog">
<meta property="og:description" content="android,web,node,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hanks' Blog">
<meta name="twitter:description" content="android,web,node,python">
  
  
    <link rel="icon" href="/images/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'> -->
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo"></a>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      
        <a class="main-nav-link" href="/archives">归档</a>
      
        <a class="main-nav-link" href="/daily">日报</a>
      
        <a class="main-nav-link" href="/eye-video">开眼</a>
      
        <a class="main-nav-link" href="/joke">joke</a>
      
        <a class="main-nav-link" href="/picture-fight">斗图</a>
      
        <a class="main-nav-link" href="/atom.xml">RSS</a>
      
    </nav>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/daily" class="mobile-nav-link">日报</a>
  
    <a href="/eye-video" class="mobile-nav-link">开眼</a>
  
    <a href="/joke" class="mobile-nav-link">joke</a>
  
    <a href="/picture-fight" class="mobile-nav-link">斗图</a>
  
    <a href="/atom.xml" class="mobile-nav-link">RSS</a>
  
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="info">
     <div class="content">
       <div>
         <a href="https://github.com/hanks-zyh"><img class="avatar" src="https://avatars2.githubusercontent.com/u/6268322?v=3&s=460" alt="" /></a>
       </div>
       <div class="name">
         <h2 >Hanks</h2>
       </div>
       <p>90后，奋青，Android ……</p>
       <div class="account">
         <div class="account-item">
           <a href="http://weibo.com/u/2359002991"><img src="http://ww1.sinaimg.cn/large/8c9b876fjw1f3ik9y4q7hj205k05kdfx.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
              <a href="http://www.zhihu.com/people/yuhan-zhang-36"><img src="http://ww2.sinaimg.cn/large/8c9b876fjw1f3ik7sv63wj205k05k3yg.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
           <a href="http://hanks.xyz/atom.xml"> <img src="http://ww3.sinaimg.cn/large/8c9b876fjw1f3ik9kk2ctj205k05kt8n.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
       </div>
     </div>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">最新发布</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/26/node-image-recognition/">Node 识别图片中的文字</a>
          </li>
        
          <li>
            <a href="/2017/03/22/proxy-test/">请求代理</a>
          </li>
        
          <li>
            <a href="/2017/02/16/android-customview-inputmethod/">Android 自定义 view 连接输入法</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-lua/">Android 与 Lua</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-markdown-render/">Android 下 Markdown 渲染</a>
          </li>
        
          <li>
            <a href="/2017/01/09/android-webview-font/">Android 中 webview 自定义字体</a>
          </li>
        
          <li>
            <a href="/2016/09/25/slack-bot/">slack bot</a>
          </li>
        
          <li>
            <a href="/2016/09/19/webapp/">让网页更适配移动设备</a>
          </li>
        
          <li>
            <a href="/2016/09/05/weex-2333/">体验 weex —— 写一个表情包应用</a>
          </li>
        
          <li>
            <a href="/2016/08/31/nestedscrollchild/">WebView 实现 NestedScrollingChild</a>
          </li>
        
          <li>
            <a href="/2016/08/29/nestedchildparent/">NestedScrollingParent 实现复杂交互效果</a>
          </li>
        
          <li>
            <a href="/2016/08/04/telegram-bot/">写一个福利 Telegram 机器人</a>
          </li>
        
          <li>
            <a href="/2016/07/31/write-butterkinfe/">写一个 ButterKnife</a>
          </li>
        
          <li>
            <a href="/2016/07/24/edittext-cursor/">多行 EditText 的光标高度问题</a>
          </li>
        
          <li>
            <a href="/2016/07/22/textview-lineheight/">TextView 设置行高并垂直居中</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Atom/" style="font-size: 10px;">Atom</a> <a href="/tags/Dagger2/" style="font-size: 10px;">Dagger2</a> <a href="/tags/EditText/" style="font-size: 10px;">EditText</a> <a href="/tags/Express/" style="font-size: 11.67px;">Express</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/Framework/" style="font-size: 11.67px;">Framework</a> <a href="/tags/HTML-CSS/" style="font-size: 10px;">HTML/CSS</a> <a href="/tags/Jade/" style="font-size: 10px;">Jade</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/LAMP/" style="font-size: 10px;">LAMP</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Lua/" style="font-size: 10px;">Lua</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/NestedScrolling/" style="font-size: 13.33px;">NestedScrolling</a> <a href="/tags/Node-js/" style="font-size: 13.33px;">Node.js</a> <a href="/tags/OS-X/" style="font-size: 10px;">OS X</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Python/" style="font-size: 11.67px;">Python</a> <a href="/tags/React-Native/" style="font-size: 18.33px;">React-Native</a> <a href="/tags/Refactoring/" style="font-size: 10px;">Refactoring</a> <a href="/tags/Rx/" style="font-size: 10px;">Rx</a> <a href="/tags/RxJava/" style="font-size: 13.33px;">RxJava</a> <a href="/tags/Rxandroid/" style="font-size: 10px;">Rxandroid</a> <a href="/tags/Rxjava/" style="font-size: 11.67px;">Rxjava</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Scrapy/" style="font-size: 11.67px;">Scrapy</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/SwipeRefreshLayout/" style="font-size: 10px;">SwipeRefreshLayout</a> <a href="/tags/Telegram/" style="font-size: 10px;">Telegram</a> <a href="/tags/TextView/" style="font-size: 10px;">TextView</a> <a href="/tags/Ubuntu/" style="font-size: 16.67px;">Ubuntu</a> <a href="/tags/VPS/" style="font-size: 10px;">VPS</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/WebView/" style="font-size: 11.67px;">WebView</a> <a href="/tags/bot/" style="font-size: 10px;">bot</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/interpolator/" style="font-size: 10px;">interpolator</a> <a href="/tags/leancloud/" style="font-size: 10px;">leancloud</a> <a href="/tags/mac-os/" style="font-size: 10px;">mac os</a> <a href="/tags/slack/" style="font-size: 10px;">slack</a> <a href="/tags/virtualBox/" style="font-size: 10px;">virtualBox</a> <a href="/tags/weex/" style="font-size: 10px;">weex</a> <a href="/tags/代理/" style="font-size: 10px;">代理</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/学习/" style="font-size: 10px;">学习</a> <a href="/tags/必备知识/" style="font-size: 10px;">必备知识</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/热修复/" style="font-size: 11.67px;">热修复</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/自动化/" style="font-size: 10px;">自动化</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/hanks-zyh">hanks-zyh</a>
          </li>
        
          <li>
            <a href="http://kiya.space">Kiya‘s space</a>
          </li>
        
          <li>
            <a href="http://rocko.xyz/">Rocko&#39;s blog</a>
          </li>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="wx">
      <h3 class="widget-title">微信公众号</h3>
      <img src='http://ww1.sinaimg.cn/large/8c9b876fly1fe0nnlvokpj20by0bywfi.jpg' height="100%" width="100%" >
      <p>搜索公众号: CodeProvider</p>
    </div>
  </div>


  
</aside>
        
        <section id="main" class="mdl-shadow--2dp">
  
    <article id="post-HDU_题目1698_Just_a_Hook（线段树）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/04/HDU_题目1698_Just_a_Hook（线段树）/">HDU 题目1698 Just a Hook（线段树）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p><br>
</p>
<p></p>
<h1 style="text-align:center; font-family:'Times New Roman'; color:rgb(26,92,200)">
Just a Hook</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green">Time Limit: 4000/2000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 12674&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 6309<br>
</span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="padding-bottom:0px; background-color:transparent; padding-left:14px; padding-right:14px; font-family:Arial; height:38px; color:rgb(124,169,237); font-size:18px; font-weight:bold; padding-top:0px">
Problem Description</div>
<div class="panel_content" style="padding-bottom:0px; margin:0px; padding-left:20px; padding-right:20px; font-family:'Times New Roman'; height:auto; font-size:14px; padding-top:0px">
In the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.<br>
<br>
<center><img alt="" src="http://acm.hdu.edu.cn/data/images/C116-1010-1.JPG" style="border-bottom:medium none; border-left:medium none; border-top:medium none; border-right:medium none"></center>
<br>
<br>
Now Pudge wants to do some operations on the hook.<br>
<br>
Let us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.<br>
The total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows:<br>
<br>
For each cupreous stick, the value is 1.<br>
For each silver stick, the value is 2.<br>
For each golden stick, the value is 3.<br>
<br>
Pudge wants to know the total value of the hook after performing the operations.<br>
You may consider the original hook is made up of cupreous sticks.<br>
</div>
<div class="panel_bottom" style="margin:0px; font-family:'Times New Roman'; height:auto; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="padding-bottom:0px; background-color:transparent; padding-left:14px; padding-right:14px; font-family:Arial; height:38px; color:rgb(124,169,237); font-size:18px; font-weight:bold; padding-top:0px">
Input</div>
<div class="panel_content" style="padding-bottom:0px; margin:0px; padding-left:20px; padding-right:20px; font-family:'Times New Roman'; height:auto; font-size:14px; padding-top:0px">
The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.<br>
For each case, the first line contains an integer N, 1&lt;=N&lt;=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0&lt;=Q&lt;=100,000, which is the number of the operations.<br>
Next Q lines, each line contains three integers X, Y, 1&lt;=X&lt;=Y&lt;=N, Z, 1&lt;=Z&lt;=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents
 the golden kind.<br>
</div>
<div class="panel_bottom" style="margin:0px; font-family:'Times New Roman'; height:auto; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="padding-bottom:0px; background-color:transparent; padding-left:14px; padding-right:14px; font-family:Arial; height:38px; color:rgb(124,169,237); font-size:18px; font-weight:bold; padding-top:0px">
Output</div>
<div class="panel_content" style="padding-bottom:0px; margin:0px; padding-left:20px; padding-right:20px; font-family:'Times New Roman'; height:auto; font-size:14px; padding-top:0px">
For each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example.<br>
</div>
<div class="panel_bottom" style="margin:0px; font-family:'Times New Roman'; height:auto; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="padding-bottom:0px; background-color:transparent; padding-left:14px; padding-right:14px; font-family:Arial; height:38px; color:rgb(124,169,237); font-size:18px; font-weight:bold; padding-top:0px">
Sample Input</div>
<div class="panel_content" style="padding-bottom:0px; margin:0px; padding-left:20px; padding-right:20px; font-family:'Times New Roman'; height:auto; font-size:14px; padding-top:0px">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">1
10
2
1 5 2
5 9 3</div></pre>
</div>
<div class="panel_bottom" style="margin:0px; font-family:'Times New Roman'; height:auto; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="padding-bottom:0px; background-color:transparent; padding-left:14px; padding-right:14px; font-family:Arial; height:38px; color:rgb(124,169,237); font-size:18px; font-weight:bold; padding-top:0px">
Sample Output</div>
<div class="panel_content" style="padding-bottom:0px; margin:0px; padding-left:20px; padding-right:20px; font-family:'Times New Roman'; height:auto; font-size:14px; padding-top:0px">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">Case 1: The total value of the hook is 24.</div></pre>
</div>
<div class="panel_bottom" style="margin:0px; font-family:'Times New Roman'; height:auto; font-size:14px">
&nbsp;</div>
<br>
<p></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px"><br>
</span></strong></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px"><strong>分析：看到题目首先想到了线段树，（因为题目是区间更新）</strong></span><span style="font-family:KaiTi_GB2312; font-size:18px">区间更新需要用到延迟标记（或者说懒惰标记），简单来说就是每次更新的时候不要更新到底，用延迟标记使得更新延迟到下次需要更新or询问到的时候。延迟标记的意思是：这个区间的左右儿子都需要被更新，但是当前区间已经更新了</span><span style="font-family:KaiTi_GB2312; font-size:18px"><strong><br>
首先 区间 &nbsp;[1,n] 建立线段树，（题目例子 n==10） 如下图；</strong></span></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px"><br>
</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px"><br>
</span></strong></p>
<p><img alt="" src="http://img.blog.csdn.net/20130804114913875"><br>
</p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:18px">然后依次更新区间，分3中情况，向左，向右，分开向左向右，</span></strong></p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt"><strong><span style="color:#ff0000">在修改和查询的时候，如果我们到了一个结点p，并且需要分开决定考虑其子结点（不能完全覆盖），那么我们就要看看结点p有没有标记，如果有，就要按照标记修改其子结点的信息，并且给子结点都标上相同的标记，同时消掉p的标记；</span></strong></p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt">&nbsp;进行更新操作</p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt">1 5 2</p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt">区间更新后的树如下：</p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt"><img alt="" src="http://img.blog.csdn.net/20130804120131718"><br>
</p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt"><strong><span style="font-family:KaiTi_GB2312; font-size:18px"></span></strong></p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt">&nbsp;进行更新操作</p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt">5 9 3</p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt">区间更新后的树如下</p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt"><img alt="" src="http://img.blog.csdn.net/20130804120446312"><br>
</p>
<strong><span style="font-family:KaiTi_GB2312; font-size:18px"></span></strong>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt"><span style="color:#3333ff">假如 再 进行更新操作</span></p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt"><span style="color:#3333ff">6 10 1</span></p>
<p class="p0" style="margin-top:0pt; margin-bottom:0pt"><span style="color:#3333ff">区间更新后的树如下</span></p>
<img alt="" src="http://img.blog.csdn.net/20130804120500281"><br>
<p><br>
</p>
<p></p>
<pre class="cpp" name="code">#define N 100001
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;

using namespace std;


typedef struct TREE
{
    int lside,rside,value;
}TREE;

TREE tree[N*4];//线段树占空间约为结点个数的 4 倍
int sum,temp;

void build_tree(int l,int r,int i)
{
    tree[i].lside = l;
    tree[i].rside = r;
    tree[i].value = 1;//cuperous
    if(tree[i].lside == tree[i].rside)  return;
    int mid = (tree[i].lside + tree[i].rside)&gt;&gt;1; 
    build_tree(l,mid,i&lt;&lt;1); //i*2
    build_tree(mid+1,r,i&lt;&lt;1|1); //i*2+1
}

void change(int x,int y,int z,int i)
{
//    printf(&quot;x=%d,y=%d,i=%d,tl=%d,tr=%d,v=%d\n&quot;,x,y,i,tree[i].lside,tree[i].rside,tree[i].value);
    if(x&lt;= tree[i].lside &amp;&amp; y&gt;=tree[i].rside)//正好与跟新区间相同
    {
        tree[i].value = z;
        return ;
    }
    if(tree[i].value&gt;0)//不能完全覆盖，需要将下面的都左右子树 都先覆盖为当前结点的标志，
    {
    	tree[i&lt;&lt;1].value =  tree[i].value;
    	tree[i&lt;&lt;1|1].value = tree[i].value;
    	tree[i].value = 0;
    }
    
    int mid = (tree[i].lside + tree[i].rside)&gt;&gt;1;
    if(y&lt;=mid) change(x,y,z,i&lt;&lt;1);//向左
    else if( x&gt;mid ) change(x,y,z,i&lt;&lt;1|1 );//向右
    else//分开的
    {
        change(x,mid,z,i&lt;&lt;1);
        change(mid+1,y,z,i&lt;&lt;1|1);
    }
}
void count(int i)
{
	if(tree[i].value&gt;0)
	{
		sum += tree[i].value * (tree[i].rside - tree[i].lside + 1);//区间的value * 区间的长度 
		return;
	}
	count(i&lt;&lt;1);
	count(i&lt;&lt;1|1);
    
}
int main()
{
    int t,i,j,n,q,x,y,z;
    scanf(&quot;%d&quot;,&amp;t);
    for(i=1;i&lt;=t;i++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        build_tree(1,n,1);
        scanf(&quot;%d&quot;,&amp;q);
        while(q--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
            change(x,y,z,1);
    //            for(j=1;j&lt;40;j++)
    //    printf(&quot;j=%d,l=%d,r=%d,v=%d\n&quot;,j,tree[j].lside,tree[j].rside,tree[j].value);
        }
        sum = 0;
        count(1);
        printf(&quot;Case %d: The total value of the hook is %d.\n&quot;,i,sum);
    }
    return 0;
}

/*
7
10
3
1 5 2
5 9 3
6 10 1


*/</pre><br>
<br>
<p></p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-POJ_题目2182_Lost_Cows" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/02/POJ_题目2182_Lost_Cows/">POJ 题目2182 Lost Cows</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<p align="center">&nbsp;</p>
<div lang="en-US" class="ptt" align="center"><strong><span style="font-size:18px">Lost Cows</span></strong></div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><strong>Time Limit:</strong> 1000MS</td>
<td width="10">&nbsp;</td>
<td><strong>Memory Limit:</strong> 65536K</td>
</tr>
<tr>
<td><strong>Total Submissions:</strong> 8263</td>
<td width="10">&nbsp;</td>
<td><strong>Accepted:</strong> 5272</td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div lang="en-US" class="ptx">N (2 &lt;= N &lt;= 8,000) cows have unique brands in the range 1..N. In a spectacular display of poor judgment, they visited the neighborhood 'watering hole' and drank a few too many beers before dinner. When it was time to line up for
 their evening meal, they did not line up in the required ascending numerical order of their brands.
<br>
<br>
Regrettably, FJ does not have a way to sort them. Furthermore, he's not very good at observing problems. Instead of writing down each cow's brand, he determined a rather silly statistic: For each cow in line, he knows the number of cows that precede that cow
 in line that do, in fact, have smaller brands than that cow. <br>
<br>
Given this data, tell FJ the exact ordering of the cows. <br>
</div>
<p class="pst">Input</p>
<div lang="en-US" class="ptx">* Line 1: A single integer, N <br>
<br>
* Lines 2..N: These N-1 lines describe the number of cows that precede a given cow in line and have brands smaller than that cow. Of course, no cows precede the first cow in line, so she is not listed. Line 2 of the input describes the number of preceding cows
 whose brands are smaller than the cow in slot #2; line 3 describes the number of preceding cows whose brands are smaller than the cow in slot #3; and so on.
<br>
</div>
<p class="pst">Output</p>
<div lang="en-US" class="ptx">* Lines 1..N: Each of the N lines of output tells the brand of a cow in line. Line #1 of the output tells the brand of the first cow in line; line 2 tells the brand of the second cow; and so on.</div>
<p class="pst">Sample Input</p>
<pre class="sio">5
1
2
1
0
</pre>
<p class="pst">Sample Output</p>
<pre class="sio">2
4
5
3
1
</pre>
<p>&nbsp;</p>
<p><strong><span style="font-size:18px">本来是练习线段树的，结果用一个递推推出来了，明天再用线段树试试</span></strong></p>
<p><strong><span style="font-size:18px"></span></strong>&nbsp;</p>
<p><strong><span style="font-size:18px">递推思想：&nbsp; 已知每头牛前面有几个比自己矮的（题目中序号比自己小的），求他们的高度（他们的序号）为多少</span></strong></p>
<p><strong><span style="font-size:18px">先用一个数组来按原来的序号列出来，即 orignal[] = { 1,2,3,4,5.....n}； 再用一个数组存放后来的顺序，即比他们矮的头数lost[] = {0,1,2,1,0}；</span></strong></p>
<p><strong><span style="font-size:18px">从最后一头牛来看，比他矮的有count = lost[i]个， 则从原来的序列orginal【】中选择最小的 count个（必须未被选择过），然后该位置即为 第 count&#43;1 个牛，，</span></strong></p>
<p><strong><span style="font-size:18px"></span></strong>&nbsp;</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;

const int N=8010;

int lost[N],orignal[N],cow[N];
bool visit[N];
int main(){

   	int n,i,j,count,k;
   	scanf(&quot;%d&quot;,&amp;n);
   	for(i=2;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;lost[i]);	//  1 2 1 0     第一个是0 不用存	
	for(j=1;j&lt;=n;j++)
		orignal[j]=j;  //  1 2 3 4 5 
	
	memset(visit,0,sizeof(visit));//标志牛是否位置已经确定	
	for(i=n;i&gt;1;i--) 
	{
	//	printf(&quot;lost[%d]=%d\n&quot;,i,lost[i]);
		count = 0;
		j = 1;
		while(count &lt; lost[i])//从1号牛开始找出未被访问的 lost[i] 个
		{
			while(visit[j])//必须未访问
			{
				j++;
			}	
			count ++;
			j++;
		}
	//	printf(&quot;j=%d,org=%d\n&quot;,j,orignal[j]);
		while(visit[j]) j++;
		cow[i] = orignal[j];//放置牛，该牛位置确定
		visit[j] = 1;	
		
	}
	for(i=1;i&lt;=n;i++)
	{
		if(!visit[i]) cow[1] = orignal[i];	
	}
	for(k=1;k&lt;=n;k++)
		printf(&quot;%d\n&quot;,cow[k]);
	
    return 0;
}
/*
5
1
2
1
0
*/
</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目485_A_B_Problem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/02/NYOJ_题目485_A_B_Problem/">NYOJ 题目485 A*B Problem</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<h2 class="problem-display" align="center">A*B Problem</h2>
<div class="problem-ins" align="center">时间限制：<span id="problem[time_limit]" class="editable highlight">1000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB
</div>
<div class="problem-ins" align="center">难度：<span class="editable highlight">2</span></div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>
<p>设计一个程序求出A*B，然后将其结果每一位相加得到C，如果C的位数大于等于2，继续将C的各位数相加，直到结果是个一位数k。</p>
<p>例如：</p>
<p>6*8=48；</p>
<p>4&#43;8=12；</p>
<p>1&#43;2=3；</p>
<p>输出3即可。</p>
<div class="clr"></div>
<dl class="others"><dt>输入</dt><dd>第一行输入一个数N(0&lt;N&lt;=1000000)，表示N组测试数据。<br>
随后的N行每行给出两个非负整数m，n（0&lt;=m,n&lt;=10^12)。</dd><dt>输出</dt><dd>对于每一行数据，输出k。</dd><dt>样例输入</dt><dd>
<pre id="sample_input">3
6 8
1234567 67
454 1232</pre>
</dd><dt>样例输出</dt><dd>
<pre id="sample_output">3
4
5</pre>
</dd></dl>
</dd></dl>
<p><strong><span style="font-size:18px">数学不好伤不起啊；；；</span></strong></p>
<p><span style="font-size:18px"><strong>结果 =（A*B）%9&nbsp;&nbsp; = （A%9 ）*(B%9) %9;</strong></span></p>
<p><span style="font-size:18px"><strong>A,B 用long long 类型存放，，另外long long 类型要自己定义，否则结果会出错</strong></span></p>
<p>&nbsp;</p>
<pre class="html" name="code"> 
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

typedef long long LL;//这里需要自己定义，直接定义不知道为什么会出错
LL a,b;
int main()
{
    int n;
 //   long long a,b;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    {
        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);
        if(a==0 || b==0)
            printf(&quot;0\n&quot;);
        else
        {
            int ans=(a%9)*(b%9)%9;
            if(ans==0) ans=9;
            printf(&quot;%d\n&quot;,ans);
        }
    }
    return 0;
}        </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1556_Color_the_ball（线段树）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/02/hdu_题目1556_Color_the_ball（线段树）/">hdu 题目1556 Color the ball（线段树）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 align="center" style="color:#1a5cc8">Color the ball</h1>
<p align="center"><span size="&#43;0" style=""><strong><span style="font-family:Arial; color:green; font-size:12px"><strong>Time Limit: 9000/3000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 5853&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 3117<br>
</strong></span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">N个气球排成一排，从左到右依次编号为1,2,3....N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽&quot;牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。<br>
当N = 0，输入结束。</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">3
1 1
2 2
3 3
3
1 1
1 2
1 3
0</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">1 1 1
3 2 1</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<pre class="cpp" name="code">#define N 400000
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;

using namespace std;

typedef struct interval_tree
{
    int lside,rside,cnt;
}interval_tree;

interval_tree tree[N];

int Pnt[N],k;

void build_tree(int l,int r,int i)
{
    
        tree[i].lside = l;
        tree[i].rside = r;
        tree[i].cnt = 0;
        if(l==r) return;
        int mid = (tree[i].rside+tree[i].lside)/2;
        build_tree(l,mid,2*i);
        build_tree(mid+1,r,2*i+1);    
}

void count(int i)
{
	if(tree[i].lside == tree[i].rside)  
   {
		Pnt[k++] = tree[i].cnt;	
		return;
	}
	tree[i*2].cnt += tree[i].cnt;
	tree[i*2+1].cnt += tree[i].cnt;
	count(2*i);
	count(2*i+1);
}


void change(int a,int b,int i)
{
	 if(a&lt;=tree[i].lside &amp;&amp; b&gt;=tree[i].rside)  
    {    
        tree[i].cnt++;
        return;
    }
    int mid =(tree[i].lside+tree[i].rside)/2;
    if(b &lt;= mid )     change(a,b,2*i);
    else if(a &gt; mid )    change(a,b,2*i+1);
    else 
    {
        change(a,mid,2*i);
        change(mid+1,b,2*i+1);
    }
}
int main()
{
    int i,n,a,b;
    while(scanf(&quot;%d&quot;,&amp;n),n)
    {

        build_tree(1,n,1);
        while(n--)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            change(a,b,1);
        }
        k=0;
        count(1);
        for(i=0;i&lt;k-1;i++)
        	printf(&quot;%d &quot;,Pnt[i]);
        printf(&quot;%d\n&quot;,Pnt[k-1]);
    }
    return 0;
}
</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ题目116_士兵杀敌（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/02/NYOJ题目116_士兵杀敌（二）/">NYOJ题目116 士兵杀敌（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<h4 class="problem-display"></h4>
<h3 class="problem-display" align="center">士兵杀敌（二）</h3>
<h3 class="problem-ins" align="center">时间限制：<span id="problem[time_limit]" class="editable highlight">1000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB
</h3>
<h3 class="problem-ins" align="center">难度：<span class="editable highlight">5</span></h3>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd><span style="font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; color:#464646; line-height:21px"></span>
<p style="padding-bottom:0px; margin:1em 0px; padding-left:0px; padding-right:0px; padding-top:0px">
南将军手下有N个士兵，分别编号1到N，这些士兵的杀敌数都是已知的。</p>
<p style="padding-bottom:0px; margin:1em 0px; padding-left:0px; padding-right:0px; padding-top:0px">
小工是南将军手下的军师，南将军经常想知道第m号到第n号士兵的总杀敌数，请你帮助小工来回答南将军吧。</p>
<p style="padding-bottom:0px; margin:1em 0px; padding-left:0px; padding-right:0px; padding-top:0px">
南将军的某次询问之后士兵i可能又杀敌q人，之后南将军再询问的时候，需要考虑到新增的杀敌数。</p>
<p style="padding-bottom:0px; margin:1em 0px; padding-left:0px; padding-right:0px; padding-top:0px">
</p>
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>只有一组测试数据<br>
第一行是两个整数N,M，其中N表示士兵的个数(1&lt;N&lt;1000000)，M表示指令的条数。(1&lt;M&lt;100000)<br>
随后的一行是N个整数，ai表示第i号士兵杀敌数目。(0&lt;=ai&lt;=100)<br>
随后的M行每行是一条指令，这条指令包含了一个字符串和两个整数，首先是一个字符串，如果是字符串QUERY则表示南将军进行了查询操作，后面的两个整数m,n，表示查询的起始与终止士兵编号；如果是字符串ADD则后面跟的两个整数I,A(1&lt;=I&lt;=N,1&lt;=A&lt;=100),表示第I个士兵新增杀敌数为A.<br>
</dd><dt>输出 </dt><dd>对于每次查询，输出一个整数R表示第m号士兵到第n号士兵的总杀敌数，每组输出占一行 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">5 6
1 2 3 4 5
QUERY 1 3
ADD 1 2
QUERY 1 3
ADD 2 3
QUERY 1 2
QUERY 1 5</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">6
8
8
20</pre>
</dd></dl>
</dd></dl>
<p>利用树状数组来存放士兵杀敌数</p>
<p>&nbsp;</p>
<p></p>
<pre class="cpp" name="code"> 

#include &lt;stdio.h&gt;
int a[1000000],Tree_a[1000000];//a[]为原始数据组，Tree_a[]树状数组
int lowbit(int i)
{  // 返回i因子中含有 2的最大幂,如6的因子中最大2的幂是2^1 = 2 ，8的因子最大2次幂 2^3 = 8；
	return i&amp;(-i);
}
void change(int x, int y,int n)
{
	while(x&lt;=n)
	{
		Tree_a[x] += y;
		x += lowbit(x);
	}
}
int f_sum(int x)
{//返回前x个数的和
	if(x==0) return 0;
	int sum = 0;
	while( x&gt;0 )
	{
		sum += Tree_a[x]; //求前x数的和
		x -= lowbit(x);
	}
	return sum;
}
int main()
{
	int m,n,i,e,j,x,y;
	char str[6];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;e);
		a[i] = e;
		if(i&amp;1)//奇数,树状数组与原始位置数据一样
			Tree_a[i] = a[i];
		else //偶数，树状数组对应位置存的为几项的和
		{
			int sum = 0;
			for(j=i+1-lowbit(i);j&lt;=i;j++)	sum += a[j];
			Tree_a[i] = sum;
		}
	}

	while(m--)
	{
		scanf(&quot;%s%d%d&quot;,str,&amp;x,&amp;y);
		if(str[0]=='Q')	 printf(&quot;%d\n&quot;,f_sum(y) - f_sum(x-1));
		else 	change(x,y,n);// 第x个位置增加 y，调整x到N之间的和的值
	}
}
        </pre>
<p><br>
&nbsp;</p>
<dl></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_士兵杀敌（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/02/NYOJ_士兵杀敌（一）/">NYOJ 士兵杀敌（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<div style="text-align:center"><strong>士兵杀敌（一）</strong></div>
<div style="text-align:center">时间限制：1000 ms &nbsp;| &nbsp;内存限制：65535 KB</div>
<div style="text-align:center">难度：3</div>
&nbsp;<br>
描述<br>
南将军手下有N个士兵，分别编号1到N，这些士兵的杀敌数都是已知的。<br>
<br>
小工是南将军手下的军师，南将军现在想知道第m号到第n号士兵的总杀敌数，请你帮助小工来回答南将军吧。<br>
<br>
注意，南将军可能会问很多次问题。<br>
<br>
&nbsp;<br>
输入<br>
只有一组测试数据<br>
第一行是两个整数N,M，其中N表示士兵的个数(1&lt;N&lt;1000000)，M表示南将军询问的次数(1&lt;M&lt;100000)<br>
随后的一行是N个整数，ai表示第i号士兵杀敌数目。(0&lt;=ai&lt;=100)<br>
随后的M行每行有两个整数m,n，koko.wan128.cn,表示南将军想知道第m号到第n号士兵的总杀敌数（1&lt;=m,n&lt;=N)。<br>
输出<br>
对于每一个询问，输出总杀敌数<br>
每个输出占一行<br>
样例输入<br>
5 2<br>
1 2 3 4 5<br>
1 3<br>
2 4
<p></p>
<p>样例输出<br>
6<br>
9<br>
</p>
<p><br>
</p>
<p><strong><span style="font-size:18px">将前n个士兵杀敌数的和放到a[n]中，问s到t士兵的杀敌数，直接a[t]-a[s-1]得到；<br>
</span></strong></p>
<p><pre class="cpp" name="code">#include &lt;stdio.h&gt;

int main()
{
    int n,m,a[1000001];
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    a[0] = 0;
    for(i=1;i&lt;=n;i++)
    {
         scanf(&quot;%d&quot;,&amp;c);
         a[i] = a[i-1]+c;                
    }
    while(m--)
    {
         scanf(&quot;%d%d&quot;,&amp;s,&amp;t);          
         printf(&quot;%d\n&quot;,a[t]-a[s-1]);
    }
    return 0;
}
</pre><br>
<br>
</p>
<p></p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-ZOJ_题目1610_Count_the_Colors（线段树）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/01/ZOJ_题目1610_Count_the_Colors（线段树）/">ZOJ 题目1610 Count the Colors（线段树）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<center>
<h2><span class="bigProblemTitle"><span style="color:#3366ff">Count the Colors</span></span></h2>
</center>
<h2>
<hr>
</h2>
<p>&nbsp;</p>
<center><span style="color:green">Time Limit: </span>2 Seconds &nbsp;&nbsp;&nbsp;&nbsp; <span style="color:green">
Memory Limit: </span>65536 KB </center>
<hr>
<p>Painting some colored segments on a line, some previously painted segments may be covered by some the subsequent ones.</p>
<p>Your task is counting the segments of different colors you can see at last.</p>
<p><br>
<strong>Input<br>
</strong><br>
The first line of each data set contains exactly one integer n, 1 &lt;= n &lt;= 8000, equal to the number of colored segments.</p>
<p>Each of the following n lines consists of exactly 3 nonnegative integers separated by single spaces:<br>
<br>
x1 x2 c<br>
<br>
x1 and x2 indicate the left endpoint and right endpoint of the segment, c indicates the color of the segment.</p>
<p>All the numbers are in the range [0, 8000], and they are all integers.</p>
<p>Input may contain several data set, process to the end of file.</p>
<p><br>
<strong>Output</strong><br>
<br>
Each line of the output should contain a color index that can be seen from the top, following the count of the segments of this color, they should be printed according to the color index.</p>
<p>If some color can't be seen, you shouldn't print it.</p>
<p>Print a blank line after every dataset.</p>
<p><br>
<strong>Sample Input</strong><br>
<br>
5<br>
0 4 4<br>
0 3 1<br>
3 4 2<br>
0 2 2<br>
0 2 3<br>
4<br>
0 1 1<br>
3 4 1<br>
1 3 2<br>
1 3 1<br>
6<br>
0 1 0<br>
1 2 1<br>
2 3 1<br>
1 2 0<br>
2 3 0<br>
1 2 1</p>
<p><br>
<strong>Sample Output</strong><br>
<br>
1 1<br>
2 1<br>
3 1</p>
<p>1 1</p>
<p>0 2<br>
1 1</p>
<p>&nbsp;</p>
<p>没有使用线段树的代码：因为8000比较小，不然会超时</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include&quot;stdio.h&quot;
#include&lt;string.h&gt;

int main()
{
	int tree[8010];
	int finalcolor[8010];
	int n,i,j;
	int ls,rs,c;//临时的表示当前输入数据的左右范围及颜色 
	int rmax;//表示总的最右边界 
	while(scanf(&quot;%d&quot;,&amp;n)!=EOF)
	{

		memset(tree,-1,sizeof(tree));
		rmax = 0;
		while(n--)//输入n个颜色,及其染色范围 
		{
			scanf(&quot;%d%d%d&quot;,&amp;ls,&amp;rs,&amp;c);
			if(rs&gt;rmax) rmax = rs;//从1开始的下标中存放的值表示前面一单位段的颜色 
			for(j=ls+1;j&lt;=rs;j++)//后来输入的颜色会直接覆盖前面的颜色 
				tree[j] = c;
			
		}

		
		memset(finalcolor,0,sizeof(finalcolor));

		
		int k;
		j=0;
		finalcolor[tree[1]]=1;
		for(i=2;i&lt;=rmax;i++)
		{	
			if(tree[i]==tree[i-1]) continue;	 
			finalcolor[tree[i]]++;
	
		}//for
		
		for(i=0;i&lt;=8002;i++)
		{
			if(finalcolor[i])
				printf(&quot;%d %d\n&quot;,i,finalcolor[i]);
		} 
		printf(&quot;\n&quot;);
		
	}//while
	return 0;
}











/*
1
1 2 55

5
0 4 4
0 3 1
3 4 2
0 2 2
0 2 3
4
0 1 1
3 4 1
1 3 2
1 3 1
6
0 1 0
1 2 1
2 3 1
1 2 0
2 3 0
1 2 1
3
1 2 3
1 2 2
1 2 1

*/</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-C___之_STL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/01/C___之_STL/">C++ 之 STL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h3><span class="link_title"></span>
<div id="body">
<div id="main">
<div class="main">
<div id="article_details" class="details"><span class="ico ico_type_Original"></span>
<h1 class="article_title"><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6946811">STL系列之一 deque双向队列
</a></span></h1>
<div id="article_content" class="article_content">
<p><span style="font-size:18px">deque双向队列是一种双向开口的连续线性空间，可以高效的在头尾两端插入和删除元素，deque在接口上和vector非常相&#20284;，下面列出deque的常用成员函数：</span></p>
<p align="center"></p>
<div align="left">&nbsp;</div>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><span style="font-size:18px">deque的实现比较复杂，内部会维护一个map（注意！不是STL中的map容器）即一小块连续的空间，该空间中每个元素都是指针，指向另一段（较大的）区域，这个区域称为缓冲区，缓冲区用来保存deque中的数据。因此deque在随机访问和遍历数据会比vector慢。具体的deque实现可以参考《STL源码剖析》，当然此书中使用的SGI STL与VS2008所使用的PJ STL的实现方法还是有区别的。下面给出了deque的结构图：</span></p>
<p><span style="font-size:18px">&nbsp;<img alt="" src="http://hi.csdn.net/attachment/201111/8/0_13207172099IU6.gif"></span></p>
<p><span style="font-size:18px">由于篇幅问题，deque的实现细节就不再深入了，下面给出deque的使用范例：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6946811#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6946811#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6946811#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6946811#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//双向队列&nbsp;deque </span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="comment">//by&nbsp;MoreWindows&nbsp;http://blog.csdn.net/morewindows
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;deque&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;deque&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;ideq(20);&nbsp;</span><span class="comment">//Create&nbsp;a&nbsp;deque&nbsp;ideq&nbsp;with&nbsp;20&nbsp;elements&nbsp;of&nbsp;default&nbsp;value&nbsp;0
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;deque&lt;</span><span class="datatypes">int</span><span>&gt;::iterator&nbsp;pos;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//使用assign()赋&#20540;&nbsp;&nbsp;assign在计算机中就是赋&#20540;的意思
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;20;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ideq[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//输出deque </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;输出deque中数据:\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;20;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;ideq[i]);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//在头尾加入新数据 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n在头尾加入新数据...\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ideq.push_back(100);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;ideq.push_front(i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//输出deque </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n输出deque中数据:\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(pos&nbsp;=&nbsp;ideq.begin();&nbsp;pos&nbsp;!=&nbsp;ideq.end();&nbsp;pos&#43;&#43;)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;*pos);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//查找 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">int</span><span>&nbsp;FINDNUMBER&nbsp;=&nbsp;19;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n查找%d\n&quot;</span><span>,&nbsp;FINDNUMBER);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;=&nbsp;find(ideq.begin(),&nbsp;ideq.end(),&nbsp;FINDNUMBER);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(pos&nbsp;!=&nbsp;ideq.end())&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;find&nbsp;%d&nbsp;success\n&quot;</span><span>,&nbsp;*pos);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;find&nbsp;failed\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//在头尾删除数据 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n在头尾删除数据...\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ideq.pop_back();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;ideq.pop_front();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//输出deque </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n输出deque中数据:\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(pos&nbsp;=&nbsp;ideq.begin();&nbsp;pos&nbsp;!=&nbsp;ideq.end();&nbsp;pos&#43;&#43;)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;*pos);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//双向队列 deque
//by MoreWindows http://blog.csdn.net/morewindows
#include &lt;deque&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
	deque&lt;int&gt; ideq(20); //Create a deque ideq with 20 elements of default value 0
	deque&lt;int&gt;::iterator pos;
	int i;

	//使用assign()赋值  assign在计算机中就是赋值的意思
	for (i = 0; i &lt; 20; ++i)
		ideq[i] = i;
	
	//输出deque
	printf(&quot;输出deque中数据:\n&quot;);
	for (i = 0; i &lt; 20; ++i)
		printf(&quot;%d &quot;, ideq[i]);
	putchar('\n');

	//在头尾加入新数据
	printf(&quot;\n在头尾加入新数据...\n&quot;);
	ideq.push_back(100);
	ideq.push_front(i);

	//输出deque
	printf(&quot;\n输出deque中数据:\n&quot;);
	for (pos = ideq.begin(); pos != ideq.end(); pos++)
		printf(&quot;%d &quot;, *pos);
	putchar('\n');

	//查找
	const int FINDNUMBER = 19;
	printf(&quot;\n查找%d\n&quot;, FINDNUMBER);
	pos = find(ideq.begin(), ideq.end(), FINDNUMBER);
	if (pos != ideq.end())
		printf(&quot;find %d success\n&quot;, *pos);
	else
		printf(&quot;find failed\n&quot;);

	//在头尾删除数据
	printf(&quot;\n在头尾删除数据...\n&quot;);
	ideq.pop_back();
	ideq.pop_front();

	//输出deque
	printf(&quot;\n输出deque中数据:\n&quot;);
	for (pos = ideq.begin(); pos != ideq.end(); pos++)
		printf(&quot;%d &quot;, *pos);
	putchar('\n');
	return 0;
}</pre>
<p><span style="font-size:18px">运行结果如下：</span></p>
<p><img alt="" src="http://hi.csdn.net/attachment/201111/8/0_1320717228QV1x.gif"></p>
<p><span style="font-size:18px">另外要注意一点。对于deque和vector来说，尽量少用erase(pos)和erase(beg,end)。因为这在中间删除数据后会导致后面的数据向前移动，从而使效率低下。</span></p>
<p><span style="font-size:18px">&nbsp;</span></p>
<p><span style="font-size:18px">&nbsp;</span></p>
<p><span style="font-size:18px">转载请标明出处，原文地址：<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6946811">http://blog.csdn.net/morewindows/article/details/6946811</a></span></p>
</div>
</div>
</div>
</div>
</div>
</h3>
<h3><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950917">STL系列之三 queue 单向队列
</a></span></h3>
<p class="article_content"><span style="font-size:18px">queue单向队列与<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">栈</a>有点类&#20284;，一个是在同一端存取数据，另一个是在一端存入数据，另一端取出数据。单向队列中的数据是先进先出（First In First Out,FIFO）。在STL中，单向队列也是以别的容器作为底部结构，再将接口改变，使之符合单向队列的特性就可以了。因此实现也是非常方便的。下面就给出单向队列的函数列表和VS2008中单向队列的源代码。单向队列一共6个常用函数（<span style="color:#ff0000">front()、back()、push()、pop()、empty()、size()</span>），与<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">栈</a>的常用函数较为相&#20284;。</span></p>
<p class="article_content" align="center"><span style="font-size:18px"><img alt="" src="http://hi.csdn.net/attachment/201111/9/0_1320801684QU6a.gif"></span>
</p>
<div class="article_content" align="left">
<div id="body">
<div id="main">
<div class="main">
<div id="article_details" class="details">
<div class="article_title"><span class="ico ico_type_Original"></span>
<h3><span class="link_title">&nbsp;&nbsp;&nbsp;&nbsp; <a target="_blank" href=""><span style="color:blue"></span></a></span>
<div id="article_details" class="details"><span class="ico ico_type_Original"></span>
<h1 class="article_title"><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">STL系列之二 stack栈
</a></span></h1>
<div id="article_content" class="article_content">
<p align="left"><span style="font-size:18px">栈（statck）这种数据结构在计算机中是相当出名的。栈中的数据是先进后出的（First In Last Out, FILO）。栈只有一个出口，允许新增元素（只能在栈顶上增加）、移出元素（只能移出栈顶元素）、取得栈顶元素等操作。在STL中，栈是以别的容器作为底部结构，再将接口改变，使之符合栈的特性就可以了。因此实现非常的方便。下面就给出栈的函数列表和VS2008中栈的源代码，在STL中栈一共就5个常用操作函数（<span style="color:#ff0000">top()、push()、pop()、
 size()、empty()&nbsp;</span>），很好记的。</span></p>
<p align="center"><img alt="" src="http://hi.csdn.net/attachment/201111/9/0_13208010984xk4.gif" width="454" height="380">
</p>
<div align="left">&nbsp;</div>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p align="left"><strong><span style="font-size:18px">VS2008中栈的源代码</span></strong></p>
<p><span style="font-size:18px">友情提示：初次阅读时请注意其实现思想，不要在细节上浪费过多的时间。</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6950881#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6950881#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6950881#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6950881#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//VS2008中&nbsp;stack的定义&nbsp;MoreWindows整理(http://blog.csdn.net/MoreWindows)
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="keyword">template</span><span>&lt;</span><span class="keyword">class</span><span>&nbsp;_Ty,&nbsp;</span><span class="keyword">class</span><span>&nbsp;_Container&nbsp;=&nbsp;deque&lt;_Ty&gt;&nbsp;&gt;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">class</span><span>&nbsp;stack&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;LIFO&nbsp;queue&nbsp;implemented&nbsp;with&nbsp;a&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;_Container&nbsp;container_type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::value_type&nbsp;value_type;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::size_type&nbsp;size_type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::reference&nbsp;reference;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::const_reference&nbsp;const_reference;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;stack()&nbsp;:&nbsp;c()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;construct&nbsp;with&nbsp;empty&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">explicit</span><span>&nbsp;stack(</span><span class="keyword">const</span><span>&nbsp;_Container&amp;&nbsp;_Cont)&nbsp;:&nbsp;c(_Cont)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;construct&nbsp;by&nbsp;copying&nbsp;specified&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;empty()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;test&nbsp;if&nbsp;stack&nbsp;is&nbsp;empty
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.empty());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;size_type&nbsp;size()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;test&nbsp;length&nbsp;of&nbsp;stack </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.size());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;reference&nbsp;top()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;last&nbsp;element&nbsp;of&nbsp;mutable&nbsp;stack
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.back());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;const_reference&nbsp;top()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;last&nbsp;element&nbsp;of&nbsp;nonmutable&nbsp;stack
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.back());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;push(</span><span class="keyword">const</span><span>&nbsp;value_type&amp;&nbsp;_Val)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;insert&nbsp;element&nbsp;at&nbsp;end
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.push_back(_Val);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;pop()&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;erase&nbsp;last&nbsp;element </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.pop_back();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;_Container&amp;&nbsp;_Get_container()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;get&nbsp;reference&nbsp;to&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">protected</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;_Container&nbsp;c;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;the&nbsp;underlying&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>};&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//VS2008中 stack的定义 MoreWindows整理(http://blog.csdn.net/MoreWindows)
template&lt;class _Ty, class _Container = deque&lt;_Ty&gt; &gt;
class stack
{	// LIFO queue implemented with a container
public:
	typedef _Container container_type;
	typedef typename _Container::value_type value_type;
	typedef typename _Container::size_type size_type;
	typedef typename _Container::reference reference;
	typedef typename _Container::const_reference const_reference;

	stack() : c()
	{	// construct with empty container
	}

	explicit stack(const _Container&amp; _Cont) : c(_Cont)
	{	// construct by copying specified container
	}

	bool empty() const
	{	// test if stack is empty
		return (c.empty());
	}

	size_type size() const
	{	// test length of stack
		return (c.size());
	}

	reference top()
	{	// return last element of mutable stack
		return (c.back());
	}

	const_reference top() const
	{	// return last element of nonmutable stack
		return (c.back());
	}

	void push(const value_type&amp; _Val)
	{	// insert element at end
		c.push_back(_Val);
	}

	void pop()
	{	// erase last element
		c.pop_back();
	}

	const _Container&amp; _Get_container() const
	{	// get reference to container
		return (c);
	}

protected:
	_Container c;	// the underlying container
};</pre>
<p align="left"><span style="font-size:18px">可以看出，由于栈只是进一步封装别的数据结构，并提供自己的接口，所以代码非常简洁，如果不指定容器，默认是用deque来作为其底层数据结构的（对deque不是很了解？可以参阅</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6946811"><span style="font-size:18px">《STL系列之一
 deque双向队列》</span></a><span style="font-size:18px">）。下面给出栈的使用范例：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6950881#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6950881#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6950881#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6950881#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//栈&nbsp;stack支持&nbsp;empty()&nbsp;size()&nbsp;top()&nbsp;push()&nbsp;pop()
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="comment">//&nbsp;by&nbsp;MoreWindows(http://blog.csdn.net/MoreWindows)
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;stack&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;list&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//可以使用list或vector作为栈的容器，默认是使用deque的。 </span>
<span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;stack&lt;</span><span class="datatypes">int</span><span>,&nbsp;list&lt;</span><span class="datatypes">int</span><span>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;stack&lt;</span><span class="datatypes">int</span><span>,&nbsp;vector&lt;</span><span class="datatypes">int</span><span>&gt;&gt;&nbsp;&nbsp;&nbsp;b;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//压入数据 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.push(i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.push(i);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//栈的大小 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;%d\n&quot;</span><span>,&nbsp;a.size(),&nbsp;b.size());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//取栈项数据并将数据弹出栈 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(!a.empty())&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;a.top());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.pop();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(!b.empty())&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;b.top());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.pop();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//栈 stack支持 empty() size() top() push() pop()
// by MoreWindows(http://blog.csdn.net/MoreWindows)
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;cstdio&gt;
using namespace std;
int main()
{
	//可以使用list或vector作为栈的容器，默认是使用deque的。
	stack&lt;int, list&lt;int&gt;&gt;      a;
	stack&lt;int, vector&lt;int&gt;&gt;   b;
	int i;
	
	//压入数据
	for (i = 0; i &lt; 10; i++)
	{
		a.push(i);
		b.push(i);
	}

	//栈的大小
	printf(&quot;%d %d\n&quot;, a.size(), b.size());

	//取栈项数据并将数据弹出栈
	while (!a.empty())
	{
		printf(&quot;%d &quot;, a.top());
		a.pop();
	}
	putchar('\n');

	while (!b.empty())
	{
		printf(&quot;%d &quot;, b.top());
		b.pop();
	}
	putchar('\n');
	return 0;
}</pre>
<p align="left">&nbsp;</p>
<p><span style="font-size:16px">转载请标明出处，原文地址：<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">http://blog.csdn.net/morewindows/article/details/6950881</a></span></p>
</div>
</div>
</h3>
<h3><span class="link_title"></span>&nbsp;</h3>
<h3><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950917">STL系列之三 queue 单向队列
</a></span></h3>
</div>
<div class="article_manage"><span class="link_categories">分类： <a target="_blank" href="http://blog.csdn.net/MoreWindows/article/category/923923">
STL 他山之石</a> </span><span class="link_postdate">2011-11-09 09:20</span> <span class="link_view" title="阅读次数">
7902人阅读</span> <span class="link_comments" title="评论次数"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950917#comments">评论</a>(10)</span>
<span class="link_collect"><a target="_blank" title="收藏" href="">收藏</a></span> <span class="link_report">
<a target="_blank" title="举报" href="http://blog.csdn.net/morewindows/article/details/6950917#report">举报</a></span>
</div>
<div class="tag2box"><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=reference">reference</a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">数据结构</a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=class">class</a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=insert">insert</a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=list">list</a></div>
<div id="article_content" class="article_content">
<p><span style="font-size:18px">queue单向队列与<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">栈</a>有点类&#20284;，一个是在同一端存取数据，另一个是在一端存入数据，另一端取出数据。单向队列中的数据是先进先出（First In First Out,FIFO）。在STL中，单向队列也是以别的容器作为底部结构，再将接口改变，使之符合单向队列的特性就可以了。因此实现也是非常方便的。下面就给出单向队列的函数列表和VS2008中单向队列的源代码。单向队列一共6个常用函数（<span style="color:#ff0000">front()、back()、push()、pop()、empty()、size()</span>），与<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">栈</a>的常用函数较为相&#20284;。</span></p>
<p align="center"><span style="font-size:18px"><img alt="" src="http://hi.csdn.net/attachment/201111/9/0_1320801684QU6a.gif"></span>
</p>
<div align="left">&nbsp;</div>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p align="left"><strong><span style="font-size:18px">VS2008中queue单向队列的源代码</span></strong></p>
<p align="left"><span style="font-size:18px">友情提示：初次阅读时请注意其实现思想，不要在细节上浪费过多的时间。</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6950917#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6950917#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6950917#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6950917#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span>&lt;SPAN&nbsp;style=</span><span class="string">&quot;FONT-SIZE:&nbsp;18px&quot;</span><span>&gt;</span><span class="comment">//VS2008中&nbsp;queue的定义&nbsp;MoreWindows整理(http://blog.csdn.net/MoreWindows)
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="keyword">template</span><span>&lt;</span><span class="keyword">class</span><span>&nbsp;_Ty,&nbsp;</span><span class="keyword">class</span><span>&nbsp;_Container&nbsp;=&nbsp;deque&lt;_Ty&gt;&nbsp;&gt;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">class</span><span>&nbsp;queue&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;FIFO&nbsp;queue&nbsp;implemented&nbsp;with&nbsp;a&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;_Container&nbsp;container_type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::value_type&nbsp;value_type;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::size_type&nbsp;size_type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::reference&nbsp;reference;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::const_reference&nbsp;const_reference;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;queue()&nbsp;:&nbsp;c()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;construct&nbsp;with&nbsp;empty&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">explicit</span><span>&nbsp;queue(</span><span class="keyword">const</span><span>&nbsp;_Container&amp;&nbsp;_Cont)&nbsp;:&nbsp;c(_Cont)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;construct&nbsp;by&nbsp;copying&nbsp;specified&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;empty()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;test&nbsp;if&nbsp;queue&nbsp;is&nbsp;empty
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.empty());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;size_type&nbsp;size()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;length&nbsp;of&nbsp;queue </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.size());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;reference&nbsp;front()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;first&nbsp;element&nbsp;of&nbsp;mutable&nbsp;queue
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.front());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;const_reference&nbsp;front()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;first&nbsp;element&nbsp;of&nbsp;nonmutable&nbsp;queue
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.front());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;reference&nbsp;back()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;last&nbsp;element&nbsp;of&nbsp;mutable&nbsp;queue
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.back());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;const_reference&nbsp;back()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;last&nbsp;element&nbsp;of&nbsp;nonmutable&nbsp;queue
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.back());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;push(</span><span class="keyword">const</span><span>&nbsp;value_type&amp;&nbsp;_Val)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;insert&nbsp;element&nbsp;at&nbsp;beginning
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.push_back(_Val);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;pop()&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;erase&nbsp;element&nbsp;at&nbsp;end </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.pop_front();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;_Container&amp;&nbsp;_Get_container()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;get&nbsp;reference&nbsp;to&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">protected</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;_Container&nbsp;c;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;the&nbsp;underlying&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>};&lt;/SPAN&gt;&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code"><span style="font-size:18px;">//VS2008中 queue的定义 MoreWindows整理(http://blog.csdn.net/MoreWindows)
template&lt;class _Ty, class _Container = deque&lt;_Ty&gt; &gt;
class queue
{	// FIFO queue implemented with a container
public:
	typedef _Container container_type;
	typedef typename _Container::value_type value_type;
	typedef typename _Container::size_type size_type;
	typedef typename _Container::reference reference;
	typedef typename _Container::const_reference const_reference;

	queue() : c()
	{	// construct with empty container
	}

	explicit queue(const _Container&amp; _Cont) : c(_Cont)
	{	// construct by copying specified container
	}

	bool empty() const
	{	// test if queue is empty
		return (c.empty());
	}

	size_type size() const
	{	// return length of queue
		return (c.size());
	}

	reference front()
	{	// return first element of mutable queue
		return (c.front());
	}

	const_reference front() const
	{	// return first element of nonmutable queue
		return (c.front());
	}

	reference back()
	{	// return last element of mutable queue
		return (c.back());
	}

	const_reference back() const
	{	// return last element of nonmutable queue
		return (c.back());
	}

	void push(const value_type&amp; _Val)
	{	// insert element at beginning
		c.push_back(_Val);
	}

	void pop()
	{	// erase element at end
		c.pop_front();
	}

	const _Container&amp; _Get_container() const
	{	// get reference to container
		return (c);
	}

protected:
	_Container c;	// the underlying container
};</span></pre>
<p align="left"><span style="font-size:18px">可以看出，由于queue只是进一步封装别的数据结构，并提供自己的接口，所以代码非常简洁，如果不指定容器，默认是用deque来作为其底层数据结构的（对deque不是很了解？可以参阅</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6946811"><span style="font-size:18px">《STL系列之一deque双向队列》</span></a><span style="font-size:18px">）。下面给出单向队列的使用范例：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6950917#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6950917#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6950917#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6950917#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//单向队列&nbsp;queue支持&nbsp;empty()&nbsp;size()&nbsp;front()&nbsp;back()&nbsp;push()&nbsp;pop()
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="comment">//By&nbsp;MoreWindows(http://blog.csdn.net/MoreWindows)
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;queue&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;list&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//可以使用list作为单向队列的容器，默认是使用deque的。
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;queue&lt;</span><span class="datatypes">int</span><span>,&nbsp;list&lt;</span><span class="datatypes">int</span><span>&gt;&gt;&nbsp;a;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;queue&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//压入数据 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.push(i);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.push(i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//单向队列的大小 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;%d\n&quot;</span><span>,&nbsp;a.size(),&nbsp;b.size());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//队列头和队列尾 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;%d\n&quot;</span><span>,&nbsp;a.front(),&nbsp;a.back());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;%d\n&quot;</span><span>,&nbsp;b.front(),&nbsp;b.back());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//取单向队列项数据并将数据移出单向队列 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(!a.empty())&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;a.front());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.pop();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(!b.empty())&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;b.front());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.pop();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//单向队列 queue支持 empty() size() front() back() push() pop()
//By MoreWindows(http://blog.csdn.net/MoreWindows)
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;cstdio&gt;
using namespace std;

int main()
{
	//可以使用list作为单向队列的容器，默认是使用deque的。
	queue&lt;int, list&lt;int&gt;&gt; a;
	queue&lt;int&gt;        b;
	int i;

	//压入数据
	for (i = 0; i &lt; 10; i++)
	{
		a.push(i);
		b.push(i);
	}

	//单向队列的大小
	printf(&quot;%d %d\n&quot;, a.size(), b.size());

	//队列头和队列尾
	printf(&quot;%d %d\n&quot;, a.front(), a.back());
	printf(&quot;%d %d\n&quot;, b.front(), b.back());

	//取单向队列项数据并将数据移出单向队列
	while (!a.empty())
	{
		printf(&quot;%d &quot;, a.front());
		a.pop();
	}
	putchar('\n');

	while (!b.empty())
	{
		printf(&quot;%d &quot;, b.front());
		b.pop();
	}
	putchar('\n');
	return 0;
}</pre>
<p align="left">&nbsp;</p>
<p><span style="font-size:16px">转载请标明出处，原文地址：<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950917">http://blog.csdn.net/morewindows/article/details/6950917</a></span></p>
</div>
</div>
</div>
</div>
</div>
</div>
<p></p>
<p class="article_content"></p>
<p class="article_content"><span class="link_title"></span>&nbsp;</p>
<p class="article_content"><span class="link_title"></span>&nbsp;</p>
<p class="article_content"><span class="link_title"></span>&nbsp;</p>
<h1 class="article_content"><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6967409">STL系列之四 heap 堆
</a></span></h1>
<div id="body">
<div id="main">
<div class="main">
<div id="article_details" class="details">
<div id="article_content" class="article_content">
<p align="left"><span style="font-size:18px">下面再介绍STL中与堆相关的4个函数——建立堆make_heap()，在堆中添加数据push_heap()，在堆中删除数据pop_heap()和堆排序sort_heap()：</span></p>
<p align="left"><span style="font-size:18px">头文件 #include &lt;algorithm&gt;</span></p>
<p align="left"><span style="font-size:18px">下面的_First与_Last为可以随机访问的迭代器（指针），_Comp为比较函数（仿函数），其规则——如果函数的第一个参数小于第二个参数应返回true，否则返回false。</span></p>
<p align="left"><strong><span style="font-size:18px">建立堆</span></strong></p>
<p align="left"><span style="font-size:18px; color:#ff0000">make_heap(_First, _Last, _Comp)</span></p>
<p align="left"><span style="font-size:18px">默认是建立最大堆的。对int类型，可以在第三个参数传入greater&lt;int&gt;()得到最小堆。</span></p>
<p align="left"><strong><span style="font-size:18px">&nbsp;</span></strong></p>
<p align="left"><strong><span style="font-size:18px">在堆中添加数据</span></strong></p>
<p align="left"><span style="font-size:18px; color:#ff0000">push_heap (_First, _Last)</span></p>
<p align="left"><span style="font-size:18px">要先在容器中加入数据，再调用push_heap ()</span></p>
<p align="left"><span style="font-size:18px">&nbsp;</span></p>
<p align="left"><strong><span style="font-size:18px">在堆中删除数据 </span></strong></p>
<p align="left"><span style="font-size:18px; color:#ff0000">pop_heap(_First, _Last)</span></p>
<p align="left"><span style="font-size:18px">要先调用pop_heap()再在容器中删除数据</span></p>
<p align="left"><strong><span style="font-size:18px">&nbsp;</span></strong></p>
<p align="left"><strong><span style="font-size:18px">堆排序</span></strong></p>
<p align="left"><span style="font-size:18px; color:#ff0000">sort_heap(_First, _Last)
</span></p>
<p align="left"><span style="font-size:18px">排序之后就不再是一个合法的heap了</span></p>
<p align="left"><span style="font-size:18px">&nbsp;</span></p>
<p><span style="font-size:18px">有关堆与堆排序的更详细介绍请参阅——《</span><a target="_blank" title="白话经典算法系列之七 堆与堆排序" href="http://blog.csdn.net/morewindows/article/details/6709644"><span style="font-size:18px">白话经典算法系列之七 堆与堆排序</span></a><span style="font-size:18px">》</span></p>
<p><span style="font-size:18px">&nbsp;</span></p>
<p align="left"><span style="font-size:18px">下面给出STL中heap相关函数的使用范例：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6967409#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6967409#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6967409#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6967409#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//by&nbsp;MoreWindows(&nbsp;http://blog.csdn.net/MoreWindows&nbsp;)
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;functional&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;PrintfVectorInt(vector&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;&amp;vet)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(vector&lt;</span><span class="datatypes">int</span><span>&gt;::iterator&nbsp;pos&nbsp;=&nbsp;vet.begin();&nbsp;pos&nbsp;!=&nbsp;vet.end();&nbsp;pos&#43;&#43;)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;*pos);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">int</span><span>&nbsp;MAXN&nbsp;=&nbsp;20;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;a[MAXN];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;MAXN;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;rand()&nbsp;%&nbsp;(MAXN&nbsp;*&nbsp;2);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//动态申请vector&nbsp;并对vector建堆 </span>
<span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;*pvet&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;vector&lt;</span><span class="datatypes">int</span><span>&gt;(40);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pvet-&gt;assign(a,&nbsp;a&nbsp;&#43;&nbsp;MAXN);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//建堆 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;make_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;PrintfVectorInt(*pvet);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//加入新数据&nbsp;先在容器中加入，再调用push_heap()
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;pvet-&gt;push_back(25);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;push_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;PrintfVectorInt(*pvet);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//删除数据&nbsp;&nbsp;要先调用pop_heap()，再在容器中删除 </span>
<span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pop_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;pvet-&gt;pop_back();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pop_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;pvet-&gt;pop_back();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;PrintfVectorInt(*pvet);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//堆排序 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;sort_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;PrintfVectorInt(*pvet);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">delete</span><span>&nbsp;pvet;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//by MoreWindows( http://blog.csdn.net/MoreWindows )
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
using namespace std;
void PrintfVectorInt(vector&lt;int&gt; &amp;vet)
{
	for (vector&lt;int&gt;::iterator pos = vet.begin(); pos != vet.end(); pos++)
		printf(&quot;%d &quot;, *pos);
	putchar('\n');
}
int main()
{
	const int MAXN = 20;
	int a[MAXN];
	int i;
	for (i = 0; i &lt; MAXN; ++i)
		a[i] = rand() % (MAXN * 2);

	//动态申请vector 并对vector建堆
	vector&lt;int&gt; *pvet = new vector&lt;int&gt;(40);
	pvet-&gt;assign(a, a + MAXN);

	//建堆
	make_heap(pvet-&gt;begin(), pvet-&gt;end());
	PrintfVectorInt(*pvet);

	//加入新数据 先在容器中加入，再调用push_heap()
	pvet-&gt;push_back(25);
	push_heap(pvet-&gt;begin(), pvet-&gt;end());
	PrintfVectorInt(*pvet);

	//删除数据  要先调用pop_heap()，再在容器中删除
	pop_heap(pvet-&gt;begin(), pvet-&gt;end());
	pvet-&gt;pop_back();
	pop_heap(pvet-&gt;begin(), pvet-&gt;end());
	pvet-&gt;pop_back();
	PrintfVectorInt(*pvet);

	//堆排序
	sort_heap(pvet-&gt;begin(), pvet-&gt;end());
	PrintfVectorInt(*pvet);

	delete pvet;
	return 0;
}</pre>
<p align="left"><span style="font-size:18px">掌握其基本用法后，我们用这个堆排序和</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/category/859207"><span style="font-size:18px">《白话经典算法系列》</span></a><span style="font-size:18px">中的</span><a target="_blank" title="白话经典算法系列之七 堆与堆排序" href="http://blog.csdn.net/morewindows/article/details/6709644"><span style="font-size:18px">堆排序</span></a><span style="font-size:18px">、</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6684558"><span style="font-size:18px">快速排序</span></a><span style="font-size:18px">，</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6678165"><span style="font-size:18px">归并排序</span></a><span style="font-size:18px">来进行个性能测试（Win7
 &#43; VS2008 Release下），测试代码如下：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6967409#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6967409#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6967409#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6967409#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//&nbsp;by&nbsp;MoreWindows(&nbsp;http://blog.csdn.net/MoreWindows&nbsp;)
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;ctime&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li><span></span><span class="comment">//------------------------快速排序----------------------------
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;quick_sort(</span><span class="datatypes">int</span><span>&nbsp;s[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;l,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;r)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(l&nbsp;&lt;&nbsp;r)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;l,&nbsp;j&nbsp;=&nbsp;r,&nbsp;x&nbsp;=&nbsp;s[l];&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(i&nbsp;&lt;&nbsp;j)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;j&nbsp;&amp;&amp;&nbsp;s[j]&nbsp;&gt;=&nbsp;x)&nbsp;</span><span class="comment">//&nbsp;从右向左找第一个小于x的数
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(i&nbsp;&lt;&nbsp;j)&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i&#43;&#43;]&nbsp;=&nbsp;s[j];&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;j&nbsp;&amp;&amp;&nbsp;s[i]&nbsp;&lt;&nbsp;x)&nbsp;</span><span class="comment">//&nbsp;从左向右找第一个大于等于x的数
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&#43;&#43;;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(i&nbsp;&lt;&nbsp;j)&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[j--]&nbsp;=&nbsp;s[i];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i]&nbsp;=&nbsp;x;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quick_sort(s,&nbsp;l,&nbsp;i&nbsp;-&nbsp;1);&nbsp;</span><span class="comment">//&nbsp;递归调用&nbsp;
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quick_sort(s,&nbsp;i&nbsp;&#43;&nbsp;1,&nbsp;r);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="comment">//------------------------归并排序----------------------------
</span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="comment">//将有二个有序数列a[first...mid]和a[mid...last]合并。 </span>
<span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;mergearray(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;first,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;mid,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;last,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;temp[])&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;first,&nbsp;j&nbsp;=&nbsp;mid&nbsp;&#43;&nbsp;1;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;m&nbsp;=&nbsp;mid,&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;last;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;k&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(i&nbsp;&lt;=&nbsp;m&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;=&nbsp;n)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(a[i]&nbsp;&lt;&nbsp;a[j])&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[k&#43;&#43;]&nbsp;=&nbsp;a[i&#43;&#43;];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[k&#43;&#43;]&nbsp;=&nbsp;a[j&#43;&#43;];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(i&nbsp;&lt;=&nbsp;m)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[k&#43;&#43;]&nbsp;=&nbsp;a[i&#43;&#43;];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(j&nbsp;&lt;=&nbsp;n)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[k&#43;&#43;]&nbsp;=&nbsp;a[j&#43;&#43;];&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;k;&nbsp;i&#43;&#43;)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[first&nbsp;&#43;&nbsp;i]&nbsp;=&nbsp;temp[i];&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">void</span><span>&nbsp;mergesort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;first,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;last,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;temp[])&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(first&nbsp;&lt;&nbsp;last)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;mid&nbsp;=&nbsp;(first&nbsp;&#43;&nbsp;last)&nbsp;/&nbsp;2;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergesort(a,&nbsp;first,&nbsp;mid,&nbsp;temp);&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//左边有序
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergesort(a,&nbsp;mid&nbsp;&#43;&nbsp;1,&nbsp;last,&nbsp;temp);&nbsp;</span><span class="comment">//右边有序
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergearray(a,&nbsp;first,&nbsp;mid,&nbsp;last,&nbsp;temp);&nbsp;</span><span class="comment">//再将二个有序数列合并
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li><span></span><span class="datatypes">bool</span><span>&nbsp;MergeSort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;*p&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;</span><span class="datatypes">int</span><span>[n];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(p&nbsp;==&nbsp;NULL)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mergesort(a,&nbsp;0,&nbsp;n&nbsp;-&nbsp;1,&nbsp;p);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li><span></span><span class="comment">//------------------------堆排序---------------------------
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">inline</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;Swap(</span><span class="datatypes">int</span><span>&nbsp;&amp;a,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;&amp;b)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;c&nbsp;=&nbsp;a;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;b;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;c;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="comment">//建立最小堆 </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="comment">//&nbsp;&nbsp;从i节点开始调整,n为节点总数&nbsp;从0开始计算&nbsp;i节点的子节点为&nbsp;2*i&#43;1,&nbsp;2*i&#43;2
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;MinHeapFixdown(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;j,&nbsp;temp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;a[i];&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;2&nbsp;*&nbsp;i&nbsp;&#43;&nbsp;1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(j&nbsp;&lt;&nbsp;n)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(j&nbsp;&#43;&nbsp;1&nbsp;&lt;&nbsp;n&nbsp;&amp;&amp;&nbsp;a[j&nbsp;&#43;&nbsp;1]&nbsp;&lt;&nbsp;a[j])&nbsp;</span><span class="comment">//在左右孩子中找最小的
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&#43;&#43;;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(a[j]&nbsp;&gt;=&nbsp;temp)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">break</span><span>;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;a[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//把较小的子结点往上移动,替换它的父结点
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;j;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;2&nbsp;*&nbsp;i&nbsp;&#43;&nbsp;1;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="comment">//建立最小堆 </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">void</span><span>&nbsp;MakeMinHeap(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;0;&nbsp;i--)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MinHeapFixdown(a,&nbsp;i,&nbsp;n);&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;MinheapsortTodescendarray(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;n&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;1;&nbsp;i--)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(a[i],&nbsp;a[0]);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MinHeapFixdown(a,&nbsp;0,&nbsp;i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">int</span><span>&nbsp;MAXN&nbsp;=&nbsp;5000000;&nbsp;&nbsp;</span></li><li><span></span><span class="datatypes">int</span><span>&nbsp;a[MAXN];&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;b[MAXN],&nbsp;c[MAXN],&nbsp;d[MAXN];&nbsp;&nbsp;</span></li><li><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;srand(time(NULL));&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;MAXN;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;rand()&nbsp;*&nbsp;rand();&nbsp;</span><span class="comment">//注rand()产生的数在0到0x7FFF之间
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;MAXN;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i]&nbsp;=&nbsp;c[i]&nbsp;=&nbsp;b[i]&nbsp;=&nbsp;a[i];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">clock_t</span><span>&nbsp;ibegin,&nbsp;iend;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;--当前数据量为%d--By&nbsp;MoreWindows(http://blog.csdn.net/MoreWindows)--\n&quot;</span><span>,&nbsp;MAXN);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//快速排序 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;快速排序:&nbsp;&nbsp;&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ibegin&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;quick_sort(a,&nbsp;0,&nbsp;MAXN&nbsp;-&nbsp;1);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;iend&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d毫秒\n&quot;</span><span>,&nbsp;iend&nbsp;-&nbsp;ibegin);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//归并排序 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;归并排序:&nbsp;&nbsp;&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ibegin&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;MergeSort(b,&nbsp;MAXN);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;iend&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d毫秒\n&quot;</span><span>,&nbsp;iend&nbsp;-&nbsp;ibegin);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//堆排序 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;堆排序:&nbsp;&nbsp;&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;ibegin&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;MakeMinHeap(c,&nbsp;MAXN);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;MinheapsortTodescendarray(c,&nbsp;MAXN);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;iend&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d毫秒\n&quot;</span><span>,&nbsp;iend&nbsp;-&nbsp;ibegin);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//STL中的堆排序 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;STL中的堆排序:&nbsp;&quot;</span><span>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;ibegin&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;make_heap(d,&nbsp;d&nbsp;&#43;&nbsp;MAXN);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;sort_heap(d,&nbsp;d&nbsp;&#43;&nbsp;MAXN);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;iend&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d毫秒\n&quot;</span><span>,&nbsp;iend&nbsp;-&nbsp;ibegin);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">// by MoreWindows( http://blog.csdn.net/MoreWindows )
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
using namespace std;
//------------------------快速排序----------------------------
void quick_sort(int s[], int l, int r)
{
	if (l &lt; r)
	{
		int i = l, j = r, x = s[l];
		while (i &lt; j)
		{
			while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数
				j--;  
			if(i &lt; j) 
				s[i++] = s[j];

			while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数
				i++;  
			if(i &lt; j) 
				s[j--] = s[i];
		}
		s[i] = x;
		quick_sort(s, l, i - 1); // 递归调用 
		quick_sort(s, i + 1, r);
	}
}
//------------------------归并排序----------------------------
//将有二个有序数列a[first...mid]和a[mid...last]合并。
void mergearray(int a[], int first, int mid, int last, int temp[])
{
	int i = first, j = mid + 1;
	int m = mid,   n = last;
	int k = 0;

	while (i &lt;= m &amp;&amp; j &lt;= n)
	{
		if (a[i] &lt; a[j])
			temp[k++] = a[i++];
		else
			temp[k++] = a[j++];
	}

	while (i &lt;= m)
		temp[k++] = a[i++];

	while (j &lt;= n)
		temp[k++] = a[j++];

	for (i = 0; i &lt; k; i++)
		a[first + i] = temp[i];
}
void mergesort(int a[], int first, int last, int temp[])
{
	if (first &lt; last)
	{
		int mid = (first + last) / 2;
		mergesort(a, first, mid, temp);    //左边有序
		mergesort(a, mid + 1, last, temp); //右边有序
		mergearray(a, first, mid, last, temp); //再将二个有序数列合并
	}
}
bool MergeSort(int a[], int n)
{
	int *p = new int[n];
	if (p == NULL)
		return false;
	mergesort(a, 0, n - 1, p);
	return true;
}
//------------------------堆排序---------------------------
inline void Swap(int &amp;a, int &amp;b)
{
	int c = a;
	a = b;
	b = c;
}
//建立最小堆
//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2
void MinHeapFixdown(int a[], int i, int n)
{
	int j, temp;

	temp = a[i];
	j = 2 * i + 1;
	while (j &lt; n)
	{
		if (j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j]) //在左右孩子中找最小的
			j++;

		if (a[j] &gt;= temp)
			break;

		a[i] = a[j];     //把较小的子结点往上移动,替换它的父结点
		i = j;
		j = 2 * i + 1;
	}
	a[i] = temp;
}
//建立最小堆
void MakeMinHeap(int a[], int n)
{
	for (int i = n / 2 - 1; i &gt;= 0; i--)
		MinHeapFixdown(a, i, n);
}
void MinheapsortTodescendarray(int a[], int n)
{
	for (int i = n - 1; i &gt;= 1; i--)
	{
		Swap(a[i], a[0]);
		MinHeapFixdown(a, 0, i);
	}
}
const int MAXN = 5000000;
int a[MAXN];
int b[MAXN], c[MAXN], d[MAXN];
int main()
{
	int i;
	srand(time(NULL));
	for (i = 0; i &lt; MAXN; ++i)
		a[i] = rand() * rand(); //注rand()产生的数在0到0x7FFF之间

	for (i = 0; i &lt; MAXN; ++i)
		d[i] = c[i] = b[i] = a[i];

    clock_t ibegin, iend;

	printf(&quot;--当前数据量为%d--By MoreWindows(http://blog.csdn.net/MoreWindows)--\n&quot;, MAXN);
	//快速排序
	printf(&quot;快速排序:  &quot;);
	ibegin = clock();
	quick_sort(a, 0, MAXN - 1);
	iend = clock();
	printf(&quot;%d毫秒\n&quot;, iend - ibegin);

	
	//归并排序
	printf(&quot;归并排序:  &quot;);
	ibegin = clock();
	MergeSort(b, MAXN);
	iend = clock();
	printf(&quot;%d毫秒\n&quot;, iend - ibegin);

	//堆排序
	printf(&quot;堆排序:  &quot;);
	ibegin = clock();
	MakeMinHeap(c, MAXN);
	MinheapsortTodescendarray(c, MAXN);
	iend = clock();
	printf(&quot;%d毫秒\n&quot;, iend - ibegin);

	//STL中的堆排序
	printf(&quot;STL中的堆排序: &quot;);	
	ibegin = clock();
	make_heap(d, d + MAXN);
	sort_heap(d, d + MAXN);
	iend = clock();
	printf(&quot;%d毫秒\n&quot;, iend - ibegin);
	return 0;
}</pre>
<p align="left"><span style="font-size:18px">对100000（十万）个数据的测试结果：</span></p>
<p align="left"><img alt="" src="http://hi.csdn.net/attachment/201111/14/0_1321233460Fi43.gif"></p>
<p align="left"><span style="font-size:18px">对500000（五十万）个数据的测试结果：</span></p>
<p align="left"><img alt="" src="http://hi.csdn.net/attachment/201111/14/0_1321233476GMB7.gif"></p>
<p align="left"><span style="font-size:18px">对1000000（一百万）个数据的测试结果：</span></p>
<p align="left"><img alt="" src="http://hi.csdn.net/attachment/201111/14/0_1321233489v5C8.gif"></p>
<p align="left"><span style="font-size:18px">对5000000（五百万）个数据的测试结果：</span></p>
<p align="left"><img alt="" src="http://hi.csdn.net/attachment/201111/14/0_1321233500b76W.gif"></p>
<p><span style="font-size:18px">从中可以看出快速排序的效率确实要比其它同为O(N * logN)的排序算法要高，而STL中堆操作函数的性能与《</span><a target="_blank" title="白话经典算法系列之七 堆与堆排序" href="http://blog.csdn.net/morewindows/article/details/6709644"><span style="font-size:18px">白话经典算法系列之七 堆与堆排序</span></a><span style="font-size:18px">》一文中堆操作函数的性能是相差无几的。</span></p>
<p><span style="font-size:18px">&nbsp;</span></p>
<p><span style="font-size:18px">转载请标明出处，原文地址：<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6967409">http://blog.csdn.net/morewindows/article/details/6967409</a></span></p>
</div>
</div>
</div>
</div>
</div>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1053Entropy_（赫夫曼树）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/01/hdu_题目1053Entropy_（赫夫曼树）/">hdu 题目1053Entropy （赫夫曼树）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<h1 align="center" style="color:#1a5cc8">Entropy</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 3152&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1209<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">An entropy encoder is a data encoding method that achieves lossless data compression by encoding a message with “wasted” or “extra” information removed. In other words, entropy encoding removes information that was not necessary in
 the first place to accurately encode the message. A high degree of entropy implies a message with a great deal of wasted information; english text encoded in ASCII is an example of a message type that has very high entropy. Already compressed messages, such
 as JPEG graphics or ZIP archives, have very little entropy and do not benefit from further attempts at entropy encoding.<br>
<br>
English text encoded in ASCII has a high degree of entropy because all characters are encoded using the same number of bits, eight. It is a known fact that the letters E, L, N, R, S and T occur at a considerably higher frequency than do most other letters in
 english text. If a way could be found to encode just these letters with four bits, then the new encoding would be smaller, would contain all the original information, and would have less entropy. ASCII uses a fixed number of bits for a reason, however: it’s
 easy, since one is always dealing with a fixed number of bits to represent each possible glyph or character. How would an encoding scheme that used four bits for the above letters be able to distinguish between the four-bit codes and eight-bit codes? This
 seemingly difficult problem is solved using what is known as a “prefix-free variable-length” encoding.<br>
<br>
In such an encoding, any number of bits can be used to represent any glyph, and glyphs not present in the message are simply not encoded. However, in order to be able to recover the information, no bit pattern that encodes a glyph is allowed to be the prefix
 of any other encoding bit pattern. This allows the encoded bitstream to be read bit by bit, and whenever a set of bits is encountered that represents a glyph, that glyph can be decoded. If the prefix-free constraint was not enforced, then such a decoding would
 be impossible.<br>
<br>
Consider the text “AAAAABCD”. Using ASCII, encoding this would require 64 bits. If, instead, we encode “A” with the bit pattern “00”, “B” with “01”, “C” with “10”, and “D” with “11” then we can encode this text in only 16 bits; the resulting bit pattern would
 be “0000000000011011”. This is still a fixed-length encoding, however; we’re using two bits per glyph instead of eight. Since the glyph “A” occurs with greater frequency, could we do better by encoding it with fewer bits? In fact we can, but in order to maintain
 a prefix-free encoding, some of the other bit patterns will become longer than two bits. An optimal encoding is to encode “A” with “0”, “B” with “10”, “C” with “110”, and “D” with “111”. (This is clearly not the only optimal encoding, as it is obvious that
 the encodings for B, C and D could be interchanged freely for any given encoding without increasing the size of the final encoded message.) Using this encoding, the message encodes in only 13 bits to “0000010110111”, a compression ratio of 4.9 to 1 (that is,
 each bit in the final encoded message represents as much information as did 4.9 bits in the original encoding). Read through this bit pattern from left to right and you’ll see that the prefix-free encoding makes it simple to decode this into the original text
 even though the codes have varying bit lengths.<br>
<br>
As a second example, consider the text “THE CAT IN THE HAT”. In this text, the letter “T” and the space character both occur with the highest frequency, so they will clearly have the shortest encoding bit patterns in an optimal encoding. The letters “C”, “I’
 and “N” only occur once, however, so they will have the longest codes.<br>
<br>
There are many possible sets of prefix-free variable-length bit patterns that would yield the optimal encoding, that is, that would allow the text to be encoded in the fewest number of bits. One such optimal encoding is to encode spaces with “00”, “A” with
 “100”, “C” with “1110”, “E” with “1111”, “H” with “110”, “I” with “1010”, “N” with “1011” and “T” with “01”. The optimal encoding therefore requires only 51 bits compared to the 144 that would be necessary to encode the message with 8-bit ASCII encoding, a
 compression ratio of 2.8 to 1.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The input file will contain a list of text strings, one per line. The text strings will consist only of uppercase alphanumeric characters and underscores (which are used in place of spaces). The end of the input will be signalled
 by a line containing only the word “END” as the text string. This line should not be processed.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each text string in the input, output the length in bits of the 8-bit ASCII encoding, the length in bits of an optimal prefix-free variable-length encoding, and the compression ratio accurate to one decimal point.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">AAAAABCD
THE_CAT_IN_THE_HAT
END</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">64 13 4.9
144 51 2.8</div></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size:18px">数组tree下标0代表‘_’,1---26代表A---Z，weigth代表出现的次数，deep代表结点所在赫夫曼树的深度，</span></strong></p>
<p><strong><span style="font-size:18px">建立的新节点放在下标27开始，</span></strong></p>
<p><strong><span style="font-size:18px">最后将0---26中元素的权&#20540; (出现次数) weigth * deep 累加起来；</span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>代码： 请无视注释，</p>
<pre class="cpp" name="code">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

using namespace std;

typedef struct TREE
{
	int weigth,parent,lchild,rchild,deep;
}TREE;

TREE tree[55];
bool visit[55];


int len_huff(int n)
{
	int j,i,k;
	memset(visit,0,sizeof(visit));
	int min1,min2,index1,index2;
	
	int num = 0;
	for(i=0;i&lt;27;i++)
	{
		if(tree[i].weigth != 0)
		{
			k=i;
			num++;
		} 	
	
	}
		
	if(num==1) return tree[k].weigth;
//	printf(&quot;num=%d\n&quot;,num);
	
	for(i=27;i&lt;26+num;i++)
	{
		
		
		min1 = min2 = 999999;
		for(j=0;j&lt;i;j++)//寻找最小的两个元素
		{
			if(!visit[j])
			{
				if( tree[j].weigth!=0 &amp;&amp; tree[j].weigth&lt;min1)
				{
					min2 = min1;
					index2 = index1;
					min1 = tree[j].weigth;
					index1 = j;		
				}
				else if( tree[j].weigth!=0 &amp;&amp; tree[j].weigth&lt;min2)
				{
					index2 = j;
					min2 = tree[j].weigth;
				}										
			}//if 							
		}	
		visit[index1] = visit[index2] = 1;
//		printf(&quot;index1=%d,min1=%d,index2=%d,min2=%d\n&quot;,index1,min1,index2,min2);//找到最小的两个 
			
	//	tree[index1].deep++;
	//	tree[index2].deep++;
		
		tree[i].weigth = min1 + min2;  //新结点
		tree[i].lchild = index1; 
		tree[i].rchild = index2;
		tree[index1].parent = tree[index2].parent = i;
	}
	
//	for(i=27;i&lt;55;i++)
//	{
//		int child = tree[i].lchild;
//		int parent,dp=1;
////				printf(&quot;lchild=%d\n&quot;,child);
//		while(child!=-1)
//		{
//			dp++;
//			parent = child;
//			child = tree[child].lchild;
//		}	
//		tree[parent].deep = dp;
////		
//		printf(&quot;pa=%d,de=%d\n&quot;,parent,dp);
//		child = tree[i].rchild;
//		dp=1;
//		while(child!=-1)
//		{
//			dp++;
//			parent = child;
//			child = tree[child].rchild;
//		}	
//		tree[parent].deep = dp;
//	//	printf(&quot;rchild=%d,de=%d\n&quot;,child,dp);
//	}



	int len = 0;
	for(i=0;i&lt;27;i++)//计算每个节点的深度
	{
		int parent = tree[i].parent;
		int child ,dp=0;
//				printf(&quot;lchild=%d\n&quot;,child);
		while(parent !=-1)//不是 根节点 
		{
			dp++;
			child= parent ;
			parent  = tree[parent].parent;
		}	
		tree[i].deep = dp;
		len += tree[i].deep*tree[i].weigth;	
//		
	}
//	printf(&quot;%d &quot;,len);
	return len;
					
}
/*
AA
AAAAABCD
THE_CAT_IN_THE_HAT
END
*/
int main()
{
	char s[10001];
	int i;
	while(gets(s))
	{
		if(strcmp(s,&quot;END&quot;)==0) break;
	//	printf(&quot;%d &quot;,);
		
		memset(tree,-1,sizeof(tree));
		for(i=0;i&lt;55;i++) tree[i].weigth=tree[i].deep=0;
		
		for(i=0;i&lt;strlen(s);i++)
		{
			if(s[i]=='_') tree[0].weigth++;
			else tree[s[i]-'A'+1].weigth++;	
		}
		
		int len2 = len_huff(strlen(s));
		
		int len1 = strlen(s)*8; 
		
		
		double radio = 1.0*len1/len2;
//	printf(&quot;len1=%d,len2=%lld,radio=%lf\n&quot;,len1,len2,radio);
		printf(&quot;%d %d %.1lf\n&quot;,strlen(s)*8,len2,radio);
//		printf(&quot;    i    weigth   parent    lchild    rchild    deep\n&quot;);
//		for(i=0;i&lt;55;i++)
//			printf(&quot; %4d:   %5d    %5d    %5d    %5d    %5d\n&quot;,i,tree[i].weigth,tree[i].parent,tree[i].lchild,tree[i].rchild,tree[i].deep);	
		
		
	//	printf(&quot;%d &quot;,length_Haffuman(s));
	//	printf(&quot;.1lf\n&quot;,1.0*strlen(s)/length_Haffuman(s));			
	}
	return 0;	
}
</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-POJ_题目3253_Fence_Repair_（赫夫曼树应用）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/01/POJ_题目3253_Fence_Repair_（赫夫曼树应用）/">POJ 题目3253 Fence Repair （赫夫曼树应用）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>本题主要利用赫夫曼树的原理，</p>
<p>&nbsp;</p>
<div lang="en-US" class="ptt" align="center"><strong><span style="font-size:18px; color:#3366ff">Fence Repair</span></strong></div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><strong>Time Limit:</strong> 2000MS</td>
<td width="10">&nbsp;</td>
<td><strong>Memory Limit:</strong> 65536K</td>
</tr>
<tr>
<td><strong>Total Submissions:</strong> 19794</td>
<td width="10">&nbsp;</td>
<td><strong>Accepted:</strong> 6276</td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div lang="en-US" class="ptx">
<p>Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs<em>N</em> (1 ≤
<em>N</em> ≤ 20,000) planks of wood, each having some integer length<em>L<sub>i</sub></em> (1 ≤
<em>L<sub>i</sub></em> ≤ 50,000) units. He then purchases a single long board just long enough to saw into the<em>N</em> planks (i.e., whose length is the sum of the lengths
<em>L<sub>i</sub></em>). FJ is ignoring the &quot;kerf&quot;, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.</p>
<p>FJ sadly realizes that he doesn't own a saw with which to cut the wood, so he mosies over to Farmer Don's Farm with this long board and politely asks if he may borrow a saw.</p>
<p>Farmer Don, a closet capitalist, doesn't lend FJ a saw but instead offers to charge Farmer John for each of the<em>N</em>-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.</p>
<p>Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the<em>N</em> planks. FJ knows that he can cut the board in various different orders which will
 result in different charges since the resulting intermediate planks are of different lengths.</p>
</div>
<p class="pst">Input</p>
<div lang="en-US" class="ptx">Line 1: One integer <em>N</em>, the number of planks<br>
Lines 2..<em>N</em>&#43;1: Each line contains a single integer describing the length of a needed plank</div>
<p class="pst">Output</p>
<div lang="en-US" class="ptx">Line 1: One integer: the minimum amount of money he must spend to make<em>N</em>-1 cuts</div>
<p class="pst">Sample Input</p>
<pre class="sio">3
8
5
8</pre>
<p class="pst">Sample Output</p>
<pre class="sio">34</pre>
<p class="pst">Hint</p>
<div lang="en-US" class="ptx">He wants to cut a board of length 21 into pieces of lengths 8, 5, and 8.<br>
The original board measures 8&#43;5&#43;8=21. The first cut will cost 21, and should be used to cut the board into pieces measuring 13 and 8. The second cut will cost 13, and should be used to cut the 13 into 8 and 5. This would cost 21&#43;13=34. If the 21 was cut into
 16 and 5 instead, the second cut would cost 16 for a total of 37 (which is more than 34).</div>
<div lang="en-US" class="ptx">&nbsp;</div>
<div lang="en-US" class="ptx">&nbsp;</div>
<p><strong><span style="font-size:18px">解题思路 ：要将长度为n的一个长木板 分成若干短的，分解长度为n的木板需要花费n；</span></strong></p>
<p><strong><span style="font-size:18px">如题中给出要求的3个木板长度，所以最初开始木板长度为 8&#43;5&#43;8=21</span></strong></p>
<p><strong><span style="font-size:18px">将长度为21的木板分解成3段，并且要求花费最少，</span></strong></p>
<p><strong><span style="font-size:18px">第一次分解 21， 分成8和13，</span></strong></p>
<p><strong><span style="font-size:18px">第二次分解 13，分成8和5，此种分法花费最少，但这种分法是什么规则呢？？？？</span></strong></p>
<p><strong><span style="font-size:18px"></span></strong>&nbsp;</p>
<p><strong><span style="font-size:18px">倒过来逆向思维，将若干个长度的木板拼接成一个，每两个（长度a，b）拼成一个长度为（a&#43;b），就花费 （a&#43;b）元</span></strong></p>
<p><strong><span style="font-size:18px">要使总花费最少，则每次选择长度最小的两个拼接，，就像建立赫夫曼树那样来做</span></strong></p>
<p><strong><span style="font-size:18px"></span></strong>&nbsp;</p>
<p><strong><span style="font-size:18px"></span></strong>&nbsp;</p>
<p><strong><span style="font-size:18px">第一次代码：超时，，，，建立一个一位数组，从0开始存元素，dao下标n-1，，，</span></strong></p>
<p><strong><span style="font-size:18px">将它们从大到小排序，，取出后两个相加，将和sum放到数组后面，代替那两个组小&#20540;，数组元素--；</span></strong></p>
<p><strong><span style="font-size:18px">然后将数组再次里面排序，取最小&#20540;两个，重复，&#20540;到剩一个，</span></strong></p>
<p><strong><span style="font-size:18px">每次取出的两个最小的和 累加起来 即为最少花费！！</span></strong></p>
<p>超时代码：</p>
<pre class="cpp" name="code">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
using namespace std;

int a[20002];
bool cmp(int a,int b)
{
	if(a&gt;b) return true;
	return false;
}
void Haffman(int num)
{
/*
4
3 6 1 4
*/
	int n = num;
	int i;
	int sum =0;
	while(n--)
	{
	//	printf(&quot;sum=%d\n&quot;,sum);
		sort(a,a+n+1,cmp);
	//	for(i=0;i&lt;n+1;i++) printf(&quot;%d &quot;,a[i]);
	//	printf(&quot;\n&quot;);
		a[n-1] = a[n]+a[n-1];
		sum += a[n-1];
		if(n==1) break;
	}
	printf(&quot;%d\n&quot;,sum);
		
}

int main()
{
	int i,n;
//	int a[10001];
	scanf(&quot;%d&quot;,&amp;n);
	for(i=0;i&lt;n;i++)
		scanf(&quot;%d&quot;,&amp;a[i]);	
	//	scanf(&quot;%d&quot;,&amp;tree[i].weigth);	
	
	Haffman(n);			
		
	system(&quot;pause&quot;);
	return 0;	
}

</pre>
<p><br>
第二次代码：时间：500MS </p>
<p>其实不用每次都进行排序，第一次排完序之后，将新得到的和直接再插入到数组内即可，数组仍然有序</p>
<pre class="html" name="code">#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
using namespace std;

int a[20002];
int  cmp(const void  * a,const void * b)
{
	return *(int *)b  - *(int *)a;
}
void Haffman(int num)
{
/*
6
3 6 1 4 5 2
*/
	int n = num;
	int i,j,k;
	long long sum =0;
	qsort(a,n,sizeof(int),cmp);
	
	for(i=0;i&lt;n-1;i++)
	{		
		int temp = a[num-1]+a[num-2];
		for(j=n-1;j&gt;=0;j--)//将和插入到数组里面
		{
			if(temp&lt;a[j]) break;
			else a[j+1] = a[j];		
		}
		a[j+1] = temp; 
		sum += temp;//每次的和累加
		num--;
	}
	printf(&quot;%lld\n&quot;,sum);
		
}

int main()
{
	int i,n;

	while(scanf(&quot;%d&quot;,&amp;n)!=EOF)
	{
		for(i=0;i&lt;n;i++)
				scanf(&quot;%d&quot;,&amp;a[i]);		
		if(n==1) printf(&quot;0\n&quot;);	
		else	Haffman(n);	
	}		
	//system(&quot;pause&quot;);
	return 0;	
}


</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size:18px"></span></strong>&nbsp;下面是别人用的堆排序做的，时间90MS</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
using namespace std;
typedef long long int64;
int len;
int64 arr[20001]; //arr[0] 存数当前数组的长度

//调整堆
void heap(int i) {
	int left = i * 2;
	int right = i * 2 + 1;
	int mins = i;
	if (left &lt;= arr[0] &amp;&amp; arr[left] &lt; arr[mins])
		mins = left;
	if (right &lt;= arr[0] &amp;&amp; arr[right] &lt; arr[mins])
		mins = right;
	if (i != mins) {
		swap(arr[i], arr[mins]);
		heap(mins);
	}
}

//想堆中插入一个数
void inheap(int64 key) {
	arr[++arr[0]] = key;
	int64 i = arr[0];
	//i就是当前插入的最后位置. 循环 lgn 次即可
	while (i &gt; 1 &amp;&amp; arr[i] &lt; arr[i / 2]) {
		swap(arr[i], arr[i / 2]);
		i = i / 2;
	}
}

//返回最小的两个数的和
int64 get() {
	int64 p = arr[1], q;
	arr[1] = arr[arr[0]]; //第一个位置 和 最后一个位置交换
	arr[0]--; //数组长度减1
	heap(1); //调整位置1
	q = arr[1];
	arr[1] = arr[arr[0]];
	arr[0]--;
	heap(1);
	inheap(p + q); //返回最小的两个数的和
	return p + q;
}

int main() {
	while (cin &gt;&gt; len) {
		arr[0] = 0;
		for (int i = 1; i &lt;= len; i++) {
			cin &gt;&gt; arr[i];
			inheap(arr[i]);
		}
		int64 ans = 0;
		for (int i = 1; i &lt; len; i++) {
			ans += get();
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}


</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hud1805_题目_Expression_（数组创建二叉树_树的层次遍历" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/31/hud1805_题目_Expression_（数组创建二叉树_树的层次遍历/">hud1805 题目 Expression （数组创建二叉树+树的层次遍历</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 align="center" style="color:#1a5cc8">Expressions</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 1000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 201&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 102<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">Arithmetic expressions are usually written with the operators in between the two operands (which is called infix notation). For example, (x&#43;y)*(z-w) is an arithmetic expression in infix notation. However, it is easier to write a program
 to evaluate an expression if the expression is written in postfix notation (also known as reverse polish notation). In postfix notation, an operator is written behind its two operands, which may be expressions themselves. For example, x y &#43; z w - * is a postfix
 notation of the arithmetic expression given above. Note that in this case parentheses are not required.
<br>
<br>
To evaluate an expression written in postfix notation, an algorithm operating on a stack can be used. A stack is a data structure which supports two operations:
<br>
<br>
1. push: a number is inserted at the top of the stack. <br>
2. pop: the number from the top of the stack is taken out. <br>
During the evaluation, we process the expression from left to right. If we encounter a number, we push it onto the stack. If we encounter an operator, we pop the first two numbers from the stack, apply the operator on them, and push the result back onto the
 stack. More specifically, the following pseudocode shows how to handle the case when we encounter an operator O:
<br>
<br>
a := pop();<br>
b := pop();<br>
push(b O a);<br>
The result of the expression will be left as the only number on the stack. <br>
<br>
Now imagine that we use a queue instead of the stack. A queue also has a push and pop operation, but their meaning is different:
<br>
<br>
1. push: a number is inserted at the end of the queue. <br>
2. pop: the number from the front of the queue is taken out of the queue. <br>
Can you rewrite the given expression such that the result of the algorithm using the queue is the same as the result of the original expression evaluated using the algorithm with the stack?
<br>
</div>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The first line of the input contains a number T (T ≤ 200). The following T lines each contain one expression in postfix notation. Arithmetic operators are represented by uppercase letters, numbers are represented by lowercase letters.
 You may assume that the length of each expression is less than 10000 characters.
<br>
</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each given expression, print the expression with the equivalent result when using the algorithm with the queue instead of the stack. To make the solution unique, you are not allowed to assume that the operators are associative
 or commutative. <br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">2
xyPzwIM
abcABdefgCDEF</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">wzyxIPM
gfCecbDdAaEBF</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>解题思路:</p>
<p>&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr><a target="_blank" href="http://photo.blog.sina.com.cn/showpic.html#blogid=64018c250100qi0j&amp;url=http://s1.sinaimg.cn/orignal/64018c25g9fdb220d6420"></a><br>
<a target="_blank" href="http://photo.blog.sina.com.cn/showpic.html#blogid=64018c250100qi0j&amp;url=http://s14.sinaimg.cn/orignal/64018c25g9fdb29ad7a0d"></a><img src="http://img.blog.csdn.net/20130731214513281" alt=""><img src="http://img.blog.csdn.net/20130731214513468" alt=""></p>
<p><br>
从图中我们可以发现output &nbsp;<wbr>就是从层序遍历得到的字符串按照逆序输出</p>
<p>&nbsp;</p>
<p>第一次可恶的超时了：</p>
<p>&nbsp;主要是创建数组用的二叉链表，</p>
<pre class="cpp" name="code">typedef struct node
{
      char data;
      node * lchild;
      node * rchild;  
}node;

</pre>
<p><br>
还有队列用的STL标准模板，不知道为什么这也会很费时间;;;;==!</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
using namespace std;

typedef struct node
{
      char data;
      node * lchild;
      node * rchild;  
}node;


stack &lt;node *&gt; S;

//int k; 
//char Pnt[10002];


bool is_upper(char c)
{
     if(c&gt;='A' &amp;&amp; c&lt;='Z') return true;
     return false;     
}

node * create_tree(char s[])
{
	node * p;
	node *root;
	int i;
     for(i=0;i&lt;strlen(s);i++)
     {
           if(is_upper(s[i]))
           {
                p = (node*)malloc(sizeof(node));
				p-&gt;data = s[i];
				p-&gt;rchild = S.top(); S.pop();
				p-&gt;lchild = S.top(); S.pop();

				root = p;
				S.push(p);                 
           }              
		   else 
		   {
				p = (node*)malloc(sizeof(node));
				p-&gt;data = s[i];
				p-&gt;lchild = NULL;
				p-&gt;rchild = NULL;
				S.push(p);
			}    
     }
     return root;
}

void BFS(node * root)
{
	queue &lt;node *&gt; Q;
	Q.push(root);
	while(!Q.empty()) 
	{
		printf(&quot;%c&quot;,Q.front()-&gt;data);
		if(Q.front()-&gt;lchild) Q.push(Q.front()-&gt;lchild);
		if(Q.front()-&gt;rchild) Q.push(Q.front()-&gt;rchild);
		//Pnt[k++] = 	Q.front()-&gt;data;		
		Q.pop();	
	}	
}
/*
2
xyPzwIM
abcABdefgCDEF
*/
int main()
{
    int t,i;char s[10002];
    node *root;
    scanf(&quot;%d&quot;,&amp;t);
    getchar();
    while(t--)
    {
        gets(s); 
        root = create_tree(s);	 	
        BFS(root);             
		printf(&quot;\n&quot;);
    }
 //   system(&quot;pause&quot;);
    return 0;    
}


</pre>
<p><br>
f第二次：南开oj 通过，因为限时2000MS ，&nbsp; 改进代码时间 1500MS&nbsp; ，但是对于杭电oj，POJ都不行，还超时，</p>
<p>其中放弃二叉链表创建数组，而是用一个 结构体数组，存放孩子信息，</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
using namespace std;

typedef struct TREE 
{
	char dat;
	int l,r;	
}TREE;

TREE tree[10002];

stack &lt;int&gt; S;

int k; 
char Pnt[10002];


bool is_upper(char c)
{
     if(c&gt;='A' &amp;&amp; c&lt;='Z') return true;
     return false;     
}

void create_tree(char s[])
{
	
	node * p;
	node *root;
	int i;
    for(i=0;i&lt;strlen(s);i++)
    {
		tree[i].dat=s[i];
       if(is_upper(s[i]))
       {
			tree[i].r = S.top(); S.pop();
			tree[i].l = S.top(); S.pop();
			S.push(i);
//               p = (node*)malloc(sizeof(node));
//				p-&gt;data = s[i];
//				p-&gt;rchild = S.top(); S.pop();
//				p-&gt;lchild = S.top(); S.pop();
//
//				root = p;
//				S.push(p);    
			             
       }              
	   else 
	   {
			tree[i].r = -1;
			tree[i].l = -1;
			S.push(i);
		//	p = (node*)malloc(sizeof(node));
//				p-&gt;data = s[i];
//				p-&gt;lchild = NULL;
//				p-&gt;rchild = NULL;
//				S.push(p);
		}    
     }
    // return root;
}

void BFS(char s[])
{
	queue &lt;int&gt; Q;
	Q.push(strlen(s)-1);
	while(!Q.empty()) 
	{
		Pnt[k++] = 	tree[Q.front()].dat;
	//	printf(&quot;%c&quot;,tree[Q.front()].dat);
		if(tree[Q.front()].l != -1) Q.push(tree[Q.front()].l);
		if(tree[Q.front()].r != -1) Q.push(tree[Q.front()].r);
				
		Q.pop();	
	}	
}
/*
2
xyPzwIM
abcABdefgCDEF
*/
int main()
{
    int t,i;char s[10002];
    node *root;
    scanf(&quot;%d&quot;,&amp;t);
    getchar();
    while(t--)
    {
		k=0;
        gets(s); 
        create_tree(s);	 	
        BFS(s);  
      //  printf(&quot;\n&quot;);
		Pnt[k]='\0'; 
		for(i=strlen(Pnt)-1;i&gt;=0;i--) printf(&quot;%c&quot;,Pnt[i]);          
		printf(&quot;\n&quot;);
    }
   // system(&quot;pause&quot;);
    return 0;    
}


</pre>
<p>第三次改进： 就放弃STLqueue 用一个一位数组表示队列，（我不知道是不是这里的原因，，，时间一下子减少不少），如果有大神知道的话，混应知道</p>
<p>time： 20MS，，这次到哪里都可以AC，无压力了；；；</p>
<pre class="cpp" name="code">#define N 10005
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
typedef struct TREE 
{
	int l,r,own;	
}TREE;

TREE tree[N];
char Pnt[N],s[N];
int Stack[N],Q[N];

void build_tree(int n)
{
	int i,top=-1;
	memset(tree,-1,sizeof(tree));
	for(i=0;i&lt;n;i++)
	{
		if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z')//小写 
		Stack[++top]=i;
		else{
			tree[i].r = Stack[top--];
			tree[i].l = Stack[top];
			Stack[top]= i;
		}
		tree[i].own = i;
	}
}
void BFS(int n)
{	

	int front=0,rear=1,k=0; 
	for(Q[0]=n;front&lt;rear;front++)
	{
		TREE u = tree[Q[front]];
	//	printf(&quot;front=%d,c=%c\n&quot;,front,s[u.own]);
		Pnt[k++]= s[u.own];
		if(u.l != -1) Q[rear++] = u.l;
		if(u.r != -1) Q[rear++] = u.r;					
	}	
}
/*
2
xyPzwIM
abcABdefgCDEF
*/
int main()
{
    int t,i,k;
    scanf(&quot;%d&quot;,&amp;t);
    getchar();
    while(t--)
    {
        gets(s);
       // printf(&quot;len=%d\n&quot;,strlen(s));
        int n = strlen(s);
        build_tree(n);
        BFS(n-1); 
 
		for(i=n-1;i&gt;=0;i--) printf(&quot;%c&quot;,Pnt[i]);          
		printf(&quot;\n&quot;);
			
    }
  // system(&quot;pause&quot;);
    return 0;    
}

</pre>
<p><br>
<br>
&nbsp;</p>
<p>&nbsp;</p>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-二叉树的层次遍历（相当于广度遍历）_SJTU_OJ_题目_1040二叉树层次遍历" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/31/二叉树的层次遍历（相当于广度遍历）_SJTU_OJ_题目_1040二叉树层次遍历/">二叉树的层次遍历（相当于广度遍历） SJTU OJ 题目 1040二叉树层次遍历</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;&nbsp;</p>
<h1 class="page-header" align="center" style="">1040. 二叉树层次遍历</h1>
<div class="row" style="">
<h2 style="line-height:36px; margin:0px; font-family:inherit; font-size:24px; font-weight:bold">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Description</h2>
<p style="margin:0px 0px 9px">给出一棵二叉树，求它的层次遍历结果。</p>
<p style="margin:0px 0px 9px">[二叉树的遍历问题是一种精神，务必领会]</p>
<h2 style="line-height:36px; margin:0px; font-family:inherit; font-size:24px; font-weight:bold">
Input Format</h2>
<p style="margin:0px 0px 9px">第一行，N&lt;1000000，表示二叉树节点数。</p>
<p style="margin:0px 0px 9px">默认序号为0的节点为树根。接下来共N-1行，依次表示序号为1，...，N-1的节点的父亲节点序号。</p>
<p style="margin:0px 0px 9px">如果一个节点有两个孩子节点，左孩子节点序号总是小于右孩子节点序号。</p>
<h2 style="line-height:36px; margin:0px; font-family:inherit; font-size:24px; font-weight:bold">
Output Format</h2>
<p style="margin:0px 0px 9px">仅一行，二叉树的层次遍历结果。节点序号间用空&#26684;隔开。</p>
<h2 style="line-height:36px; margin:0px; font-family:inherit; font-size:24px; font-weight:bold">
Hint</h2>
<h2 style="line-height:36px; margin:0px; font-family:inherit; font-size:24px; font-weight:bold">
Sample Input</h2>
<pre style="border-bottom:1px solid; border-left:1px solid; padding-bottom:8px; line-height:18px; background-color:rgb(245,245,245); margin:0px 0px 9px; padding-left:8px; padding-right:8px; display:block; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; word-wrap:break-word; white-space:pre-wrap; color:rgb(51,51,51); font-size:12px; word-break:break-all; border-top:1px solid; border-right:1px solid; padding-top:8px"><code style="border-bottom:0px; border-left:0px; padding-bottom:0px; background-color:transparent; padding-left:0px; padding-right:0px; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; border-top:0px; border-right:0px; padding-top:0px">6
0
1
1
0
4
</code></pre>
<h2 style="line-height:36px; margin:0px; font-family:inherit; font-size:24px; font-weight:bold">
Sample Output</h2>
<pre style="border-bottom:1px solid; border-left:1px solid; padding-bottom:8px; line-height:18px; background-color:rgb(245,245,245); margin:0px 0px 9px; padding-left:8px; padding-right:8px; display:block; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; word-wrap:break-word; white-space:pre-wrap; color:rgb(51,51,51); font-size:12px; word-break:break-all; border-top:1px solid; border-right:1px solid; padding-top:8px"><code style="border-bottom:0px; border-left:0px; padding-bottom:0px; background-color:transparent; padding-left:0px; padding-right:0px; font-family:Menlo,Monaco,Consolas,'Courier New',monospace; font-size:12px; border-top:0px; border-right:0px; padding-top:0px">0 1 4 2 3 5</code></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size:18px">&nbsp;分析：一开始我想到直接建一个二维数组，tree[num][2];&nbsp; </span>
</strong></p>
<p><strong><span style="font-size:18px">&nbsp; 行标为根结点，每一行第一个为左子树，第二个为右子树；</span></strong></p>
<p>&nbsp;<img src="http://img.blog.csdn.net/20130731143430859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTI4MjA2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size:18px">然后从o结点开始遍历，遍历完两个子树，然后从左子树开始遍历，遍历左子树两个子树，但是很难确定什么时候当前节点的堂兄弟是否都已经遍历，</span></strong></p>
<p><strong><span style="font-size:18px">后来问问女朋友，她说我肯定是没看它的博客，我到她的新浪博客找找看，结果找到了</span></strong><a target="_blank" href="http://blog.sina.com.cn/s/blog_abecef150101jpxb.html"><strong><span style="font-size:18px">二叉树遍历问题</span></strong></a><strong><span style="font-size:18px">，下面看看是怎么实现的层次遍历</span></strong></p>
<p><strong><span style="font-size:18px">建立一个队列 queue &lt;int &gt;Q;&nbsp; (头文件#include&lt;queue&gt;),</span></strong></p>
<p><strong><span style="font-size:18px">1.首先将根节点0入队，</span></strong></p>
<p><strong><span style="font-size:18px">2.将队首元素的两个子树入队，</span></strong></p>
<p><strong><span style="font-size:18px">3.将队首元素输出，出队，然后重复步骤2，直到队列为空（或者直到所有元素输出）</span></strong></p>
<p><strong><span style="font-size:18px"></span></strong>&nbsp;</p>
<p><strong><span style="font-size:18px">代码：</span></strong></p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;



using namespace std;

int tree[1000002][2];//注意题目中的N&lt;1000000;额这里我一开始设置的小了，提交一直RUN TIME ERROR 
int cnt=0;

queue &lt; int&gt; Q;

void Traverse(int n)
{
	cnt++;
	if(cnt&gt;n) return ;
	//将对头元素的两个子树入队 
	if(tree[Q.front()][0]!=-1) Q.push(tree[Q.front()][0]);
	if(tree[Q.front()][1]!=-1) Q.push(tree[Q.front()][1]);
	
	printf(&quot;%d&quot;,Q.front());
	if(cnt&lt;n) printf(&quot; &quot;);
	Q.pop();
	Traverse(n);
}
int main()
{
	int i,n,parent;
	scanf(&quot;%d&quot;,&amp;n);
	
	cnt=0;
//	while( !Q.empty() ) Q.pop();
	for(i=0;i&lt;n;i++) 
		tree[i][0] = tree[i][1] = -1;
	
	for(i=1;i&lt;n;i++)
	{
		scanf(&quot;%d&quot;,&amp;parent);
		if(tree[parent][0]!=-1 )  //0位置有元素
		{
			if(tree[parent][0]&gt;i)//比较xiao的放到0位置， 
			{
				tree[parent][1] = tree[parent][0]; 
				tree[parent][0]	= i; 
			}
			else tree[parent][1] = i; 
		}
		else tree[parent][0]=i;
	}	
	Q.push(0);
//	for(i=0;i&lt;n;i++)printf(&quot;%4d %4d\n&quot;,tree[i][0],tree[i][1]);
	Traverse(n);
	printf(&quot;\n&quot;);
	
	return 0;
}</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-已知树的前序和中序求后序_hdu_题目1710_Binary_Tree_Traversals" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/31/已知树的前序和中序求后序_hdu_题目1710_Binary_Tree_Traversals/">已知树的前序和中序求后序 hdu 题目1710 Binary Tree Traversals</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">Binary Tree Traversals</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 1000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 2448&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1066<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">A binary tree is a finite set of vertices that is either empty or consists of a root r and two disjoint binary trees called the left and right subtrees. There are three most important ways in which the vertices of a binary tree can
 be systematically traversed or ordered. They are preorder, inorder and postorder. Let T be a binary tree with root r and subtrees T1,T2.<br>
<br>
In a preorder traversal of the vertices of T, we visit the root r followed by visiting the vertices of T1 in preorder, then the vertices of T2 in preorder.<br>
<br>
In an inorder traversal of the vertices of T, we visit the vertices of T1 in inorder, then the root r, followed by the vertices of T2 in inorder.<br>
<br>
In a postorder traversal of the vertices of T, we visit the vertices of T1 in postorder, then the vertices of T2 in postorder and finally we visit r.<br>
<br>
Now you are given the preorder sequence and inorder sequence of a certain binary tree. Try to find out its postorder sequence.<br>
<center><img src="http://acm.hdu.edu.cn/data/images/C57-1005-1.jpg" alt=""></center>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The input contains several test cases. The first line of each test case contains a single integer n (1&lt;=n&lt;=1000), the number of vertices of the binary tree. Followed by two lines, respectively indicating the preorder sequence and
 inorder sequence. You can assume they are always correspond to a exclusive binary tree.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each test case print a single line specifying the corresponding postorder sequence.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">9
1 2 4 7 3 5 8 9 6
4 7 2 1 8 5 9 3 6</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">7 4 2 8 9 5 6 3 1</div></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size:18px">利用递归，从前序一个个元素开始，m=1； 在中序中找到in[i] ==&nbsp;pre[m], 然后将中序分为两部分，in[1.....i-1]&nbsp; 和in[i&#43;1.....n],然后分别遍历这两部分，直到这两部分元素为0(s&gt;t) 或1个（s==t）；</span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int m = 1;
int p = 1;
int pre[1003],in[1003],post[1003];

void Traverse(int s,int t)
{
    if(s&gt;t) return;//空，没有元素
    if(s==t){//一个元素
        m++;
        post[p++] = in[s];
    //    printf(&quot;%d &quot;,in[s]);
        return ;
    }
    int k,i;

    //printf(&quot;---------pre[%d]=%d\n&quot;,m,pre[m]);
    k = pre[m++];
    i= s;
    while(in[i++]!=k);
//    printf(&quot;i=%d\n&quot;,i);
    Traverse(s,i-2);
    Traverse(i,t);
    post[p++] = in[i-1];
//    printf(&quot;%d &quot;,in[i-1]);

}
/*
9
1 2 4 7 3 5 8 9 6
4 7 2 1 8 5 9 3 6
*/
int main()
{
    int n,i;

    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;pre[i]);
        for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;in[i]);
    //    for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,pre[i]);
    //    for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,in[i]);
        Traverse(1,n);
    //    printf(&quot;\n&quot;);
        for(i=1;i&lt;n;i++) printf(&quot;%d &quot;,post[i]);
        printf(&quot;%d\n&quot;,post[n]);//这里格式问题！！！
        m=1;   p=1;  //每组测试数据都要将m，p初始化！！！
    }
    return 0;
}</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-回溯法_N皇后问题_hud题目2553" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/31/回溯法_N皇后问题_hud题目2553/">回溯法 N皇后问题 hud题目2553</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<h1 align="center" style="color:#1a5cc8">N皇后问题</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 5563&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 2518<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">在N*N的方&#26684;棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。<br>
你的任务是，对于给定的N，求出有多少种合法的放置方法。<br>
<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">1
8
5
0</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">1
92
10</div></pre>
</div>
<p>&nbsp;</p>
<p><strong><span style="font-size:18px">思路：</span></strong></p>
<p><strong><span style="font-size:18px">给棋盘的行和列都编上1到N的号码，皇后也给编上1到N的号码。</span></strong></p>
<p><strong><span style="font-size:18px">由于一个皇后应在不同的行上，为不失一般性，可以假定第i个皇后将放在第i行上的某列。</span></strong></p>
<p><strong><span style="font-size:18px">因此N皇后问题的解空间可以用一个N元组（X1，X2，.....Xn）来表示，其中Xi是放置皇后i所在的列号。</span></strong></p>
<p><strong><span style="font-size:18px">这意味着所有的解都是N元组（1，2，3，.......，N）的置换。解空间大小为N！。</span></strong></p>
<p><strong><span style="font-size:18px">其次我们看<span style="color:#ff6600">约束条件</span>：因为解空间已经给我们排除了不在同一行（因为每个皇后分别已经对应不同的行号）的约束条件。</span></strong></p>
<p><strong><span style="font-size:18px">我们要判断的是不在同一列和不在同一斜线的约束。因为Xi表示皇后所在的列号，所以如果存在X（k）=X（i）那么肯定存在第k个皇后和第i个皇后同列。所以不同列的判段条件是X（k）！=X（i），1&lt;k&lt;i 。又因为同一斜线的特征是要么行号和列号之和不变（右高左低）要么是行号和列号只差相等（左高右低），所以同斜线的判断条件是 i&#43;X（i）=&nbsp; k&#43;X（k) 或 i-X(i) =k-X(k),两式合并得
<span style="color:#ff0000">|X(i)-X(k)|=|i-k|</span></span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>第一次递归代码：超时</p>
<pre class="cpp" name="code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;


int sum,x[11];

bool place(int k)
{
    //int i;
    //printf(&quot;k=%d\n&quot;,k);
    //for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,x[i]);
//    printf(&quot;\n&quot;);
    int j;
    for(j=1;j&lt;k;j++)
    {
        if(abs(j-k)==abs(x[j]-x[k]) || x[j]==x[k] ) return false; //在同一斜线或同一列    
    }
    return true;
}
void backtrack(int t,int n)
{
    int i;
//    printf(&quot;t=%d,n=%d\n&quot;,t,n);
//    for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,x[i]);
//    printf(&quot;\n&quot;);
    if(t&gt;n) {
        sum++;
    //    printf(&quot;sum=%d\n&quot;,sum);
    }
    else
    {
        for(i=1;i&lt;=n;i++)
        {
            x[t]=i;    
        //    printf(&quot;%d\n&quot;,place(t,x));
            if(place(t)) backtrack(t+1,n);
        }
    }
}

int main()
{
    int n,i;    
    while(scanf(&quot;%d&quot;,&amp;n),n)
    {    
        sum = 0;
        for(i=1;i&lt;=n;i++) x[i]=0;
        backtrack(1,n);
        printf(&quot;%d\n&quot;,sum);
    }
    return 0;
}     </pre>
<p><br>
第二次AC 简单打表，因为是N《= 10 ，因此用1中代码，将N等于1 to10都计算出来，放在一维数组</p>
<pre class="cpp" name="code">#include &lt;stdio.h&gt;
 
int main()
{
    int a[11]={0,1,0,0,2,10,4,40,92,352,724};
    int n,i;    
    while(scanf(&quot;%d&quot;,&amp;n),n)    
        printf(&quot;%d\n&quot;,a[n]);
    return 0;
} 
</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>AC代码：15MS&nbsp; 228KB</p>
<pre class="cpp" name="code">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;

int x[11],cnt[11],n,sum;
bool flag; 

void DFS(int k)//放置第k个皇后 
{
    int i,j,flag;
    if(k&gt;n) {//放置的皇后个数大于n时，表示一种解决方案 
        sum++; 
        return;    
    } 
      for(i=1;i&lt;=n;i++)//将第k个皇后依次放在第1 to n列 
     {
        flag = 1;
          x[k] = i;//列値1 to n
        for(j=1;j&lt;k;j++) //依次与前1到k-1个皇后比较 
        {
            if(x[k]==x[j]||abs(j-k)==abs(x[k]-x[j]))
            {//在同一列或在同一斜线 
                flag = 0; 
                break;    
            } 
        } 
        if(flag) DFS(k+1);//第k个皇后与前k-1个都比交完，互不冲突再放置第k+1个皇后 
       } 
}
 
int main()
{
    for(n=1;n&lt;11;n++)
    {
        sum =0;
        DFS(1);
        cnt[n] = sum;    
    }    
    while(scanf(&quot;%d&quot;,&amp;n),n)    
        printf(&quot;%d\n&quot;,cnt[n]);
    return 0;
} </pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目35_表达式求值_（栈的应用）前中后缀，" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/30/NYOJ_题目35_表达式求值_（栈的应用）前中后缀，/">NYOJ 题目35 表达式求值 （栈的应用）前中后缀，</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div class="problem-display">
<h4></h4>
<h2 style="text-align:center">
<div class="problem-display">
<div>
<div class="problem-display">
<h2 style="text-align:left">一。中缀表达式求&#20540;</h2>
<div><br>
</div>
<h2 style="text-align:center">表达式求&#20540;</h2>
<div class="problem-ins" style="text-align:left"><span style="font-size:12px">时间限制：<span id="problem[time_limit]" class="editable highlight">3000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB</span></div>
<div class="problem-ins" style="text-align:left"><span style="font-size:12px">难度：<span class="editable highlight">4</span></span></div>
</div>
<div class="clr"></div>
<dl class="problem-display"><dt style="text-align:left"><span style="font-size:12px">描述
</span></dt><dd>
<div style="text-align:left"><span style="font-size:12px">ACM队的mdd想做一个计算器，但是，他要做的不仅仅是一计算一个A&#43;B的计算器，他想实现随便输入一个表达式都能求出它的&#20540;的计算器，现在请你帮助他来实现这个计算器吧。</span></div>
<div style="text-align:left"><span style="font-size:12px">比如输入：“1&#43;2/4=”，程序就输出1.50（结果保留两位小数）</span></div>
<div class="clr"></div>
<dl class="others"><dt style="text-align:left"><span style="font-size:12px">输入</span></dt><dd>
<div style="text-align:left"><span style="font-size:12px">第一行输入一个整数n，共有n组测试数据（n&lt;10)。</span></div>
<div style="text-align:left"><span style="font-size:12px">每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式，每个运算式都是以“=”结束。这个表达式里只包含&#43;-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。</span></div>
<div style="text-align:left"><span style="font-size:12px">数据保证除数不会为0</span></div>
</dd><dt style="text-align:left"><span style="font-size:12px">输出</span></dt><dd style="text-align:left"><span style="font-size:12px">每组都输出该组运算式的运算结果，输出结果保留两位小数。</span></dd><dt style="text-align:left"><span style="font-size:12px">样例输入</span></dt><dd>
<pre id="sample_input"><div style="text-align:left"><span style="font-size:12px">2</span></div><div style="text-align:left"><span style="font-size:12px">1.000&#43;2/4=</span></div><div style="text-align:left"><span style="font-size:12px">((1&#43;2)*5&#43;1)/4=</span></div></pre>
</dd><dt style="text-align:left"><span style="font-size:12px">样例输出</span></dt><dd>
<pre id="sample_output"><div style="text-align:left"><span style="font-size:12px">1.50</span></div><div style="text-align:left"><span style="font-size:12px">4.00</span></div></pre>
</dd></dl>
</dd></dl>
<div style="text-align:left">此题为中缀表达式，也可以先转化成后缀表达式（逆波兰表达式）或前缀表达式（波兰表达式）求&#20540;；下面的例子会讲到</div>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">
<div>
<div><span style="color:#CC0000">o</span>算法分析：</div>
<div><span style="color:#0033CC"><span style="color:#CC0000">n</span></span><span style="color:#0033CC">扫描三遍：第一遍去括号；第二遍算乘除；第三遍算加减。</span></div>
<div><span style="color:#CC0000">o</span>数据结构：</div>
<div><span style="color:#0033CC"><span style="color:#CC0000">n</span></span><span style="color:#0033CC">用数组模拟栈；需要两个栈，一个是</span><span style="color:#0033CC">char&nbsp;</span><span style="color:#0033CC">型用来存储</span><span style="color:#0033CC">符</span><span style="color:#0033CC">号，另一个是</span><span style="color:#0033CC">double</span><span style="color:#0033CC">型用来存储数&#20540;。</span></div>
</div>
<br>
</div>
<div style="text-align:left">栈的应用：</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">1.提取数字，有可能是浮点数，可以使用sscanf函数，sscanf(str,&quot;%[^&#43;()*/-]&quot;,buf); &nbsp;先将操作数提取成字符串&nbsp;</div>
<div style="text-align:left">然后使用 double shu = &nbsp;atof（buf）；将字符串转换成double型；</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">2，操作符比较</div>
<div style="text-align:left">左括号入栈，遇到右括号，弹出栈顶运算符，计算，入栈，直到遇到左括号，弹栈</div>
<div style="text-align:left">栈定指针优先级大于当前操作符，则入栈，</div>
<div style="text-align:left">否则则出栈两个操作数，计算后然后入栈；</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">3，最后操作数栈定元素即为结果</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><pre name="code" class="cpp"> 
#define TRUE 1
#define FALSE 0
#define STACK_INIT_SIZE 10002

#include &quot;iostream&quot;
#include &quot;cstdlib&quot;
#include &quot;cstdio&quot;
#include &quot;cstring&quot;

using namespace std;

typedef int Status;		//Status 相当于 int
typedef struct Stack1	//运算符栈
{
	char * base;
	char * top;
}SqStack1;
typedef struct Stack2  //数字栈
{
	double * base;
	double * top;
}SqStack2;

//运算符栈操作
void  InitStack1(SqStack1 &amp;S)	//创建一个空栈
{

	S.base = (char *)malloc(sizeof(char) * STACK_INIT_SIZE);
	S.top = S.base;
}
Status Stack1Empty(SqStack1 S)//判断是否为空
{
	if(S.top == S.base)	return TRUE;
	else return FALSE;
}
void Push1(SqStack1 &amp;S,char e )//插入元素e为新的栈顶元素
{
	* S.top++ = e;
}
void Pop1(SqStack1 &amp;S,char &amp;e)//出栈
{
	e = * --S.top ;
}
char GetTop1(SqStack1 S)
{
	return *(S.top-1);
}
void TraverseStack1(SqStack1 S)//输出当前顺序表
{
	char * p = S.base;
	cout&lt;&lt;&quot;运算栈中的元素为：&quot;;
	while( p != S.top  )
	{
		cout&lt;&lt;*p&lt;&lt;&quot; &quot;;
		p++;
	}	
	cout&lt;&lt;endl;
}

//数字栈操作
void  InitStack2(SqStack2 &amp;S)	//创建一个空栈
{

	S.base = (double *)malloc(sizeof(double) * STACK_INIT_SIZE);
	S.top = S.base;
}
void Push2(SqStack2 &amp;S,double e )//插入元素e为新的栈顶元素
{
	* S.top++ = e;
}
void Pop2(SqStack2 &amp;S,double &amp;e)//出栈
{
	e = * --S.top ;
}
double GetTop2(SqStack2 S)
{
	return *(S.top-1);
}
void TraverseStack2(SqStack2 S)//输出当前顺序表
{
	double * p = S.base;
	cout&lt;&lt;&quot;数字栈栈中的元素为：&quot;;
	while( p != S.top  )
	{
		cout&lt;&lt;*p&lt;&lt;&quot; &quot;;
		p++;
	}	
	cout&lt;&lt;endl;
}

//运算操作
Status In(char ch)//判断ch是否为运算符
{
	if(ch == '+' || ch == '('|| ch == '-' || ch == '*' || ch == '/' || ch == ')'  || ch == '=') return TRUE;
	else return FALSE;
}
char Precede(char a, char b) // 计算运算符优先级
{
	char r;
	switch(b) 
	{
		case '+' :      //此处由于加减几乎优先级一样，故放在一起
		case '-' :
			if (a=='(' || a=='=') 		r = '&lt;';
			else 		r = '&gt;';
			break;
		case '*' :      //此处由于乘除优先级一样，故放在一起
		case '/' :
			if (a=='*' || a=='/' || a==')') 
			r = '&gt;';
			else 	r = '&lt;';
			break;
		case '(' :	r = '&lt;';
			break;
		case ')' :
			if (a=='(') 	r = '=';
			else 	r = '&gt;';
			break;
		case'=':
			if (a=='=') 	r = '=';
			else r = '&gt;';
			break;
	}
	return r;
}
double Operate(double a,char theta, double b)
{
	switch (theta)
	{
		case '+': return a + b;break;
		case '-': return a - b;break;
		case '*': return a * b;break;
		case '/': return a / b;break;
		default : return FALSE;
	}
}
double EvaluateExpression(char str[])
{
	char *p = str;
	SqStack1 OPTR;	SqStack2 OPND;//设OPTR和OPND分别为运算符栈和运算数栈
	InitStack1(OPTR); 	InitStack2(OPND);
	Push1(OPTR,'=');
	char x,theta,c;
	double a,b,k,t,m;
	c = *p;
	while( !Stack1Empty(OPTR))
	{
		if(!In(c) )
		{
			for(k = 0; !In(c) &amp;&amp; c!='.'&amp;&amp;c!='='; c = * ++p)
					k = 10*k + c-'0';
			t = 0 ;
			if(c=='.')
			{
				c = * ++p;
				for(t = 0,m = 0.1 ; !In(c) ; c = * ++p)
				{
					t += m * (c-'0');
					m *= 0.1;
				}
			}	
			Push2(OPND,k+t);
		}
		else
			switch(Precede(GetTop1(OPTR),c))
			{
				case '&lt;': 
					Push1(OPTR,c); 	
					c = * ++p;
					break;
				case '=': 
					Pop1(OPTR,x);  
					c = * ++p; 
					break;
				case '&gt;': 
					Pop1(OPTR,theta);
					Pop2(OPND,b); Pop2(OPND,a);
					Push2(OPND,Operate(a,theta,b));
					break;					
			}		
	}
	return GetTop2(OPND);
}
		
int main()
{
	int n;
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		char str[1002];
		scanf(&quot;%s&quot;,str);	
		printf(&quot;%.2lf\n&quot;,EvaluateExpression(str));	
	}
	return 0;
}        </pre>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
二。后缀表达式求&#20540;。</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">首先我们需要先将中缀表达式转化为后缀表达式，</div>
<div style="text-align:left">看下面这道题</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">
<div class="problem-display">
<h4></h4>
<h2 style="text-align:center">中缀式变后缀式</h2>
<div class="problem-ins"><span style="font-size:12px">时间限制：<span id="problem[time_limit]" class="editable highlight">1000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB</span></div>
<div class="problem-ins"><span style="font-size:12px">难度：<span class="editable highlight">3</span></span></div>
</div>
<div class="clr"></div>
<dl class="problem-display"><dt><span style="font-size:12px">描述 </span></dt><dd><span style="font-size:12px">人们的日常习惯是把算术表达式写成中缀式，但对于机器来说更“习惯于”后缀式，关于算术表达式的中缀式和后缀式的论述一般的数据结构书都有相关内容可供参看，这里不再赘述，现在你的任务是将中缀式变为后缀式。</span>
<div class="clr"></div>
<dl class="others"><dt><span style="font-size:12px">输入</span></dt><dd><span style="font-size:12px">第一行输入一个整数n，共有n组测试数据（n&lt;10)。<br>
每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式的中缀式，每个运算式都是以“=”结束。这个表达式里只包含&#43;-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数。<br>
数据保证除数不会为0</span></dd><dt><span style="font-size:12px">输出</span></dt><dd><span style="font-size:12px">每组都输出该组中缀式相应的后缀式，要求相邻的操作数操作符用空&#26684;隔开。</span></dd><dt><span style="font-size:12px">样例输入</span></dt><dd>
<pre id="sample_input"><span style="font-size:12px">2
1.000&#43;2/4=
((1&#43;2)*5&#43;1)/4=</span></pre>
</dd><dt><span style="font-size:12px">样例输出</span></dt><dd>
<pre id="sample_output"><span style="font-size:12px">1.000 2 4 / &#43; =
1 2 &#43; 5 * 1 &#43; 4 / =</span></pre>
</dd></dl>
</dd></dl>
<div style="text-align:left"><br>
</div>
规则：</div>
<div style="text-align:left"><span style="color:rgb(255,0,0); font-family:Arial; line-height:26px">中缀表达式a &#43; b*c &#43; (d * e &#43; f) * g，其转换成后缀表达式则为a b c * &#43; d e * f&nbsp;</span><wbr style="color:rgb(255,0,0); font-family:Arial; line-height:26px"><span style="color:rgb(255,0,0); font-family:Arial; line-height:26px">&nbsp;&#43;
 g * &#43;。</span></div>
<div style="text-align:left">
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<span style="font-size:18px; color:rgb(255,0,0)">转换过程需要用到栈，具体过程如下：</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<span style="font-size:18px; color:rgb(255,0,0)">1）如果遇到操作数，我们就直接将其输出。</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<span style="font-size:18px; color:rgb(255,0,0)">2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<span style="font-size:18px"><span style="color:rgb(255,0,0)">3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。<strong>注意，左括号只弹出并不输出。</strong></span></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<span style="font-size:18px"><span style="color:rgb(255,0,0)">4）如果遇到任何其他的操作符，如（“&#43;”， “*”，“（”）等，<strong>从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止</strong>。弹出完这些元素后，才将遇到的操作符压入到栈中。<strong>有一点需要注意，只有在遇到&quot; ) &quot;的情况下我们才弹出&quot; ( &quot;，其他情况我们都不会弹出&quot; ( &quot;。也就是说这种操作，&quot; &#43; &quot;的优先级最低，&quot; ( &quot;优先级最高。</strong></span></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<span style="font-size:18px; color:rgb(255,0,0)">5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<h3 style="margin:0px; padding:0px; font-family:Arial; line-height:26px"><a name="t2" style="color:rgb(202,0,0)"></a>2）实例</h3>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
规则很多，还是用实例比较容易说清楚整个过程。以上面的转换为例，输入为a &#43; b * c &#43; (d * e &#43; f)*g，处理过程如下：</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
1）首先读到a，直接输出。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
2）读到“&#43;”，将其放入到栈中。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
3）读到b，直接输出。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
此时栈和输出的情况如下：</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348146428_8057.png" style="border:medium none; max-width:100%"></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
4）读到“*”，因为栈顶元素&quot;&#43;&quot;优先级比&quot; * &quot; 低，所以将&quot; * &quot;直接压入栈中。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
5）读到c，直接输出。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
此时栈和输出情况如下：</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348146721_9861.png" style="border:medium none; max-width:100%"></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
6）读到&quot; &#43; &quot;，因为栈顶元素&quot; * &quot;的优先级比它高，所以弹出&quot; * &quot;并输出， 同理，栈中下一个元素&quot; &#43; &quot;优先级与读到的操作符&quot; &#43; &quot;一样，所以也要弹出并输出。然后再将读到的&quot; &#43; &quot;压入栈中。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
此时栈和输出情况如下：</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147044_5952.png" style="border:medium none; max-width:100%"></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
7）下一个读到的为&quot;(&quot;，它优先级最高，所以直接放入到栈中。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
8）读到d，将其直接输出。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
此时栈和输出情况如下：</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147265_9645.png" style="border:medium none; max-width:100%"></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
9）读到&quot; * &quot;，由于只有遇到&quot; ) &quot;的时候左括号&quot;(&quot;才会弹出，所以&quot; * &quot;直接压入栈中。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
10）读到e，直接输出。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
此时栈和输出情况如下：</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147424_4303.png" style="border:medium none; max-width:100%"></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
11）读到&quot; &#43; &quot;，弹出&quot; * &quot;并输出，然后将&quot;&#43;&quot;压入栈中。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
12）读到f，直接输出。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
此时栈和输出情况：</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr><img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147826_1174.png" style="border:medium none; max-width:100%"></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到&quot;(&quot;为止。这里右括号前只有一个操作符&quot;&#43;&quot;被弹出并输出。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147993_7462.png" style="border:medium none; max-width:100%"></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
14）读到&quot; * &quot;，压入栈中。读到g，直接输出。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348148087_4361.png" style="border:medium none; max-width:100%"></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
15）此时输入数据已经读到末尾，栈中还有两个操作符“*”和&quot; &#43; &quot;，直接弹出并输出。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348148276_3639.png" style="border:medium none; max-width:100%"></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
至此整个转换过程完成。程序实现代码后续再补充了。</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;<wbr></p>
<h3 style="margin:0px; padding:0px; font-family:Arial; line-height:26px"><a name="t3" style="color:rgb(202,0,0)"></a>&nbsp;<wbr>3）转换的另一种方法</h3>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
1)先按照运算符的优先级对中缀表达式加括号，变成( ( a&#43;(b*c) ) &#43; ( ((d*e)&#43;f) *g ) )</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
2)将运算符移到括号的后面，变成((a(bc)*)&#43;(((de)*f)&#43;g)*)&#43;</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
3)去掉括号，得到abc*&#43;de*f&#43;g*&#43;</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
&nbsp;</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px">
计算就好说了，根据后缀表达式，遇到运算符则弹出两个操作数，计算后压栈，最后栈顶元素为计算结果</p>
<br>
<pre name="code" class="cpp"> 
#define TRUE 1
#define FALSE 0
#define STACK_INIT_SIZE 10002

#include &quot;iostream&quot;
#include &quot;cstdlib&quot;
#include &quot;cstdio&quot;
#include &quot;cstring&quot;

using namespace std;

typedef int Status;		//Status 相当于 int
typedef struct Stack1	//运算符栈
{
	char * base;
	char * top;
}SqStack1;


//运算符栈操作
void  InitStack1(SqStack1 &amp;S)	//创建一个空栈
{

	S.base = (char *)malloc(sizeof(char) * STACK_INIT_SIZE);
	S.top = S.base;
}
Status Stack1Empty(SqStack1 S)//判断是否为空
{
	if(S.top == S.base)	return TRUE;
	else return FALSE;
}
void Push1(SqStack1 &amp;S,char e )//插入元素e为新的栈顶元素
{
	* S.top++ = e;
}
void Pop1(SqStack1 &amp;S,char &amp;e)//出栈
{
	e = * --S.top ;
}
char GetTop1(SqStack1 S)
{
	return *(S.top-1);
}
void TraverseStack1(SqStack1 S)//输出当前顺序表
{
	char * p = S.base;
	cout&lt;&lt;&quot;运算栈中的元素为：&quot;;
	while( p != S.top  )
	{
		cout&lt;&lt;*p&lt;&lt;&quot; &quot;;
		p++;
	}	
	cout&lt;&lt;endl;
}

Status In(char ch)//判断ch是否为运算符
{
	if(ch == '+' || ch == '('|| ch == '-' || ch == '*' || ch == '/' || ch == ')'  || ch == '=') return TRUE;
	else return FALSE;
}


void In_to_Ne(char s[1002], char p[1002],int &amp;l)	
{
	char c,ch;
	Stack1 S;   InitStack1(S);
	int i,k, len;
	k = 0; 
	len = strlen(s);
	for(i = 0; i&lt; len ; ++i)
	{
		c =s[i];
	//	printf(&quot;c = %c\n&quot;,c);
		if( !In(c) ) 
		{ 
			while(!In(c) ){  
              p[k++] = c;
			  c = s[++i];
            }  
			p[k++] = ' '; 
		}//操作数
		if( Stack1Empty(S) )	Push1(S,c); 
		else if( c == '(' )  Push1(S,c);
		else if(c == ')'  ) 
		{
			while( GetTop1(S)!= '(')
			{
				Pop1(S,ch);p[k++] = ch; p[k++] =' '; 
			}
			Pop1(S,ch); //将（出栈
		}	//将栈顶元素弹出并放到p	 
		else if( (c == '+' || c=='-' )&amp;&amp;(GetTop1(S)=='(' ) )   Push1(S,c);
		else if( (c == '+' || c=='-' )&amp;&amp;(GetTop1(S) =='+' ||GetTop1(S)=='-'||GetTop1(S)=='*' ||GetTop1(S)=='/' ) ) {  Pop1(S,ch);  p[k++] = ch; p[k++] =' ';  i = i-1;  }	//将栈顶元素弹出并放到p
		else if( (c == '*' || c=='/' )&amp;&amp;(GetTop1(S) =='+' ||GetTop1(S)=='-'|| GetTop1(S)=='(' ) )   Push1(S,c);
		else if( (c == '*' || c=='/' )&amp;&amp;(GetTop1(S) =='*' ||GetTop1(S)=='/') )   {  Pop1(S,ch);  p[k++] = ch; p[k++] =' '; i = i-1;  }	//将栈顶元素弹出并放到p
	//	TraverseStack1(S);
	}

	while(!Stack1Empty(S) )
	{
		Pop1(S,ch);  p[k++] = ch; p[k++] =' ';
	}
	l = k;
	return ;
}
/*
2
1.000+2/4=
((1+2)*5+1)/4=
*/
int main()
{
	char s[1002], p[1002];
	int n,i,len;
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		scanf(&quot;%s&quot;,s);
		In_to_Ne( s, p,len);
		for(i =0; i&lt;len; ++i)
			printf(&quot;%c&quot;,p[i]);
		printf(&quot;=\n&quot;);
	}
	return 0;
}           </pre><br>
<br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">然后看后缀表达式求&#20540;：从左向右依次读取，遇到操作数入栈，操作符则出栈两个元素结果入栈，直到读完，输出站定元素&#20540;，这里很简单</div>
<div style="text-align:left">
<div>
<h2>郁闷的C小加（二）</h2>
<div><span style="font-size:12px">时间限制：<span id="problem[time_limit]">1000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]">65535</span> KB</span></div>
<div><span style="font-size:12px">难度：4</span></div>
</div>
<dl><dt><span style="font-size:12px">描述 </span></dt><dd>
<p><span style="font-size:12px">聪明的你帮助C小加解决了中缀表达式到后缀表达式的转换（详情请参考“郁闷的C小加（一）”），C小加很高兴。但C小加是个爱思考的人，他又想通过这种方法计算一个表达式的&#20540;。即先把表达式转换为后缀表达式，再求&#20540;。这时又要考虑操作数是小数和多位数的情况。</span></p>
<dl><dt><span style="font-size:12px">输入</span></dt><dd><span style="font-size:12px">第一行输入一个整数T，共有T组测试数据（T&lt;10)。<br>
每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式，每个运算式都是以“=”结束。这个表达式里只包含&#43;-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数并且小于1000000。<br>
数据保证除数不会为0。<br>
</span></dd><dt><span style="font-size:12px">输出</span></dt><dd><span style="font-size:12px">对于每组测试数据输出结果包括两行，先输出转换后的后缀表达式，再输出计算结果，结果保留两位小数。两组测试数据之间用一个空行隔开。</span></dd><dt><span style="font-size:12px">样例输入</span></dt><dd>
<pre id="sample_input"><span style="font-size:12px">21&#43;2=(19&#43;21)*3-4/5=</span></pre>
</dd><dt><span style="font-size:12px">样例输出</span></dt><dd>
<pre id="sample_output"><span style="font-size:12px">12&#43;=3.001921&#43;3*45/-=119.20</span></pre>
</dd></dl>
</dd></dl>
<pre name="code" class="cpp"> 
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;stack&gt;

using namespace std;
 

int In(char e)
{
	if(e=='(' || e==')' || e=='+' || e=='-' || e=='*' || e=='/') return 1;
	else return 0;
}
int cmp(char c)
{
	switch(c)
	{
		case '+':
		case '-': return 1;
		case '*':
		case '/': return 2;
		default : return 0;	
	}	
}
double calculate(char op,double k1,double k2)
{
	double k;
	switch (op)
	{
		case '+': k = k1+k2; break;
		case '-': k = k1-k2; break;
		case '*': k = k1*k2; break;
		case '/': k = k1/k2; break;
	}
	return k;
}

/*
20
(2.6)-(1.666)=
1+2=
(19+21)*3-4/5=

*/

void change(char str[])
{
	int t,i,k,m;
	char e,buf[1002],op,s[1002];
	double kk,k1,k2;
	stack &lt;char&gt; S1;
	stack &lt;double&gt; S2;
	k=0;
	S1.push('=');
	for(i=0;i&lt;strlen(str)-1;++i) //最后一位是 = 
	{
			if( In(str[i])  )
			{				
				switch(str[i])
				{
					case '(': S1.push(str[i]); break;
					case ')': //遇到右括号， 
						while(S1.top()!='(')//弹出栈元素输出 直到 （，
						{
							s[k++]=S1.top();
							k1 = S2.top(); S2.pop();
							k2 = S2.top(); S2.pop();
							S2.push(calculate(S1.top(),k2,k1));
							S1.pop();	
						}
						if(S1.top()=='(')//弹出（不输出
						{
							S1.pop();	
						} 

						break;
					default :
						while(cmp(str[i])&lt;=cmp(S1.top()))
						{
							s[k++]=S1.top();
							k1 = S2.top(); S2.pop();
							k2 = S2.top(); S2.pop();
							S2.push(calculate(S1.top(),k2,k1));
							S1.pop();	
						}
						S1.push(str[i]);
						break;
				}//switch
			}//if
			else{

				sscanf(str+i,&quot;%[^=()+*/-]&quot;,buf); //操作数 
				for(m=0;m&lt;strlen(buf);m++) s[k++]=buf[m];
				//printf(&quot;%s&quot;,buf);
				i += strlen(buf)-1;
				kk = atof(buf);
				//printf(&quot;k = %lf\n&quot;,k);
				S2.push(kk);

			}

			
		}//for
		while(!S1.empty())
		{
			if(S1.top()!='(' &amp;&amp; S1.top()!='=')
			{
				s[k++]=S1.top();
				k1 = S2.top(); S2.pop();
				k2 = S2.top(); S2.pop();
				S2.push(calculate(S1.top(),k2,k1));
			}
				
			S1.pop();
		}

		for(i=0;i&lt;k;i++) printf(&quot;%c&quot;,s[i]);
		printf(&quot;=\n&quot;);
		printf(&quot;%.2lf\n&quot;,S2.top());		
} 
int main()
{
	int t,i;
	char e,str[1002],buf[1002],op;
	double k,k1,k2;
		
	scanf(&quot;%d&quot;,&amp;t); getchar();
	while(t--)
	{
		
		gets(str); 
		//puts(str);
		change(str);
		
		if(t&gt;0) printf(&quot;\n&quot;);
	}

	return 0;
}        </pre><br>
<br>
</div>
<div style="text-align:left">三。前缀表达式（波兰表达式）</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">
<div id="pageTitle" style="margin:0px 0px 20px 14px; padding:0px 0px 9px; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(102,102,102); width:932px; color:rgb(35,31,23); font-family:'Lucida Grande',Verdana,'Bitstream Vera Sans',Arial,sans-serif; font-size:14px; line-height:21px; background-color:rgb(204,232,207)">
<h2 style="margin:0px; padding:0px; font-size:18px; line-height:1.1em">2694:逆波兰表达式</h2>
</div>
<div id="topMenu" style="margin:0px; padding:0px; position:absolute; top:27px; right:0px; color:rgb(35,31,23); font-family:'Lucida Grande',Verdana,'Bitstream Vera Sans',Arial,sans-serif; font-size:14px; line-height:21px; background-color:rgb(204,232,207)">
<ul style="margin:0px; padding:0px">
<li style="margin:0px; padding:0px; list-style:none; display:inline"><a href="http://poj.grids.cn/practice/2694/submit/" style="text-decoration:none; color:rgb(119,119,119); outline:none; background:inherit; display:block; font-size:13px; float:left; height:24px; line-height:22px; margin:8px 8px 0px 0px; padding:0px 15px" target="_blank" rel="external">Submit</a></li><li style="margin:0px; padding:0px; list-style:none; display:inline"><a href="http://poj.grids.cn/practice/2694/statistics/" style="text-decoration:none; color:rgb(119,119,119); outline:none; background:inherit; display:block; font-size:13px; float:left; height:24px; line-height:22px; margin:8px 8px 0px 0px; padding:0px 15px" target="_blank" rel="external">Statistics</a></li><li style="margin:0px; padding:0px; list-style:none; display:inline"><a href="http://poj.grids.cn/practice/hint/2694/" style="text-decoration:none; color:rgb(119,119,119); outline:none; background:inherit; display:block; font-size:13px; float:left; height:24px; line-height:22px; margin:8px 8px 0px 0px; padding:0px 15px" target="_blank" rel="external">Hint</a></li><li style="margin:0px; padding:0px; list-style:none; display:inline"><a href="http://poj.grids.cn/practice/clarify/2694/" style="text-decoration:none; color:rgb(119,119,119); outline:none; background:inherit; display:block; font-size:13px; float:left; height:24px; line-height:22px; margin:8px 8px 0px 0px; padding:0px 15px" target="_blank" rel="external">Clarify</a></li></ul>
</div>
<div class="problem-page col-9" style="margin:0px 14px; padding:0px; float:left; display:inline; width:670px; color:rgb(35,31,23); font-family:'Lucida Grande',Verdana,'Bitstream Vera Sans',Arial,sans-serif; font-size:14px; line-height:21px; background-color:rgb(204,232,207)">
<dl class="problem-params" style="margin:0px; padding:0px"><dt style="margin:0px; padding:0px; display:inline">
总Time Limit:&nbsp;</dt><dd style="margin:0px 15px 0px 0px; padding:0px; display:inline">1000ms&nbsp;</dd><dt style="margin:0px; padding:0px; display:inline">Memory Limit:&nbsp;</dt><dd style="margin:0px 15px 0px 0px; padding:0px; display:inline">65536kB</dd></dl>
<dl class="problem-content" style="margin:0px; padding:0px"><dt style="margin:0px; padding:0px; font-size:16px; font-weight:bold; line-height:56px">
Description</dt><dd style="margin:0px; padding:0px">逆波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 &#43; 3的逆波兰表示法为&#43; 2 3。逆波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 &#43; 3) * 4的逆波兰表示法为* &#43; 2 3 4。本题求解逆波兰表达式的&#20540;，其中运算符包括&#43; - * /四个。</dd><dt style="margin:0px; padding:0px; font-size:16px; font-weight:bold; line-height:56px">
Input</dt><dd style="margin:0px; padding:0px">输入为一行，其中运算符和运算数之间都用空&#26684;分隔，运算数是浮点数。</dd><dt style="margin:0px; padding:0px; font-size:16px; font-weight:bold; line-height:56px">
Output</dt><dd style="margin:0px; padding:0px">输出为一行，表达式的&#20540;。<br>
可直接用printf(&quot;%f\n&quot;, v)输出表达式的&#20540;v。</dd><dt style="margin:0px; padding:0px; font-size:16px; font-weight:bold; line-height:56px">
Sample Input</dt><dd style="margin:0px; padding:0px">
<pre style="margin-top:0px; margin-bottom:0px; padding:11px; background-color:rgb(245,245,245); border:1px solid rgb(218,218,218); line-height:1.3em; overflow:auto; font-family:'Courier New'">* &#43; 11.0 12.0 &#43; 24.0 35.0</pre>
</dd><dt style="margin:0px; padding:0px; font-size:16px; font-weight:bold; line-height:56px">
Sample Output</dt><dd style="margin:0px; padding:0px">
<pre style="margin-top:0px; margin-bottom:0px; padding:11px; background-color:rgb(245,245,245); border:1px solid rgb(218,218,218); line-height:1.3em; overflow:auto; font-family:'Courier New'">1357.000000</pre>
</dd><dt style="margin:0px; padding:0px; font-size:16px; font-weight:bold; line-height:56px">
Hint</dt><dd style="margin:0px; padding:0px">可使用atof(str)把字符串转换为一个double类型的浮点数。atof定义在math.h中。<br>
此题可使用函数递归调用的方法求解。</dd></dl>
</div>
<br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">求&#20540;方法</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left"><span style="color:#ff0000"><span style="font-family:arial,宋体,sans-serif; font-size:14px; line-height:24px">对于一个前缀表达式的求&#20540;而言，首先要从右至左扫描表达式，从右边第一个字符开始判断，如果当前字符是数字则一直到数字串的末尾再记录下来，如果是</span><a target="_blank" href="http://baike.baidu.com/view/425996.htm" style="text-decoration:none; font-family:arial,宋体,sans-serif; font-size:14px; line-height:24px; text-indent:30px">运算符</a><span style="font-family:arial,宋体,sans-serif; font-size:14px; line-height:24px; text-indent:30px">，则将右边离得最近的两个“数字串”作相应的运算，以此作为一个新的“数字串”并记录下来。一直扫描到表达式的最左端时，最后运算的&#20540;也就是表达式的&#20540;。例如，前缀表达式“-
 1 &#43; 2 3“的求&#20540;，扫描到3时，记录下这个数字串，扫描到2时，记录下这个数字串，当扫描到&#43;时，将&#43;右移做相邻两数字串的</span><a target="_blank" href="http://baike.baidu.com/view/425996.htm" style="text-decoration:none; font-family:arial,宋体,sans-serif; font-size:14px; line-height:24px; text-indent:30px">运算符</a><span style="font-family:arial,宋体,sans-serif; font-size:14px; line-height:24px; text-indent:30px">，记为2&#43;3，结果为5，记录下这个新数字串，并继续向左扫描，扫描到1时，记录下这个数字串，扫描到-时，将-右移做相邻两数字串的运算符，记为1-5，结果为-4，所以表达式的&#20540;为-4。</span></span><br>
</div>
<div style="text-align:left"><br>
</div>
<div style="text-align:left">原始代码：</div>
<div style="text-align:left"><pre name="code" class="cpp">#include &lt;stack&gt;
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;
void fan(char s[])
{
	char buf[10001];
	int i,j=0;
	for(i=strlen(s)-1;i&gt;=0;i--)
		buf[j++]=s[i];
	buf[j]='\0';
	for(i=0;i&lt;strlen(s);i++)
		s[i]=buf[i];
}
stack &lt;double&gt; s1;
bool In(char c)
{
	if(c=='-' || c=='+' || c=='*' || c=='/') return true;
	return false;
}

double calc(double k2,double k1, char op)
{
	switch( op )
	{
		case '+': return k2+k1; 
		case '-': return k2-k1;
		case '*': return k2*k1;
		case '/': return k2/k1;	
	}
}
double solve(char s[])
{
	char buf[10001],op;
	double k1,k2;
	int i,num_shu=0;
//	printf(&quot;%s\n&quot;,s);
	for(i=strlen(s)-1;i&gt;=0;i--)
	{
	//	printf(&quot;c=%c\n&quot;,s[i]);
		if(s[i]==' ') continue;
		if(In( s[i]) ){
			k1=s1.top(); s1.pop();
			k2=s1.top(); s1.pop();
		//	printf(&quot;k1=%f k2=%f,calc=%f\n&quot;,k1,k2,calc(k2,k1,op));
			s1.push(calc(k1,k2,s[i]));
		}	//caozuofu	
		else //caozuoshu
		{
			int j=0;
			memset(buf,0,sizeof(buf));
			while(s[i]!=' ') {buf[j]=s[i]; j++;i--;}
			//strrev(buf);
			fan(buf);
		//	printf(&quot;buf=%s\n&quot;,buf);
			k1 = atof(buf);
		//	i+= strlen(buf)-1;
		//	printf(&quot;shu=%lf\n&quot;,k1);
			
			s1.push(k1);
		//	cin&gt;&gt;i;	
		}
	}
//	while(!s2.empty())
//	{
//		k1=s1.top(); s1.pop();
//		k2=s1.top(); s1.pop();
//		op = s2.top(); s2.pop();
//	//	printf(&quot;k1=%f k2=%f,calc=%f\n&quot;,k1,k2,calc(k2,k1,op));
//		s1.push(calc(k2,k1,op)); 
//		num_shu = 1;
//	}
	return s1.top();
}
//     * + 11.0 12.0 + 24.0 35.0
int main()
{
	char s[10001];
	gets(s);
	printf(&quot;%f\n&quot;,solve(s));
	return 0;
}</pre><br>
简单代码：<pre name="code" class="cpp">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
using namespace std;
double recur()
{
    char s1[10];
    scanf(&quot;%s&quot;,s1);
    switch(s1[0])
    {
        case '+':
        return recur()+recur();
        case '-':
        return recur()-recur();
        case '*':
        return recur()*recur();
        case '/':
        return recur()/recur();
        default : return atof(s1);
    }
    return 0;
}
int main()
{
    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    double res=0;
    res=recur();
    printf(&quot;%lf\n&quot;,res);
    return 0;
}</pre><br>
</div>
<div><br>
</div>
</div>
</h2>
</div>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-POJ_题目1250_Tanning_Salon_（链表应用）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/30/POJ_题目1250_Tanning_Salon_（链表应用）/">POJ 题目1250 Tanning Salon （链表应用）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p><br>
</p>
<p></p>
<div class="ptt" lang="en-US" style="text-align:center; font-size:18pt; font-weight:bold; color:blue; background-color:rgb(204,232,207)">
Tanning Salon</div>
<div class="plm" style="text-align:center; font-size:14px; background-color:rgb(204,232,207)">
<table align="center">
<tbody>
<tr>
<td><strong>Time Limit:</strong>&nbsp;1000MS</td>
<td width="10px">&nbsp;</td>
<td><strong>Memory Limit:</strong>&nbsp;10000K</td>
</tr>
<tr>
<td><strong>Total Submissions:</strong>&nbsp;6820</td>
<td width="10px">&nbsp;</td>
<td><strong>Accepted:</strong>&nbsp;3686</td>
</tr>
</tbody>
</table>
</div>
<p></p>
<p class="pst" style="font-size:18pt; font-weight:bold; color:blue; background-color:rgb(204,232,207)">
Description</p>
<div class="ptx" lang="en-US" style="font-family:'Times New Roman',Times,serif; font-size:14px; background-color:rgb(204,232,207)">
Tan Your Hide, Inc., owns several coin-operated tanning salons. Research has shown that if a customer arrives and there are no beds available, the customer will turn around and leave, thus costing the company a sale. Your task is to write a program that tells
 the company how many customers left without tanning.&nbsp;<br>
</div>
<p class="pst" style="font-size:18pt; font-weight:bold; color:blue; background-color:rgb(204,232,207)">
Input</p>
<div class="ptx" lang="en-US" style="font-family:'Times New Roman',Times,serif; font-size:14px; background-color:rgb(204,232,207)">
The input consists of data for one or more salons, followed by a line containing the number 0 that signals the end of the input. Data for each salon is a single line containing a positive integer, representing the number of tanning beds in the salon, followed
 by a space, followed by a sequence of uppercase letters. Letters in the sequence occur in pairs. The first occurrence indicates the arrival of a customer, the second indicates the departure of that same customer. No letter will occur in more than one pair.
 Customers who leave without tanning always depart before customers who are currently tanning. There are at most 20 beds per salon.&nbsp;<br>
</div>
<p class="pst" style="font-size:18pt; font-weight:bold; color:blue; background-color:rgb(204,232,207)">
Output</p>
<div class="ptx" lang="en-US" style="font-family:'Times New Roman',Times,serif; font-size:14px; background-color:rgb(204,232,207)">
For each salon, output a sentence telling how many customers, if any, walked away. Use the exact format shown below.&nbsp;<br>
</div>
<p class="pst" style="font-size:18pt; font-weight:bold; color:blue; background-color:rgb(204,232,207)">
Sample Input</p>
<pre class="sio" style="font-family:'Courier New',Courier,monospace; font-size:14px; background-color:rgb(204,232,207)">2 ABBAJJKZKZ
3 GACCBDDBAGEE
3 GACCBGDDBAEE
1 ABCBCA
0</pre>
<p class="pst" style="font-size:18pt; font-weight:bold; color:blue; background-color:rgb(204,232,207)">
Sample Output</p>
<pre class="sio" style="font-family:'Courier New',Courier,monospace; font-size:14px; background-color:rgb(204,232,207)">All customers tanned successfully.
1 customer(s) walked away.
All customers tanned successfully.
2 customer(s) walked away.</pre>
<br>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><strong><span style="font-size:18px"><br>
</span></strong></p>
<p><strong><span style="font-size:18px"><br>
</span></strong></p>
<p><strong><span style="font-size:18px">建立两个链表L,W， &nbsp;L用来存放当前bed状态，W用来存放当前wait等待人数，</span></strong></p>
<p><strong><span style="font-size:18px">每当新到达一个新的客户，</span></strong></p>
<p><strong><span style="font-size:18px">首先判断新客户是否已在L中，</span><span style="font-size:18px">如果在L中，将其从L删除，</span></strong></p>
<p><strong><span style="font-size:18px">如果不在L，再判断元素个数是否大于n，</span></strong></p>
<p><strong><span style="font-size:18px">如果L中元素个数小于n，则将新客户添加到L，</span></strong></p>
<p><span style="font-size:18px"><strong>否则，判断新客户是否在W中，如果不在，则cnt&#43;&#43;（等待人数&#43;&#43;）；如果在w中，则从w删除</strong></span></p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><pre name="code" class="cpp">#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef struct node
{
	char elem;
	node * next;
}node;
typedef struct list
{
	node * head;
}list;
	
void Print(list L)
{
	node *p=L.head;
	while(p)
	{
		printf(&quot;%c&quot;,p-&gt;elem);
		p=p-&gt;next;
	}
//	printf(&quot;-----------\n&quot;);
}
int length(list L)
{
	node * p = L.head;
	int len = 0;
	while(p)
	{
		len++;
		p = p-&gt;next;
	} 
	return len;
	
}
void insert(list &amp;L, char e)
{
	node * p;
	p = (node *)malloc(sizeof(node));
	p-&gt;elem = e;	
	p-&gt;next = L.head;
	L.head = p;	
	//Print(L);
}
void delet(list &amp;L, char e)
{
	node * c;
//	Print(L);
	node * p = L.head;
	node * s=p;
	if(p-&gt;elem ==e)
	{
		L.head = p-&gt;next;
	}
	else
	{
		while( p-&gt;elem != e)
		{
			s = p;
			p = p-&gt;next;
		} 
		s-&gt;next = p-&gt;next;
	}
	
	free(p);
	
}
bool find(list L, char e)
{
	node * p = L.head; 
	while(p)
	{
		if( p-&gt;elem==e) 	return true;
		p=p-&gt;next;
	}
//	printf(&quot;meiyou\n&quot;);
	return false;
}

void init(list &amp;L)
{
	L.head = (node *)malloc(sizeof(node));
	if(!L.head) exit(-1);
	L.head=NULL;
}

int main()
{
	int n,i;
	char s[1000];
	list L;
	list W;
	init(L); init(W);
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		scanf(&quot;%s&quot;,s);
	//	puts(s);
	//	printf(&quot;n=%d\n&quot;,n);
//   3 GACCBDDBAGEE
	
	//	printf(&quot;l=%c,len=%d\n&quot;,s[0],strlen(s));

	//	Print(L);
		int cnt = 0;

		for(i=0;i&lt;strlen(s);i++)
		{
		//	printf(&quot;i=%c,len=%d\n&quot;,s[i],length(L));
			if(!find(L,s[i]))//对L来说新来客户
			{
				if(length(L)&lt;n ){
					insert(L,s[i]);
			//		Print(L);
				 }
				else
				{	
				//	printf(&quot;###\n&quot;);
				//	Print(W);

					if(!find(W,s[i]))	
					{
						
						insert(W,s[i]);
						cnt ++;
					}
					else delet(W,s[i]);
				} 
				//Print(L);
			}
			else delet(L,s[i]);
			
		}
		if(cnt==0) printf(&quot;All customers tanned successfully.\n&quot;);
		else printf(&quot;%d customer(s) walked away.\n&quot;,cnt);
		
	}
	return 0;
}</pre><br>
<br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-链表——约瑟夫问题_百练2746" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/30/链表——约瑟夫问题_百练2746/">链表——约瑟夫问题 百练2746</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p><a href="http://poj.grids.cn/practice/2746" target="_blank">约瑟夫问题</a></p>
<p><br>
</p>
<p>建立循环链表，一次删除符合结点，最后剩下一个即为所求结点</p>
<p><pre name="code" class="cpp">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

struct node 
{
	int num;
	node * next;
};

void initqueen(int n,node * queen)
{
	int i;
	node * r,*s;
	r=s=queen;

	for(i=2;i&lt;=n;i++)//2到n结点
	{
		
		s = (node *)malloc(sizeof(node));
		s-&gt;num = i;
		s-&gt;next = NULL;
		r-&gt;next = s;
		r = s;
	}
//	printf(&quot;r=%d\n&quot;,r-&gt;num);
	r-&gt;next = queen;//最后一个结点指向头结点，形成循环队列
}
int solve(int n,int m,node * queen)
{
	int i,j;
	node * s;
	node *p = queen;
//	printf(&quot;q = %d\n&quot;,queen-&gt;num);

	s = p;
	for(i=1;i&lt;n;i++)
	{
		
	//	printf(&quot;p=%d\n&quot;,p-&gt;num);
		for(j=1;j&lt;m;j++)
		{
			
			s = p;
			p=p-&gt;next;
		//	s = p;
		}
	//	printf(&quot;*p=%d\n&quot;,p-&gt;num);
		s-&gt;next = p-&gt;next;
		free(p);
		p = s-&gt;next;
	}
	return p-&gt;num;
}
int main()
{
 	int m,n;
	node * queen;
 	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m),m&amp;&amp;n)
 	{ 
	//	printf(&quot;n=%d,m=%d\n&quot;,n,m);
		
	 	if(n==1) {
			printf(&quot;1\n&quot;);	continue;
	 	}
		if(m==1){
			printf(&quot;%d\n&quot;,n); continue;
		}
		queen = (node *)malloc(sizeof(node)); //第一个结点
		queen-&gt;num = 1;
		queen-&gt;next = NULL;;
		 initqueen(n,queen);
		 printf(&quot;%d\n&quot;,solve(n,m,queen));					   								
	}
 	return 0;
}</pre><br>
<br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-最短路径_Dijksstra算法求最短路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/29/最短路径_Dijksstra算法求最短路/">最短路径 Dijksstra算法求最短路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<span style="font-family:宋体; font-size:14px"></span>
<div>
<div><span style="font-size:18px"><span style="color:#000099">1.</span><span style="color:#000099"><strong>两地之间是否有通路?</strong></span></span></div>
<div><span style="font-size:18px"><span style="color:#000099">2.</span><span style="color:#000099"><strong>若存在多条通路，哪条路最短？</strong></span></span></div>
</div>
<p><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<span style="font-family:宋体"></span>
<div>
<div><span style="font-size:18px"><span style="color:#000099"><span style="color:#0033cc">●</span></span><span style="color:#000099"><strong>单源最短路径</strong></span></span></div>
<div><span style="font-size:18px"><span style="color:#000099"><strong>&nbsp;&nbsp; </strong>
</span>Single-Source Shortest Path</span></div>
<div><span style="font-size:18px"><span style="color:#000099"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</strong></span>(Dijkstra<span style="color:#000099"><strong>算法</strong></span><span style="color:#000099"><strong>)</strong></span></span></div>
<div><span style="font-size:18px"><span style="color:blue"><strong>&nbsp;&nbsp; </strong></span><span style="color:blue"><strong>负权边的有向图单源最短有路径</strong></span></span></div>
<div><span style="font-size:18px">&nbsp;&nbsp;&nbsp; Bellman<strong>-</strong>Ford<strong>算法</strong></span></div>
</div>
<p><span style="font-size:18px">&nbsp;</span></p>
<div>
<div><span style="font-size:18px"><span style="color:#000099"><span style="color:#0033cc">●</span></span><span style="color:#000099"><strong>所有顶点对间的最短路径问题</strong></span></span></div>
<div><span style="font-size:18px"><span style="color:#000099"><strong>&nbsp;&nbsp; </strong>
</span>All-Pairs Shortest paths&nbsp;<span style="color:#000099"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></span><span style="color:#000099"><strong>（</strong></span><span style="color:#000099"><strong>Floyd</strong></span></span><span style="font-size:18px; color:#000099"><strong>算法）<br>
</strong></span></div>
</div>
<div>
<div><span style="font-size:18px"><span style="color:#0033cc">●</span><strong>问题: 带权有向图G（E,V), 找出从给定</strong><span style="color:#cc0000"><strong>源顶点</strong></span><span style="color:#cc0000"><strong><em>s</em></strong></span><strong>到</strong><span style="color:#cc0000"><strong>其它顶点</strong></span><span style="color:#cc0000"><strong><em>v</em></strong></span><strong>的权最小路径。</strong></span></div>
<div><span style="font-size:18px"><span style="color:#0033cc">●</span><strong>“最短路径” = 最小权
</strong></span></div>
<div><span style="font-size:18px"></span></div>
</div>
<p><span style="font-size:18px">&nbsp;</span></p>
<p><span style="font-family:宋体; font-size:14px">&nbsp;在日常生活中，我们如果需要常常往返A地区和B地区之间，我们最希望知道的可能是从A地区到B地区间的众多路径中，那一条路径的路途最短。最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。</span><span style="font-family:宋体; font-size:14px">确定起点的最短路径问题：即已知起始结点，求最短路径的问题。</span></p>
<p><span style="font-family:宋体; font-size:14px">&nbsp;Dijkstra算法</span></p>
<p><span style="font-family:宋体; font-size:14px">　　Dijkstra算法是典型最短路算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。</span></p>
<p>如下图：</p>
<p><span style="font-size:18px">&nbsp;</span></p>
<div>
<div><span style="font-size:18px"><span style="color:#0033cc">●</span><strong>贪心算法：
</strong></span></div>
<div><strong><span style="font-size:18px">&nbsp; 基于以下原理：若顶点序列{Vs,V1,…,Vn} 是从Vs到Vn的最短路，则序列 {Vs,V1,…,Vn-1} 必为从Vs到Vn-1的最短路。</span></strong></div>
<div><span style="font-size:18px"><span style="color:#0033cc">●</span><strong>基本思想：
</strong></span></div>
<div><strong><span style="font-size:18px">&nbsp;&nbsp; 设置一个顶点集S，不断做贪心选择扩充这个集合。 </span></strong></div>
<div><strong><span style="font-size:18px">&nbsp; 一个顶点属于S当且仅当从源到该顶点最短路径长度已知。 </span></strong></div>
<div><strong></strong>&nbsp;</div>
<div><strong></strong>&nbsp;</div>
<div><img alt="" src="http://img.blog.csdn.net/20130729191755265"></div>
<div>
<div>
<div><span style="font-size:18px"><span style="color:#000099"><span style="color:#0033cc">●</span></span><span style="color:#000099"><strong>图中从</strong></span><span style="color:#000099"><strong>v</strong></span><span style="color:#000099"><strong>0</strong></span><span style="color:#000099"><strong>到其余各顶点之间的最短路径</strong></span><span style="color:#000099"><strong>:</strong></span></span></div>
<div><span style="font-size:18px"><span style="color:#000099"><strong>v</strong></span><span style="color:#000099"><strong>0</strong></span><span style="color:#000099"><strong>到</strong></span><span style="color:#000099"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>v<span style="color:#000099"><strong>1&nbsp;&nbsp;&nbsp;</strong></span><span style="color:#000099"><strong>无</strong></span><span style="color:#000099"><strong>&nbsp;</strong></span></span></div>
<div><span style="font-size:18px"><span style="color:#000099"><strong>v</strong></span><span style="color:#000099"><strong>0</strong></span><span style="color:#000099"><strong>到</strong></span><span style="color:#000099"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>v<span style="color:#000099"><strong>2&nbsp;&nbsp;&nbsp;</strong></span><span style="color:#000099"><strong>(v</strong></span><span style="color:#000099"><strong>0</strong></span><span style="color:#000099"><strong>,v</strong></span><span style="color:#000099"><strong>2</strong></span><span style="color:#000099"><strong>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>10</span></div>
<div><span style="font-size:18px"><span style="color:#000099"><strong>&nbsp;</strong></span>v<span style="color:#000099"><strong>0</strong></span><span style="color:#000099"><strong>到</strong></span><span style="color:#000099"><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>v<span style="color:#000099"><strong>3&nbsp;&nbsp;&nbsp;</strong></span><span style="color:#000099"><strong>(v</strong></span><span style="color:#000099"><strong>0</strong></span><span style="color:#000099"><strong>,v</strong></span><span style="color:#000099"><strong>4</strong></span><span style="color:#000099"><strong>,</strong></span><span style="color:#000099"><strong>v</strong></span><span style="color:#000099"><strong>3</strong></span><span style="color:#000099"><strong>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>50</span></div>
<div><span style="font-size:18px"><span style="color:#000099"><strong>&nbsp;</strong></span>v<span style="color:#000099"><strong>0</strong></span><span style="color:#000099"><strong>到</strong></span><span style="color:#000099"><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>v<span style="color:#000099"><strong>4&nbsp;&nbsp;&nbsp;</strong></span><span style="color:#000099"><strong>(v</strong></span><span style="color:#000099"><strong>0</strong></span><span style="color:#000099"><strong>,v</strong></span><span style="color:#000099"><strong>4</strong></span><span style="color:#000099"><strong>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>30</span></div>
<div><span style="font-size:18px"><span style="color:#000099"><strong>&nbsp;</strong></span>v<span style="color:#000099"><strong>0</strong></span><span style="color:#000099"><strong>到</strong></span><span style="color:#000099"><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>v<span style="color:#000099"><strong>5&nbsp;&nbsp;&nbsp;</strong></span><span style="color:#000099"><strong>(</strong></span><span style="color:red"><strong>v</strong></span><span style="color:red"><strong>0</strong></span><span style="color:red"><strong>,v</strong></span><span style="color:red"><strong>4</strong></span><span style="color:red"><strong>,</strong></span><span style="color:red"><strong>v</strong></span><span style="color:red"><strong>3</strong></span><span style="color:red"><strong>,v</strong></span><span style="color:red"><strong>5</strong></span><span style="color:#000099"><strong>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></span>60</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div>
<div>
<div><span style="font-size:18px"><span style="color:#0033cc">●</span>&nbsp; <strong>初始时,S仅包含源s,
</strong></span></div>
<div><span style="font-size:18px"><span style="color:#0033cc">●</span><strong>&nbsp;</strong><span style="color:#cc0000"><strong>特殊路径：</strong></span></span></div>
<div><span style="font-size:18px"><strong>&nbsp; 从源到G中某一顶点u且中间只经过S中顶点的路称为</strong><span style="color:#cc0000"><strong>从源到</strong></span><span style="color:#cc0000"><strong>u</strong></span><span style="color:#cc0000"><strong>的特殊路径</strong></span><strong>。</strong></span></div>
<div><span style="font-size:18px"></span></div>
<div><span style="font-size:18px"><span style="color:#0033cc">●</span><strong>&nbsp;算法每次从</strong><span style="color:#cc0000"><strong>V-S</strong></span><strong>中取出具有</strong><span style="color:#cc0000"><strong>最短特殊路径</strong></span></span></div>
<div><strong><span style="font-size:18px">&nbsp;&nbsp; 长度的顶点u加入S中。 </span></strong></div>
<div>
<div>
<div><span style="font-size:18px"><span style="color:#cc0000"><span style="color:#0033cc">●</span></span><span style="color:#cc0000"><strong>算法思想:</strong></span></span></div>
<div><span style="font-size:18px"><span style="color:#cc0000"><strong>&nbsp;&nbsp; </strong>
</span>按路径长度递增序产生各顶点最短路径</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div>用到的变量：</div>
<div>&nbsp;</div>
<div><span style="font-size:18px">int&nbsp; G[maxnum][maxnum]; //邻接矩阵,距离无限远用9999表示</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px">int&nbsp; dist[maxnum]; //存放各个顶点到源点的寻短路径；</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px">bool&nbsp; visit[maxnum] ;&nbsp; //标志该定点是否被访问，初始化wei 0</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px">int last;//表示当前所走路径最后一个节点</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px">利用贪心算法，首先从原点出发，初始化dist[maxnum]; 假如源点v0，顶点数目6&nbsp; (v0,v1,v2,v3,v4,v5)；</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px">for i=0 to&nbsp;5 ,dist[i]=G[0][i];&nbsp;&nbsp;&nbsp;</span></div>
<div><span style="font-size:18px">&nbsp;然后dist[0] = 0;//到本身距离为0， 再标记V0点， visit[0] = 1;//以访问v0点，</span></div>
<div><span style="font-size:18px">此时dist[5]={0,9999,30,9999,30,100};&nbsp; visit[]={1,0,0,0,0,0};&nbsp; last = 0;//v0点为当前路径最后一个</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px">然后for循环，寻找从源点到其他店的最小距离，并且该点未被访问，</span></div>
<div><strong><span style="font-size:24px"></span></strong>&nbsp;</div>
<div><span style="font-size:24px"><strong></strong></span><pre class="cpp" name="code">int min = 9999;
for(j=0;j&lt;n;j++) 
{
    if(!visit[j] &amp;&amp; min&lt; G[v0][j])
   {
         min = G[last][j];
                    last = j;
   }
}
</pre><br>
&nbsp;</div>
<div><span style="font-size:18px">得到 last=2；//将v2加入当前路径 ，&nbsp;&nbsp;&nbsp; visit[last] = 1;&nbsp;</span></div>
<div><span style="font-size:18px">visit[] = {1,0,1,0,0,0}</span></div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px">然后将dist[]数组更新。, 更新为V0到各个点的最短路径</span>
<div><span style="font-size:18px">然后循环，直到所有结点都被访问；</span></div>
</div>
<div><strong><span style="font-size:24px"></span></strong>&nbsp;</div>
<div><strong><span style="font-size:24px"></span></strong><pre class="cpp" name="code">for(j=0;j&lt;n;j++)
 { 
         if(!visit[j] &amp;&amp; G[last][j]!=99999)
          { 
                   int newdist = dist[last] + G[last][j];
                   if(newdist &lt; dist[j])
                        { 
                                dist[j] = newdist;
                                     prev[j] = last;
                         } 
            } 
 }
 
</pre><br>
&nbsp;</div>
<div><span style="font-size:24px"><strong></strong></span>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>练习：&nbsp; <a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">
Hdu 2544</a>&nbsp;&nbsp; <a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=1874">
hdu1874</a></div>
<div>&nbsp;</div>
<div><pre class="cpp" name="code">#include &lt;iostream&gt;

using namespace std;

void Dijkstra(int n,int v,int *dist,int *prev,int G[102][102]) 
{
    bool visit[102];//存放顶点是否被访问
    int i,j;
    for(i=1; i&lt;=n; i++)
    {
        visit[i] = 0;
        dist[i] = G[v][i];
        if(dist[i]== 99999) prev[i] = 0;
        else prev[i] = v;    
    } 
    
    dist[v] = 0; 
    visit[v] = 1;
    
     for(i=2;i&lt;=n;i++)//访问剩下的点
     {
        int last = v;
        int min = 99999; 
        //寻找本行未使用点j的dist[j]最小值
        for(j=1;j&lt;=n;j++)
        {
            if(!visit[j]&amp;&amp; min&gt;dist[j])    
            {
                
                min = dist[j];
                last = j;//距离最小点的号码 
            }
        }    
        
        visit[last] = 1;//访问该距离最小点
        
        //将dist[]刷新
        for(j=1;j&lt;=n;j++)
        {
            if(!visit[j] &amp;&amp; G[last][j]!=99999)
            {
                int newdist = dist[last] + G[last][j];
                
                if(newdist &lt; dist[j])
                {
                    dist[j] = newdist;
                    prev[j] = last;    
                }
            }
    //        printf(&quot;%d &quot;,dist[j]);    
        }    
    //    printf(&quot;\n&quot;);
    } 
}


int main()
{

    int i,j,a,b,c;
    int dist[102];  
    int prev[102];  //记录当前点的前一个结点
    int G[102][102];
    int vnum,m; 
    
    while(scanf(&quot;%d%d&quot;,&amp;vnum,&amp;m),m&amp;&amp;vnum)
    {    
        
        for(i=1;i&lt;=vnum;i++)
            for(j=1;j&lt;=vnum;j++)
                G[i][j] = 99999;
    
        while(m--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            G[a][b] = G[b][a] = c;    
        }
        
        for(i=1;i&lt;=vnum;i++)
            dist[i] = 99999; //原点到各个点距离初始化
        
    //    for(i=1;i&lt;=vnum;i++) //输出创建的邻接矩阵 
//        {
//            for(j=1;j&lt;=vnum;j++)
//                printf(&quot;%4d&quot;,G[i][j]);
//            printf(&quot;\n&quot;);
//        } 

        Dijkstra(vnum,1,dist,prev,G);
        printf(&quot;%d\n&quot;,dist[vnum]);
    
    }
    
    return 0;    
}</pre><br>
</div>
<div><span style="font-size:24px"><strong></strong></span>&nbsp;</div>
<div><span style="font-size:24px"><strong></strong></span>&nbsp;</div>
<div><span style="font-size:24px"><strong></strong></span>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-中缀式转后缀表达式_-NYOJ_题目267郁闷的C小加（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/26/中缀式转后缀表达式_-NYOJ_题目267郁闷的C小加（二）/">中缀式转后缀表达式 -NYOJ 题目267郁闷的C小加（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div>
<h2>郁闷的C小加（二）</h2>
<div>时间限制：<span id="problem[time_limit]">1000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]">65535</span> KB</div>
<div>难度：4</div>
</div>
<dl><dt>描述 </dt><dd>
<p>聪明的你帮助C小加解决了中缀表达式到后缀表达式的转换（详情请参考“郁闷的C小加（一）”），C小加很高兴。但C小加是个爱思考的人，他又想通过这种方法计算一个表达式的&#20540;。即先把表达式转换为后缀表达式，再求&#20540;。这时又要考虑操作数是小数和多位数的情况。</p>
<dl><dt>输入 </dt><dd>第一行输入一个整数T，共有T组测试数据（T&lt;10)。<br>
每组测试数据只有一行，是一个长度不超过1000的字符串，表示这个运算式，每个运算式都是以“=”结束。这个表达式里只包含&#43;-*/与小括号这几种符号。其中小括号可以嵌套使用。数据保证输入的操作数中不会出现负数并且小于1000000。<br>
数据保证除数不会为0。<br>
</dd><dt>输出 </dt><dd>对于每组测试数据输出结果包括两行，先输出转换后的后缀表达式，再输出计算结果，结果保留两位小数。两组测试数据之间用一个空行隔开。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">21&#43;2=</pre>
</dd><dd>
<pre>(19&#43;21)*3-4/5=</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">12&#43;=</pre>
</dd><dd>
<pre>3.00</pre>
</dd><dd>
<pre>&nbsp;</pre>
</dd><dd>
<pre>1921&#43;3*45/-=</pre>
</dd><dd>
<pre>119.20</pre>
</dd></dl>
</dd></dl>
<dl>
<p>本题用到的技巧：</p>
<p><span style="font-size:18px">1.#include&lt;stack&gt; 其中第一好了栈以及其操作，简化了代码</span></p>
<p><span style="font-size:18px">2.atof函数 </span></p>
<div class="para"><span style="font-size:18px">功 能: 把字符串转换成浮点数</span>
<div class="para"><span style="font-size:18px">表头文件 #include &lt;stdlib.h&gt;</span></div>
</div>
<div class="para"><span style="font-size:18px">名字来源:ascii to floating point numbers 的缩写</span></div>
<div class="para"><span style="font-size:18px">用 法: double atof(const char *nptr);</span></div>
<div class="para"><span style="font-size:18px">程序例:</span></div>
<div class="para"><pre class="cpp" name="code">#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 
int main() 
{   
	float f;   
 	char *str = &quot;12345.67&quot;;   
	f = atof(str);   
	printf(&quot;string = %s float = %f\n&quot;, str, f);   
	return 0; 
} 


</pre></div>
<div class="nodoubt-module">
<div>
<div id="highlighter_136268" class="syntaxhighlighter  cpp ie"><span style="font-size:18px">相关函数
</span><a href="http://baike.baidu.com/view/653935.htm" target="_blank"><span style="font-size:18px">atoi</span></a><span style="font-size:18px">，</span><a href="http://baike.baidu.com/view/653934.htm" target="_blank"><span style="font-size:18px">atol</span></a><span style="font-size:18px">，</span><a href="http://baike.baidu.com/view/1876981.htm" target="_blank"><span style="font-size:18px">strtod</span></a><span style="font-size:18px">，</span><a href="http://baike.baidu.com/view/1874375.htm" target="_blank"><span style="font-size:18px">strtol</span></a><span style="font-size:18px">，</span><a href="http://baike.baidu.com/view/1526542.htm" target="_blank"><span style="font-size:18px">strtoul</span></a></div>
</div>
</div>
<p><span style="font-size:18px">3.sscanf函数 提取一个字符串中的各个类型的数据，分类提取很方便</span></p>
<p>&nbsp;</p>
<p>WA了数十次，一开始我以为是情况没考虑完，停了几天后忽然想到是不是后缀表达式煤球正确</p>
<p>然后找了 中缀表达式转后缀的方法：</p>
<h3 style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
1）规则</h3>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<span style="font-size:18px"><span style="color:#ff0000">中缀表达式<span style="font-family:Arial">a &#43; b*c &#43; (d * e &#43; f) * g，其转换成后缀表达式则为a b c * &#43; d e * f&nbsp;<wbr> &#43; g * &#43;。</span></span></span></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<span style="font-size:18px; color:#ff0000">转换过程需要用到栈，具体过程如下：</span></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<span style="font-size:18px; color:#ff0000">1）如果遇到操作数，我们就直接将其输出。</span></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<span style="font-size:18px; color:#ff0000">2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。</span></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<span style="font-size:18px"><span style="color:#ff0000">3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。<strong>注意，左括号只弹出并不输出。</strong></span></span></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<span style="font-size:18px"><span style="color:#ff0000">4）如果遇到任何其他的操作符，如（“&#43;”， “*”，“（”）等，<strong>从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止</strong>。弹出完这些元素后，才将遇到的操作符压入到栈中。<strong>有一点需要注意，只有在遇到&quot; ) &quot;的情况下我们才弹出&quot; ( &quot;，其他情况我们都不会弹出&quot; ( &quot;。也就是说这种操作，&quot; &#43; &quot;的优先级最低，&quot; ( &quot;优先级最高。</strong></span></span></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<span style="font-size:18px; color:#ff0000">5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。</span></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<h3 style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
2）实例</h3>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
规则很多，还是用实例比较容易说清楚整个过程。以上面的转换为例，输入为a &#43; b * c &#43; (d * e &#43; f)*g，处理过程如下：</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
1）首先读到a，直接输出。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
2）读到“&#43;”，将其放入到栈中。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
3）读到b，直接输出。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
此时栈和输出的情况如下：</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348146428_8057.png" style="border-bottom:medium none; border-left:medium none; max-width:100%; border-top:medium none; border-right:medium none"></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
4）读到“*”，因为栈顶元素&quot;&#43;&quot;优先级比&quot; * &quot; 低，所以将&quot; * &quot;直接压入栈中。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
5）读到c，直接输出。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
此时栈和输出情况如下：</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348146721_9861.png" style="border-bottom:medium none; border-left:medium none; max-width:100%; border-top:medium none; border-right:medium none"></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
6）读到&quot; &#43; &quot;，因为栈顶元素&quot; * &quot;的优先级比它高，所以弹出&quot; * &quot;并输出， 同理，栈中下一个元素&quot; &#43; &quot;优先级与读到的操作符&quot; &#43; &quot;一样，所以也要弹出并输出。然后再将读到的&quot; &#43; &quot;压入栈中。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
此时栈和输出情况如下：</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147044_5952.png" style="border-bottom:medium none; border-left:medium none; max-width:100%; border-top:medium none; border-right:medium none"></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
7）下一个读到的为&quot;(&quot;，它优先级最高，所以直接放入到栈中。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
8）读到d，将其直接输出。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
此时栈和输出情况如下：</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147265_9645.png" style="border-bottom:medium none; border-left:medium none; max-width:100%; border-top:medium none; border-right:medium none"></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
9）读到&quot; * &quot;，由于只有遇到&quot; ) &quot;的时候左括号&quot;(&quot;才会弹出，所以&quot; * &quot;直接压入栈中。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
10）读到e，直接输出。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
此时栈和输出情况如下：</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147424_4303.png" style="border-bottom:medium none; border-left:medium none; max-width:100%; border-top:medium none; border-right:medium none"></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
11）读到&quot; &#43; &quot;，弹出&quot; * &quot;并输出，然后将&quot;&#43;&quot;压入栈中。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
12）读到f，直接输出。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
此时栈和输出情况：</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr><img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147826_1174.png" style="border-bottom:medium none; border-left:medium none; max-width:100%; border-top:medium none; border-right:medium none"></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到&quot;(&quot;为止。这里右括号前只有一个操作符&quot;&#43;&quot;被弹出并输出。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348147993_7462.png" style="border-bottom:medium none; border-left:medium none; max-width:100%; border-top:medium none; border-right:medium none"></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
14）读到&quot; * &quot;，压入栈中。读到g，直接输出。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348148087_4361.png" style="border-bottom:medium none; border-left:medium none; max-width:100%; border-top:medium none; border-right:medium none"></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
15）此时输入数据已经读到末尾，栈中还有两个操作符“*”和&quot; &#43; &quot;，直接弹出并输出。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
<img title="中缀表达式转换为后缀表达式" alt="" src="http://img.my.csdn.net/uploads/201209/20/1348148276_3639.png" style="border-bottom:medium none; border-left:medium none; max-width:100%; border-top:medium none; border-right:medium none"></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
至此整个转换过程完成。程序实现代码后续再补充了。</p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr></p>
<h3 style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
&nbsp;<wbr>3）转换的另一种方法</h3>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
1)先按照运算符的优先级对中缀表达式加括号，变成<span style="font-size:14px"><span style="font-family:Arial">( ( a&#43;(b*c) ) &#43; ( ((d*e)&#43;f) *g ) )</span></span></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
2)将运算符移到括号的后面，变成<span style="font-size:14px"><span style="font-family:Arial">((a(bc)*)&#43;(((de)*f)&#43;g)*)&#43;</span></span></p>
<p style="padding-bottom:0px; margin:0px; padding-left:0px; padding-right:0px; padding-top:0px">
3)去掉括号，得到<span style="font-size:14px"><span style="font-family:Arial">abc*&#43;de*f&#43;g*&#43;</span></span></p>
<p>&nbsp;</p>
<p>计算就好说了，根据后缀表达式，遇到运算符则弹出两个操作数，计算后压栈，最后栈顶元素为计算结果</p>
</dl>
<dl>
<p>代码：</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;stack&gt;

using namespace std;
 

int In(char e)
{
	if(e=='(' || e==')' || e=='+' || e=='-' || e=='*' || e=='/') return 1;
	else return 0;
}
int cmp(char c)
{
	switch(c)
	{
		case '+':
		case '-': return 1;
		case '*':
		case '/': return 2;
		default : return 0;	
	}	
}
double calculate(char op,double k1,double k2)
{
	double k;
	switch (op)
	{
		case '+': k = k1+k2; break;
		case '-': k = k1-k2; break;
		case '*': k = k1*k2; break;
		case '/': k = k1/k2; break;
	}
	return k;
}

/*
20
(2.6)-(1.666)=
1+2=
(19+21)*3-4/5=

*/

void change(char str[])
{
	int t,i,k,m;
	char e,buf[1002],op,s[1002];
	double kk,k1,k2;
	stack &lt;char&gt; S1;
	stack &lt;double&gt; S2;
	k=0;
	S1.push('=');
	for(i=0;i&lt;strlen(str)-1;++i) //最后一位是 = 
	{
			if( In(str[i])  )
			{				
				switch(str[i])
				{
					case '(': S1.push(str[i]); break;
					case ')': //遇到右括号， 
						while(S1.top()!='(')//弹出栈元素输出 直到 （，
						{
							s[k++]=S1.top();
							k1 = S2.top(); S2.pop();
							k2 = S2.top(); S2.pop();
							S2.push(calculate(S1.top(),k2,k1));
							S1.pop();	
						}
						if(S1.top()=='(')//弹出（不输出
						{
							S1.pop();	
						} 

						break;
					default :
						while(cmp(str[i])&lt;=cmp(S1.top()))
						{
							s[k++]=S1.top();
							k1 = S2.top(); S2.pop();
							k2 = S2.top(); S2.pop();
							S2.push(calculate(S1.top(),k2,k1));
							S1.pop();	
						}
						S1.push(str[i]);
						break;
				}//switch
			}//if
			else{

				sscanf(str+i,&quot;%[^=()+*/-]&quot;,buf); //操作数 
				for(m=0;m&lt;strlen(buf);m++) s[k++]=buf[m];
				//printf(&quot;%s&quot;,buf);
				i += strlen(buf)-1;
				kk = atof(buf);
				//printf(&quot;k = %lf\n&quot;,k);
				S2.push(kk);

			}

			
		}//for
		while(!S1.empty())
		{
			if(S1.top()!='(' &amp;&amp; S1.top()!='=')
			{
				s[k++]=S1.top();
				k1 = S2.top(); S2.pop();
				k2 = S2.top(); S2.pop();
				S2.push(calculate(S1.top(),k2,k1));
			}
				
			S1.pop();
		}

		for(i=0;i&lt;k;i++) printf(&quot;%c&quot;,s[i]);
		printf(&quot;=\n&quot;);
		printf(&quot;%.2lf\n&quot;,S2.top());		
} 
int main()
{
	int t,i;
	char e,str[1002],buf[1002],op;
	double k,k1,k2;
		
	scanf(&quot;%d&quot;,&amp;t); getchar();
	while(t--)
	{
		
		gets(str); 
		//puts(str);
		change(str);
		
		if(t&gt;0) printf(&quot;\n&quot;);
	}

	return 0;
}
/*
20
1+2=
(19+21)*3-4/5=

*/
        
</pre>
<p><br>
注意：中缀表达式转为后缀表达式的方法。。。。。。</p>
</dl>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-贪心——HDU题目1009_FatMouse&#39;_Trade" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/26/贪心——HDU题目1009_FatMouse'_Trade/">贪心——HDU题目1009 FatMouse&#39; Trade</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 style="color:#1a5cc8">FatMouse' Trade</h1>
<p><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 33504&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 10897<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br>
The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of
 cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case
 is followed by two -1's. All integers are not greater than 1000.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">5 3
7 2
4 3
5 2
20 3
25 18
24 15
15 10</div><div style="font-family:Courier New,Courier,monospace">1 0</div><div style="font-family:Courier New,Courier,monospace">0 1</div><div style="font-family:Courier New,Courier,monospace">1 0</div><div style="font-family:Courier New,Courier,monospace">-1 -1</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">13.333
31.500</div><div style="font-family:Courier New,Courier,monospace">0.000</div><div style="font-family:Courier New,Courier,monospace">1.000</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>类&#20284;于0-1背包问题<br>
</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;

using namespace std;

typedef struct ROOM
{
    int j,f;
}ROOM;
ROOM room[10001];

bool cmp(ROOM a,ROOM b)
{
    return 1.0*a.j/a.f &gt; 1.0*b.j/b.f;    
}
int main()
{
    int n,m,i;
    double max;
    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n) &amp;&amp; (m!=-1||n!=-1))
    {
        if(n==0)//zhe里是特殊情况 
        {
            printf(&quot;0.000\n&quot;);continue;    
        }
        for(i=0;i&lt;n;i++) 
            scanf(&quot;%d%d&quot;,&amp;room[i].j,&amp;room[i].f);    
        sort(room,room+n,cmp);
        //for(i=0;i&lt;n;i++)
        //    printf(&quot;%d %d\n&quot;,room[i].j,room[i].f);
        max = i = 0;
        if(m==0)//第一次提交没考虑特殊情况
        {
            if(room[i].f==0)
            {
                max+=room[i].j;    
            }    
            i++;
        }
        while(m)
        {
            if(m&gt;=room[i].f)
            {
                max += room[i].j;    
                m -= room[i].f;
            }
            else
            {
                max += 1.0 * room[i].j/room[i].f *m;    
                m=0;    
            }
            i++;
        }
        printf(&quot;%.3lf\n&quot;,max);
    }
    return 0;
}
</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  

  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/14/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/">Next &raquo;</a>
    </nav>
  


</section>
      </div>
      <footer id="footer">
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      &copy; 2017 <a href="https://github.com/hanks-zyh"> Hanks</a>
	  </div>
  </div>
 <div id="share">
  <a id="totop" title="" style="display: block;">返回顶部</a>
 </div>
</footer>

    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
