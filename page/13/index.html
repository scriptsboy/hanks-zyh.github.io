<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hanks&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="android,web,node,python">
<meta property="og:type" content="website">
<meta property="og:title" content="Hanks' Blog">
<meta property="og:url" content="http://hanks-zyh.github.io/page/13/index.html">
<meta property="og:site_name" content="Hanks' Blog">
<meta property="og:description" content="android,web,node,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hanks' Blog">
<meta name="twitter:description" content="android,web,node,python">
  
  
    <link rel="icon" href="/images/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'> -->
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo"></a>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      
        <a class="main-nav-link" href="/archives">归档</a>
      
        <a class="main-nav-link" href="/daily">日报</a>
      
        <a class="main-nav-link" href="/eye-video">开眼</a>
      
        <a class="main-nav-link" href="/joke">joke</a>
      
        <a class="main-nav-link" href="/picture-fight">斗图</a>
      
        <a class="main-nav-link" href="/atom.xml">RSS</a>
      
    </nav>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/daily" class="mobile-nav-link">日报</a>
  
    <a href="/eye-video" class="mobile-nav-link">开眼</a>
  
    <a href="/joke" class="mobile-nav-link">joke</a>
  
    <a href="/picture-fight" class="mobile-nav-link">斗图</a>
  
    <a href="/atom.xml" class="mobile-nav-link">RSS</a>
  
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="info">
     <div class="content">
       <div>
         <a href="https://github.com/hanks-zyh"><img class="avatar" src="https://avatars2.githubusercontent.com/u/6268322?v=3&s=460" alt="" /></a>
       </div>
       <div class="name">
         <h2 >Hanks</h2>
       </div>
       <p>‭100100011101‬</p>
       <div class="account">
         <div class="account-item">
           <a href="http://weibo.com/u/2359002991"><img src="http://ww1.sinaimg.cn/large/8c9b876fjw1f3ik9y4q7hj205k05kdfx.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
              <a href="http://www.zhihu.com/people/yuhan-zhang-36"><img src="http://ww2.sinaimg.cn/large/8c9b876fjw1f3ik7sv63wj205k05k3yg.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
           <a href="https://github.com/hanks-zyh"> <img src="http://ww1.sinaimg.cn/large/8c9b876fly1fe196fbtiqj205k05ka9u.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
       </div>
     </div>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">最新发布</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/26/node-image-recognition/">Node 识别图片中的文字</a>
          </li>
        
          <li>
            <a href="/2017/03/22/proxy-test/">请求代理</a>
          </li>
        
          <li>
            <a href="/2017/02/16/android-customview-inputmethod/">Android 自定义 view 连接输入法</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-lua/">Android 与 Lua</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-markdown-render/">Android 下 Markdown 渲染</a>
          </li>
        
          <li>
            <a href="/2017/01/09/android-webview-font/">Android 中 webview 自定义字体</a>
          </li>
        
          <li>
            <a href="/2016/09/25/slack-bot/">slack bot</a>
          </li>
        
          <li>
            <a href="/2016/09/19/webapp/">让网页更适配移动设备</a>
          </li>
        
          <li>
            <a href="/2016/09/05/weex-2333/">体验 weex —— 写一个表情包应用</a>
          </li>
        
          <li>
            <a href="/2016/08/31/nestedscrollchild/">WebView 实现 NestedScrollingChild</a>
          </li>
        
          <li>
            <a href="/2016/08/29/nestedchildparent/">NestedScrollingParent 实现复杂交互效果</a>
          </li>
        
          <li>
            <a href="/2016/08/04/telegram-bot/">写一个福利 Telegram 机器人</a>
          </li>
        
          <li>
            <a href="/2016/07/31/write-butterkinfe/">写一个 ButterKnife</a>
          </li>
        
          <li>
            <a href="/2016/07/24/edittext-cursor/">多行 EditText 的光标高度问题</a>
          </li>
        
          <li>
            <a href="/2016/07/22/textview-lineheight/">TextView 设置行高并垂直居中</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Atom/" style="font-size: 10px;">Atom</a> <a href="/tags/Dagger2/" style="font-size: 10px;">Dagger2</a> <a href="/tags/EditText/" style="font-size: 10px;">EditText</a> <a href="/tags/Express/" style="font-size: 11.67px;">Express</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/Framework/" style="font-size: 11.67px;">Framework</a> <a href="/tags/HTML-CSS/" style="font-size: 10px;">HTML/CSS</a> <a href="/tags/Jade/" style="font-size: 10px;">Jade</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/LAMP/" style="font-size: 10px;">LAMP</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Lua/" style="font-size: 10px;">Lua</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/NestedScrolling/" style="font-size: 13.33px;">NestedScrolling</a> <a href="/tags/Node-js/" style="font-size: 13.33px;">Node.js</a> <a href="/tags/OS-X/" style="font-size: 10px;">OS X</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Python/" style="font-size: 11.67px;">Python</a> <a href="/tags/React-Native/" style="font-size: 18.33px;">React-Native</a> <a href="/tags/Refactoring/" style="font-size: 10px;">Refactoring</a> <a href="/tags/Rx/" style="font-size: 10px;">Rx</a> <a href="/tags/RxJava/" style="font-size: 13.33px;">RxJava</a> <a href="/tags/Rxandroid/" style="font-size: 10px;">Rxandroid</a> <a href="/tags/Rxjava/" style="font-size: 11.67px;">Rxjava</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Scrapy/" style="font-size: 11.67px;">Scrapy</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/SwipeRefreshLayout/" style="font-size: 10px;">SwipeRefreshLayout</a> <a href="/tags/Telegram/" style="font-size: 10px;">Telegram</a> <a href="/tags/TextView/" style="font-size: 10px;">TextView</a> <a href="/tags/Ubuntu/" style="font-size: 16.67px;">Ubuntu</a> <a href="/tags/VPS/" style="font-size: 10px;">VPS</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/WebView/" style="font-size: 11.67px;">WebView</a> <a href="/tags/bot/" style="font-size: 10px;">bot</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/interpolator/" style="font-size: 10px;">interpolator</a> <a href="/tags/leancloud/" style="font-size: 10px;">leancloud</a> <a href="/tags/mac-os/" style="font-size: 10px;">mac os</a> <a href="/tags/slack/" style="font-size: 10px;">slack</a> <a href="/tags/virtualBox/" style="font-size: 10px;">virtualBox</a> <a href="/tags/weex/" style="font-size: 10px;">weex</a> <a href="/tags/代理/" style="font-size: 10px;">代理</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/学习/" style="font-size: 10px;">学习</a> <a href="/tags/必备知识/" style="font-size: 10px;">必备知识</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/热修复/" style="font-size: 11.67px;">热修复</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/自动化/" style="font-size: 10px;">自动化</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/hanks-zyh">hanks-zyh</a>
          </li>
        
          <li>
            <a href="http://kiya.space">Kiya‘s space</a>
          </li>
        
          <li>
            <a href="http://rocko.xyz/">Rocko&#39;s blog</a>
          </li>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="wx">
      <h3 class="widget-title">微信公众号</h3>
      <img src='http://ww1.sinaimg.cn/large/8c9b876fly1fe0nnlvokpj20by0bywfi.jpg' height="100%" width="100%" >
      <p>搜索公众号: CodeProvider</p>
    </div>
  </div>


  
</aside>
        
        <section id="main" class="mdl-shadow--2dp">
  
    <article id="post-hdu_题目1242_Rescue_（BFS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/15/hdu_题目1242_Rescue_（BFS）/">hdu 题目1242 Rescue （BFS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center"><span style="color:#3366ff">Rescue </span></h1>
<h5 align="center"><span style="color:#009900">Time Limit : 2000/1000ms (Java/Other)&nbsp;&nbsp;&nbsp;Memory Limit : 65536/32768K (Java/Other)</span></h5>
<h5 align="center"><span style="color:#009900">Total Submission(s) : 80&nbsp;&nbsp;&nbsp;Accepted Submission(s) : 39</span></h5>
<h3>Problem Description</h3>
<div id="procon">Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.<br>
<br>
Angel's friends want to save Angel. Their task is: approach Angel. We assume that &quot;approach Angel&quot; is to get to the position where Angel stays. When there's a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up,
 down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.<br>
<br>
You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)<br>
</div>
<h3>Input</h3>
<div id="proinput">First line contains two integers stand for N and M.<br>
<br>
Then N lines follows, every line has M characters. &quot;.&quot; stands for road, &quot;a&quot; stands for Angel, and &quot;r&quot; stands for each of Angel's friend.
<br>
<br>
Process to the end of the file.<br>
</div>
<h3>Output</h3>
<div id="prooutput">For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing &quot;Poor ANGEL has to stay in the prison all his life.&quot;
<br>
</div>
<h3>Sample Input</h3>
<div id="prosamplein">
<pre>7 8
#.#####.
#.a#..r.
#..#x...
..#..#.#
#...##..
.#......
........
</pre>
</div>
<h3>Sample Output</h3>
<div id="prosampleout">
<pre>13
</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size:18px">第一次使用priority_queue&lt;&gt;Q;&nbsp; </span></p>
<p><span style="font-size:18px">需要设置优先级 </span></p>
<pre class="cpp" name="code"><span style="font-size:18px;"> friend bool operator&lt; (node n1,node n2){
        return n2.step &lt; n1.step;//注意这里大小关系
    }
</span></pre>
<p><span style="font-size:18px"></span>&nbsp;</p>
<p><span style="font-size:18px"></span>&nbsp;</p>
<p><span style="font-size:18px">题目需要从目标地址‘a’ 开始四个方向广搜，（因为‘r’） 可能有好多个,只要搜到 r 则停止返回搜索步数</span><span style="font-size:18px">，</span></p>
<p><span style="font-size:18px">注意步数的加减多少，，，&nbsp;&nbsp; ‘x’ 要加 2 ，用到优先队列，将路径最短的作为对头出队</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><br>
&nbsp;</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;queue&gt;
using namespace std;

char map[211][211];
int n,m,s_x,s_y,e_x,e_y;

struct node{
    int x,y;
    int step;
    friend bool operator&lt; (node n1,node n2){
        return n2.step &lt; n1.step;
    }
};
int dir[4][2]={1,0,-1,0,0,1,0,-1};

int ok(int x,int y)
{
    if(x&lt;0 || x&gt;=n || y&lt;0 || y&gt;=m || map[x][y]==1)    return 0;
    return 1;
}
    
bool bfs(){
    
    priority_queue &lt;node&gt; q;
    node cur,next;
    int i;
    
    cur.x = s_x;
    cur.y=s_y;
    cur.step =0;
    map[cur.x][cur.y] = 1;
    
    q.push(cur);
    while(!q.empty()){
        
        cur = q.top();
        q.pop();
        if(cur.x== e_x &amp;&amp; cur.y== e_y) {
            printf(&quot;%d\n&quot;,cur.step);
            return 1;                    
        }
        for(i=0;i&lt;4;i++){
            next.x = cur.x + dir[i][0];
            next.y = cur.y + dir[i][1];
            
            if(ok(next.x,next.y)){
                if(map[next.x][next.y]==-1) next.step = cur.step+2;
                else next.step = cur.step+1;
                map[next.x][next.y] = 1;
                q.push(next);    
            }                            
        }
    }
    return 0;
}
int main()
{
    int i,j;
    char s[211];    
     while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=-1)
    {
        memset(map,0,sizeof(map));


        for(i=0;i&lt;n;i++)
        {
            scanf(&quot;%s&quot;,s);
            for(j=0;s[j];j++)
            {
                if(s[j]=='r')    {s_x=i;s_y=j;}
                else if(s[j]=='a'){e_x    =i;e_y=j;}
                else if(s[j]=='#')map[i][j]=1;
                else if(s[j]=='.')map[i][j]=0;
                else if(s[j]=='x')map[i][j]=-1;
            }
        }
        if(!bfs())    printf(&quot;Poor ANGEL has to stay in the prison all his life.\n&quot; );    
    }
    return 0;
}</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1421_搬寝室（DP）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/13/hdu_题目1421_搬寝室（DP）/">hdu 题目1421 搬寝室（DP）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<h1 style="color:rgb(26,92,200); text-align:center; font-family:'Times New Roman'">
搬寝室</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 13141&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 4441<br>
</span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2*k件过去就行了.但还是会很累,因为2*k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2
 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">2 1
1 3</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">4</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<div><br>
</div>
<span style="font-size:18px">根据题目的要求，每次提的两个物品重量差越小越好，是不是每次提的物品一定是重量相邻的物品呢？<br>
</span>
<p></p>
<p><span style="font-size:18px">证明：假设四个从小到大的数：a、b、c、d，只需证明以下表达式成立即可：<br>
(a-b)^2&#43;(c-d)^2&lt; (a-c)^2&#43;(b-d)^2<br>
(a-b)^2&#43;(c-d)^2&lt; (a-d)^2&#43;(b-c)^2<br>
</span></p>
<p><span style="font-size:18px">从最简单的情况考虑：<br>
2个物品选一对，结论显然<br>
</span></p>
<p><span style="font-size:18px">3个物品选一对，…<br>
</span></p>
<p><span style="font-size:18px">4个物品选一对？（如何利用前面的知识）<br>
</span></p>
<p><span style="font-size:18px">n个物品选一对，…<br>
</span></p>
<p><span style="font-size:18px">n个物品选二对，…<br>
</span></p>
<p><span style="font-size:18px">最终问题：n个物品选k对，如何？（n&gt;=2k）</span><br>
</p>
<p><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="font-size:18px"><strong>1.先排序，</strong></span></span></p>
<p><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="font-size:18px"><strong>2.假设从n-1个中选取k对是最少得，那么从n个中选取k对，可以这样分析 对n-1个数 再在末尾增加一个数，那么这个数可能被选中成为k对中其中一对，可能不被选中，如果不被选中，那么从n个中选取k对就相当于从n-1个中选取k对，如果被选中，之前证明了选中的数必须是连续的两个才能事最小，那就相当于从n-2个数中选取k-1对加最后两个数成为。</strong></span></span></p>
<p><span style="font-size:18px"><strong><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)">3。状态转移方程就为</span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">dp</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">[</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">i</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">][</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">j</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">]=</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">min</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">(</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">dp</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">[</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">i</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">-</span></span><span style="color:rgb(204,51,0); word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">1</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">][</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">j</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">],</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">dp</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">[</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">i</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">-</span></span><span style="color:rgb(204,51,0); word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">2</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">][</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">j</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">-</span></span><span style="color:rgb(204,51,0); word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">1</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">]&#43;(</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">a</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">[</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">i</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">-</span></span><span style="color:rgb(204,51,0); word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">1</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">]-</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">a</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">[</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">i</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">])*(</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">a</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">[</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">i</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">-</span></span><span style="color:rgb(204,51,0); word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">1</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">]-</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">a</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:#FF00FF; word-wrap:normal; word-break:normal">[</span></span><span style="word-wrap:normal; word-break:normal; line-height:21px; font-family:simsun; background-color:rgb(243,248,251)">i</span><span style="color:rgb(0,0,255); font-family:simsun; line-height:21px; background-color:rgb(243,248,251)"><span style="color:rgb(255,0,255); word-wrap:normal; word-break:normal">]));</span></span></strong></span></p>
<p><br>
</p>
<p><pre name="code" class="cpp">#define MIN(a,b) (a)&gt;(b)?(b):(a)
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
using namespace std;

int a[2002];
int dp[3][2002]; 

int main()
{
    int n,k,i,j,min;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF){
        for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
        a[0]=0;
        sort(a,a+n+1);
        memset(dp,0,sizeof(dp));
        
        for(i=2; i&lt;=n; i++){
            for(j=1; j&lt;=k &amp;&amp; j*2&lt;=i;j++){
                if(j*2==i) dp[i%3][j] = dp[(i-2)%3][j-1] + (a[i]-a[i-1])*(a[i]-a[i-1]);
                else dp[i%3][j] = MIN(dp[(i-1)%3][j], dp[(i-2)%3][j-1] + (a[i]-a[i-1])*(a[i]-a[i-1])) ;
            }    
        } 
        printf(&quot;%d\n&quot;,dp[n%3][k]);
    }
    return 0;
}</pre><br>
<br>
</p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1159_Common_Subsequence（DP）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/13/hdu_题目1159_Common_Subsequence（DP）/">hdu 题目1159 Common Subsequence（DP）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<h1 style="color:rgb(26,92,200); text-align:center; font-family:'Times New Roman'">
Common Subsequence</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 17779&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 7485<br>
</span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt;x1, x2, ..., xm&gt; another sequence Z = &lt;z1, z2, ..., zk&gt; is a subsequence of X if there exists a strictly increasing sequence &lt;i1, i2,
 ..., ik&gt; of indices of X such that for all j = 1,2,...,k, xij = zj. For example, Z = &lt;a, b, f, c&gt; is a subsequence of X = &lt;a, b, c, f, b, c&gt; with index sequence &lt;1, 2, 4, 6&gt;. Given two sequences X and Y the problem is to find the length of the maximum-length
 common subsequence of X and Y.&nbsp;<br>
The program input is from a text file. Each data set in the file contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. For each set of data the program prints on the standard
 output the length of the maximum-length common subsequence from the beginning of a separate line.&nbsp;<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">abcfbc abfcab
programming contest 
abcd mnp</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">4
2
0</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<div><br>
</div>
百度转帖
<p></p>
<p></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<strong><span style="font-size:14px"><span style="font-family:宋体">动态规划法</span></span></strong></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px; text-indent:21pt">
<span style="font-family:宋体"><span style="font-size:14px">经常会遇到复杂问题不能简单地分解成几个子问题，而会分解出一系列的子问题。简单地采用把大问题分解成子问题，并综合子问题的解导出大问题的解的方法，问题求解耗时会按问题规模呈幂级数增加。</span></span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体"><span style="font-size:14px">为了节约重复求相同子问题的时间，引入一个数组，不管它们是否对最终解有用，把所有子问题的解存于该数组中，这就是动态规划法所采用的基本方法。</span></span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体"></span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体"><span style="font-size:14px"></span></span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">【问题】&nbsp;</span><span style="font-family:宋体">求两字符序列的最长公共字符子序列</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">问题描述：字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列X=</span><span style="font-family:宋体">“x0</span><span style="font-family:宋体">，x1</span><span style="font-family:宋体">，…，xm-1”，序列Y=</span><span style="font-family:宋体">“y0</span><span style="font-family:宋体">，y1</span><span style="font-family:宋体">，…，yk-1”是X</span><span style="font-family:宋体">的子序列，存在X</span><span style="font-family:宋体">的一个严&#26684;递增下标序列&lt;i0</span><span style="font-family:宋体">，i1</span><span style="font-family:宋体">，…，ik-1&gt;</span><span style="font-family:宋体">，使得对所有的j=0</span><span style="font-family:宋体">，1</span><span style="font-family:宋体">，…，k-1</span><span style="font-family:宋体">，有xij=yj</span><span style="font-family:宋体">。例如，X=</span><span style="font-family:宋体">“ABCBDAB</span><span style="font-family:宋体">”，Y=</span><span style="font-family:宋体">“BCDB</span><span style="font-family:宋体">”是X</span><span style="font-family:宋体">的一个子序列。</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">考虑最长公共子序列问题如何分解成子问题，设A=</span><span style="font-family:宋体">“a0</span><span style="font-family:宋体">，a1</span><span style="font-family:宋体">，…，am-1”，B=</span><span style="font-family:宋体">“b0</span><span style="font-family:宋体">，b1</span><span style="font-family:宋体">，…，bm-1”，并Z=</span><span style="font-family:宋体">“z0</span><span style="font-family:宋体">，z1</span><span style="font-family:宋体">，…，zk-1”为它们的最长公共子序列。不难证明有以下性质：</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">（1</span><span style="font-family:宋体">）&nbsp;</span><span style="font-family:宋体">如果am-1=bn-1</span><span style="font-family:宋体">，则zk-1=am-1=bn-1</span><span style="font-family:宋体">，且“z0</span><span style="font-family:宋体">，z1</span><span style="font-family:宋体">，…，zk-2”是“a0</span><span style="font-family:宋体">，a1</span><span style="font-family:宋体">，…，am-2”和“b0</span><span style="font-family:宋体">，b1</span><span style="font-family:宋体">，…，bn-2”的一个最长公共子序列；</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">（2</span><span style="font-family:宋体">）&nbsp;</span><span style="font-family:宋体">如果am-1!=bn-1</span><span style="font-family:宋体">，则若zk-1!=am-1</span><span style="font-family:宋体">，蕴涵“z0</span><span style="font-family:宋体">，z1</span><span style="font-family:宋体">，…，zk-1”是“a0</span><span style="font-family:宋体">，a1</span><span style="font-family:宋体">，…，am-2”和“b0</span><span style="font-family:宋体">，b1</span><span style="font-family:宋体">，…，bn-1”的一个最长公共子序列；</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">（3</span><span style="font-family:宋体">）&nbsp;</span><span style="font-family:宋体">如果am-1!=bn-1</span><span style="font-family:宋体">，则若zk-1!=bn-1</span><span style="font-family:宋体">，蕴涵“z0</span><span style="font-family:宋体">，z1</span><span style="font-family:宋体">，…，zk-1”是“a0</span><span style="font-family:宋体">，a1</span><span style="font-family:宋体">，…，am-1”和“b0</span><span style="font-family:宋体">，b1</span><span style="font-family:宋体">，…，bn-2”的一个最长公共子序列。</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">这样，在找A</span><span style="font-family:宋体">和B</span><span style="font-family:宋体">的公共子序列时，如有am-1=bn-1</span><span style="font-family:宋体">，则进一步解决一个子问题，找“a0</span><span style="font-family:宋体">，a1</span><span style="font-family:宋体">，…，am-2”和“b0</span><span style="font-family:宋体">，b1</span><span style="font-family:宋体">，…，bm-2”的一个最长公共子序列；如果am-1!=bn-1</span><span style="font-family:宋体">，则要解决两个子问题，找出“a0</span><span style="font-family:宋体">，a1</span><span style="font-family:宋体">，…，am-2”和“b0</span><span style="font-family:宋体">，b1</span><span style="font-family:宋体">，…，bn-1”的一个最长公共子序列和找出“a0</span><span style="font-family:宋体">，a1</span><span style="font-family:宋体">，…，am-1”和“b0</span><span style="font-family:宋体">，b1</span><span style="font-family:宋体">，…，bn-2”的一个最长公共子序列，再取两者中较长者作为A</span><span style="font-family:宋体">和B</span><span style="font-family:宋体">的最长公共子序列。</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
&nbsp;</p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
&nbsp;</p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">求解：</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
</p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">引进一个二维数组c[][]，用c[i][j]记录X[i]与Y[j] 的LCS 的长度，b[i][j]记录c[i][j]是通过哪一个子问题的&#20540;求得的，以决定搜索的方向。<br>
我们是自底向上进行递推计算，那么在计算c[i,j]之前，c[i-1][j-1]，c[i-1][j]与c[i][j-1]均已计算出来。此时我们根据X[i] = Y[j]还是X[i] != Y[j]，就可以计算出c[i][j]。</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体">问题的递归式写成：</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<span style="font-family:宋体"><br>
</span></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
</p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<img src="http://p.blog.csdn.net/images/p_blog_csdn_net/hhygcy/EntryImages/20090302/lcs_1.PNG" alt="recursive formula" width="412" height="72" style="border:none; max-width:100%"></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
回溯输出最长公共子序列过程：</p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
<img src="http://p.blog.csdn.net/images/p_blog_csdn_net/hhygcy/EntryImages/20090302/lcs_2.PNG" alt="flow" width="374" height="384" style="border:none; max-width:100%"></p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
&nbsp;</p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
算法分析：<br>
由于每次调用至少向上或向左（或向上向左同时）移动一步，故最多调用(m &#43; n)次就会遇到i = 0或j = 0的情况，此时开始返回。返回时与递归调用时方向相反，步数相同，故算法时间复杂度为Θ(m &#43; n)。</p>
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">
&nbsp;</p>
<br>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><pre name="code" class="cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define N 10005
int c[N][N];
int main()
{
    int m,n,i,j;
    char x[N],y[N];
    while(scanf(&quot;%s%s&quot;,x,y)!=EOF){    
        for(i=0;i&lt;strlen(x);i++) c[i][0]=0; //边界行和列
        for(i=0;i&lt;strlen(y);i++) c[0][i]=0;
        
        for(i=1;i&lt;=strlen(x);i++){            
            for(j=1;j&lt;=strlen(y);j++){
                if(x[i-1]==y[j-1]) c[i][j] = c[i-1][j-1]+1;  //x[i] == y[j] ; 最长公共子序列+1；
                else c[i][j] = c[i-1][j] &gt; c[i][j-1] ? c[i-1][j] : c[i][j-1];
            }           
        }     

        printf(&quot;%d\n&quot;,c[i-1][j-1]);
    }
    return 0;
} 
/*
cnblogs belong
abcfbc abfcab
programming contest 
abcd mnp
*/</pre><br>
<br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1160_FatMouse&#39;s_Speed_（DP）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/13/hdu_题目1160_FatMouse's_Speed_（DP）/">hdu 题目1160 FatMouse&#39;s Speed （DP）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<h1 style="color:rgb(26,92,200); text-align:center; font-family:'Times New Roman'">
FatMouse's Speed</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 7280&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 3218<br>
<span style="color:red">Special Judge</span></span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
FatMouse believes that the fatter a mouse is, the faster it runs. To disprove this, you want to take the data on a collection of mice and put as large a subset of this data as possible into a sequence so that the weights are increasing, but the speeds are decreasing.<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
Input contains data for a bunch of mice, one mouse per line, terminated by end of file.<br>
<br>
The data for a particular mouse will consist of a pair of integers: the first representing its size in grams and the second representing its speed in centimeters per second. Both integers are between 1 and 10000. The data in each test case will contain information
 for at most 1000 mice.<br>
<br>
Two mice may have the same weight, the same speed, or even the same weight and speed.&nbsp;<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
Your program should output a sequence of lines of data; the first line should contain a number n; the remaining n lines should each contain a single positive integer (each one representing a mouse). If these n integers are m[1], m[2],..., m[n] then it must
 be the case that&nbsp;<br>
<br>
W[m[1]] &lt; W[m[2]] &lt; ... &lt; W[m[n]]<br>
<br>
and&nbsp;<br>
<br>
S[m[1]] &gt; S[m[2]] &gt; ... &gt; S[m[n]]<br>
<br>
In order for the answer to be correct, n should be as large as possible.<br>
All inequalities are strict: weights must be strictly increasing, and speeds must be strictly decreasing. There may be many correct outputs for a given input, your program only needs to find one.&nbsp;<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">6008 1300
6000 2100
500 2000
1000 4000
1100 3000
6000 2000
8000 1400
6000 1200
2000 1900</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">4
4
5
9
7</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<div><br>
</div>
<br>
<p></p>
<p>1.先将老鼠的speed递减排序，</p>
<p>2.求排过序数组的 weight 最长递增子序列</p>
<p>3求最长递增子序列时，每个元素的dp数组中递增时，都要记录它前面的递增元素下标，</p>
<p>4.根据最大的递增长度那个元素，递增找到这个递增子序列</p>
<p><pre name="code" class="cpp">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#define N 1002
using namespace std;

struct mouse{
    int id,w,v;
}m[N];
struct fun{
    int len;
    int i;
    int pre; 
}f[N];

bool cmp(mouse a,mouse b){
    if(a.v&gt;b.v) return true;
    return false;
}
bool cmp1(fun a,fun b){
    if(a.len&lt;b.len) return true;
    return false;
}
int main()
{
    int i,j,w,v,max,cnt = 1,k = 1;
    while(scanf(&quot;%d%d&quot;,&amp;w,&amp;v)!=EOF){
        m[k].id = cnt++;
        m[k].w = w; m[k].v = v;
        k++; 
    }
    sort(m+1,m+cnt,cmp);
    f[1].len  = 1; f[1].i = m[1].id;
    for(i=2;i&lt;cnt;i++){
        for(max =0,j=1; j&lt;i; j++){
            if(m[i].w&gt;m[j].w &amp;&amp; f[j].len&gt;max){
                max = f[j].len;    
                f[i].pre = j;
            }
        }
        f[i].len = max+1; f[i].i = m[i].id;
         
    }
    int index;
    for(max=1,i=1;i&lt;cnt;i++) 
        if(max&lt;f[i].len) {
            max= f[i].len;
            index = i;
        }
    k = 0;
    int p[N];
    while(f[index].pre!=0){
        p[k++] = f[index].i;
        index = f[index].pre;
    }p[k] = f[index].i;
    
    printf(&quot;%d\n&quot;,max);
    for(i=k;i&gt;=0;i--) {
         printf(&quot;%d\n&quot;,p[i]);
    }
    return 0;
}</pre><br>
<br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目17_单调递增最长子序列_（DP）_hdu_题目2845_Bean" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/13/NYOJ_题目17_单调递增最长子序列_（DP）_hdu_题目2845_Bean/">NYOJ 题目17 单调递增最长子序列 （DP） hdu 题目2845 Bean</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<div class="problem-display" style="font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<h2 style="margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体">
吃土豆</h2>
<div class="problem-ins" style="text-align:center">时间限制：<span class="editable highlight" id="problem[time_limit]" style="color:rgb(113,32,21)">1000</span>&nbsp;ms &nbsp;|&nbsp; 内存限制：<span class="editable highlight" id="problem[memory_limit]" style="color:rgb(113,32,21)">65535</span>&nbsp;KB</div>
<div class="problem-ins" style="text-align:center">难度：<span class="editable highlight" style="color:rgb(113,32,21)">4</span></div>
</div>
<div class="clr" style="clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19px">
</div>
<dl class="problem-display" style="margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
描述</dt><dd style="margin:0px; padding:0px"><span style="font-family:'Times New Roman'">Bean-eating is an interesting game, everyone owns an M*N matrix, which is filled with different qualities beans. Meantime, there is only one bean in any 1*1 grid. Now you want to
 eat the beans and collect the qualities, but everyone must obey by the following rules: if you eat the bean at the coordinate(x, y), you can’t eat the beans anyway at the coordinates listed (if exiting): (x, y-1), (x, y&#43;1), and the both rows whose abscissas
 are x-1 and x&#43;1.<br>
</span>
<center><img src="http://acm.hdu.edu.cn/data/images/convip1-1001-1.JPG" alt="" style="border:0px none"></center>
<br>
<br>
Now, how much qualities can you eat and then get ?
<div class="clr" style="clear:both"></div>
<dl class="others" style="margin:0px; padding:0px"><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输入</dt><dd style="margin:0px; padding:0px">There are a few cases. In each case, there are two integer M (row number) and N (column number). The next M lines each contain N integers, representing the qualities of the beans. We can make sure that the quality of bean
 isn't beyond 1000, and 1&lt;=M,N&lt;=500.<br>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输出</dt><dd style="margin:0px; padding:0px">For each case, you just output the MAX qualities you can eat and then get.</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输入</dt><dd style="margin:0px; padding:0px">
<pre id="sample_input" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">4 6
11 0 7 5 13 9
78 4 81 6 22 4
1 40 9 34 16 10
11 22 0 33 39 6</pre>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输出</dt><dd style="margin:0px; padding:0px">
<pre id="sample_output" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">242</pre>
</dd></dl>
</dd></dl>
<br>
<p></p>
<p>二次dp，</p>
<p>1.首先单独对每行的数据进行DP处理，得到一个最大&#20540;；</p>
<p>2,.每行的最大&#20540;又组成一个新的数组，再次dp求最大&#20540;</p>
<p><br>
</p>
<p><br>
</p>
<p></p>
<pre name="code" class="cpp"> 
#define N 505
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int MAX(int x,int y){
	return x&gt;y?x:y;
}
int main()
{
	int m,n,i,j,k,max,a[N][N],dp[N][2],f[N]; 
	
	while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n)!=EOF){
		
		for(i=0;i&lt;m;i++) 
			for(j=0;j&lt;n;j++)
				scanf(&quot;%d&quot;,&amp;a[i][j]);
	
		for(i=0;i&lt;m;i++) {
			dp[0][0]=0; dp[0][1]=a[i][0];		
			for(j=1;j&lt;n;j++){
				dp[j][0] = MAX(dp[j-1][0],dp[j-1][1]);
				dp[j][1] = dp[j-1][0] + a[i][j];
			}		
			f[i] = MAX(dp[n-1][0],dp[n-1][1]);
		}
		dp[0][0] = 0;  dp[0][1] = f[0];
		
		for(j=1;j&lt;m;j++){		
			dp[j][0] = MAX(dp[j-1][0],dp[j-1][1]);
			dp[j][1] = dp[j-1][0] + f[j];
		}				
		printf(&quot;%d\n&quot;,MAX(dp[m-1][0],dp[m-1][1]));
	}
	
	return 0;
}         </pre><br>
<br>
<p>HDU 题目</p>
<p></p>
<h1 style="color:rgb(26,92,200); text-align:center; font-family:'Times New Roman'">
Beans</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 2144&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1081<br>
</span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
Bean-eating is an interesting game, everyone owns an M*N matrix, which is filled with different qualities beans. Meantime, there is only one bean in any 1*1 grid. Now you want to eat the beans and collect the qualities, but everyone must obey by the following
 rules: if you eat the bean at the coordinate(x, y), you can’t eat the beans anyway at the coordinates listed (if exiting): (x, y-1), (x, y&#43;1), and the both rows whose abscissas are x-1 and x&#43;1.<br>
<center><img src="http://acm.hdu.edu.cn/data/images/convip1-1001-1.JPG" alt="" style="border:none"></center>
<br>
<br>
Now, how much qualities can you eat and then get ?</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
There are a few cases. In each case, there are two integer M (row number) and N (column number). The next M lines each contain N integers, representing the qualities of the beans. We can make sure that the quality of bean isn't beyond 1000, and 1&lt;=M*N&lt;=200000.</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
For each case, you just output the MAX qualities you can eat and then get.</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">4 6
11 0 7 5 13 9
78 4 81 6 22 4
1 40 9 34 16 10
11 22 0 33 39 6</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">242</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<div><br>
</div>
代码要严谨，直接上面的代码通不过；
<p></p>
<p>改进代码：</p>
<p><br>
</p>
<p><pre name="code" class="cpp">#define N 200005
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int MAX(int x,int y){
    return x&gt;y?x:y;
}
int a[N],dp[N][2],f[N]; 
int main()
{
    int m,n,i,j,k,max;        
    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n)!=EOF){    
        for(i=0;i&lt;m;i++) {
            for(j=0;j&lt;n;j++)
                scanf(&quot;%d&quot;,&amp;a[j]);                            
            dp[0][0]=0; dp[0][1]=a[0];    
            for(j=1;j&lt;n;j++){
                dp[j][0] = MAX(dp[j-1][0],dp[j-1][1]);
                dp[j][1] = dp[j-1][0] + a[j];
            }        
            f[i] = MAX(dp[n-1][0],dp[n-1][1]);                                                        
        }
        dp[0][0] = 0;  dp[0][1] = f[0];
        for(j=1;j&lt;m;j++){        
            dp[j][0] = MAX(dp[j-1][0],dp[j-1][1]);
            dp[j][1] = dp[j-1][0] + f[j];
        }    
        printf(&quot;%d\n&quot;,MAX(dp[m-1][0],dp[m-1][1]));
    }
    
    return 0;
} </pre><br>
<br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目17_单调递增最长子序列_（DP）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/13/NYOJ_题目17_单调递增最长子序列_（DP）/">NYOJ 题目17 单调递增最长子序列 （DP）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<div class="problem-display" style="font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<h2 style="margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体">
单调递增最长子序列</h2>
<div class="problem-ins" style="text-align:center">时间限制：<span class="editable highlight" id="problem[time_limit]" style="color:rgb(113,32,21)">3000</span>&nbsp;ms &nbsp;|&nbsp; 内存限制：<span class="editable highlight" id="problem[memory_limit]" style="color:rgb(113,32,21)">65535</span>&nbsp;KB</div>
<div class="problem-ins" style="text-align:center">难度：<span class="editable highlight" style="color:rgb(113,32,21)">4</span></div>
</div>
<div class="clr" style="clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19px">
</div>
<dl class="problem-display" style="margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
描述</dt><dd style="margin:0px; padding:0px">求一个字符串的最长递增子序列的长度<br>
如：dabdbf最长递增子序列就是abdf，长度为4
<div class="clr" style="clear:both"></div>
<dl class="others" style="margin:0px; padding:0px"><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输入</dt><dd style="margin:0px; padding:0px">第一行一个整数0&lt;n&lt;20,表示有n个字符串要处理<br>
随后的n行，每行有一个字符串，该字符串的长度不会超过10000</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输出</dt><dd style="margin:0px; padding:0px">输出字符串的最长递增子序列的长度</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输入</dt><dd style="margin:0px; padding:0px">
<pre id="sample_input" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">3
aaa
ababc
abklmncdefg</pre>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输出</dt><dd style="margin:0px; padding:0px">
<pre id="sample_output" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">1
3
7</pre>
</dd></dl>
</dd></dl>
<br>
<p></p>
<p><br>
</p>
<p><img src="http://img.blog.csdn.net/20130813224533593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHB1X3p5aA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</p>
<p><span style="font-size:18px">与之类&#20284; f[i]数组存放 包括 i的 i个字母的最长递增子序列 长度，</span></p>
<p><span style="font-size:18px">f[0] = 1;&nbsp;</span></p>
<p><span style="font-size:18px">f[1] = 2; &nbsp;(递增子序列：1,4 )</span></p>
<p><span style="font-size:18px">f[2] = 3 ;<span style="font-size:18px">&nbsp;(递增子序列：1,4,7 )</span></span></p>
<p><span style="font-size:18px">f[3] = 2;<span style="font-size:18px">&nbsp;(递增子序列：1,2 )</span></span></p>
<p><span style="font-size:18px">f[4] = 3;<span style="font-size:18px">&nbsp;(递增子序列：1,4,5 或 1,2,5)</span></span></p>
<p><span style="font-size:18px">f[5] = 4;<span style="font-size:18px">&nbsp;(递增子序列：1,4,7,8或1,4,5,8或1,2,5,8)</span></span></p>
<p><span style="font-size:18px">f[6] = 3;<span style="font-size:18px">&nbsp;(递增子序列：1,2,3)</span></span></p>
<p><span style="font-size:18px; color:#cc0000"><br>
</span></p>
<p><span style="font-size:18px; color:#cc0000">最后求出f[]中最大&#20540;即为最长递增子序列</span></p>
<p></p>
<pre name="code" class="cpp"> 
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
	int n,i,j,max,f[10010]; 
	char s[10010];
	// bool vis[500];
	scanf(&quot;%d&quot;,&amp;n);
	getchar();
	while(n--){
		scanf(&quot;%s&quot;,s);
		
		
		for(i=1;i&lt;strlen(s);i++) f[i] = 0;
		f[0]=1;
		for(i=1;i&lt;strlen(s);i++)
		{
			max=0;
			for(j=0;j&lt;i;j++){
				if(s[j]&lt;s[i] &amp;&amp;  max&lt;f[j]) {
					f[i] = f[j];
					max = f[j];
				}
			}
			f[i]++;
		}

		for(max=1,i=0;i&lt;strlen(s);i++){
			if(max &lt; f[i]) max = f[i];
		}
		printf(&quot;%d\n&quot;,max);
	}
	
	return 0;
}         </pre><br>
<br>
<p></p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目3_多边形重心" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/12/NYOJ_题目3_多边形重心/">NYOJ 题目3 多边形重心</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h4 class="problem-display"></h4>
<h2 class="problem-display" align="center"><span style="color:#3333ff">多边形重心问题</span></h2>
<div class="problem-ins" align="center"><span style="color:#009900">时间限制：<span id="problem[time_limit]" class="editable highlight">3000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB</span></div>
<div class="problem-ins" align="center"><span style="color:#009900">难度：<span class="editable highlight">5</span></span></div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>在某个多边形上，取n个点，这n个点顺序给出，按照给出顺序将相邻的点用直线连接， （第一个和最后一个连接），所有线段不和其他线段相交，但是可以重合，可得到一个多边形或一条线段或一个多边形和一个线段的连接后的图形；<br>
如果是一条线段,我们定义面积为0，重心坐标为（0,0）.现在求给出的点集组成的图形的面积和重心横纵坐标的和；
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>第一行有一个整数0&lt;n&lt;11,表示有n组数据；<br>
每组数据第一行有一个整数m&lt;10000,表示有这个多边形有m个顶点； </dd><dt>输出 </dt><dd>输出每个多边形的面积、重心横纵坐标的和，小数点后保留三位； </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">3
3
0 1
0 2
0 3
3
1 1
0 0
0 1
4
1 1
0 0
0 0.5
0 1</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">0.000 0.000
0.500 1.000
0.500 1.000</pre>
</dd></dl>
</dd></dl>
<p></p>
<div>
<div><strong><span style="font-size:18px; color:#990000">三角形的重心是：&nbsp;&nbsp;(x1&#43;x2&#43;x3) / 3，(y1&#43;y2&#43;y3) / 3</span></strong></div>
<div><strong><span style="font-size:18px; color:#990000">三角形的面积为:S =&nbsp;&nbsp;(&nbsp;(x2 - x1) * (y3 -&nbsp;y1) - (x3 - x1) * (y2 - y1) ) / 2 ;</span></strong></div>
<div><span style="font-size:18px; color:#990000"><span color="#000000"><strong>另外在求解的过程中，不需要考虑点的输入顺序是顺时针还是逆时针，相除后就抵消了</strong></span></span></div>
</div>
<p align="center"><img alt="" src="http://img.blog.csdn.net/20130812210247250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHB1X3p5aA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="469" height="239"></p>
<p align="center">&nbsp;</p>
<p align="left"><span style="font-size:18px">关于多边形的面积 有一个化简的公式：看这里 </span><a target="_blank" href="http://blog.csdn.net/hpu_zyh/article/details/9920197"><span style="font-size:18px">计算多边形面积</span></a></p>
<dl></dl>
<div>
<div><span style="font-size:18px">剖分成N个三角形，分别求出其重心和面积，这时可以想象，原来质量均匀分布在内部区域上，而现在质量仅仅分布在这N个重心点上（等假变换），这时候就可以利用刚才的质点系重心公式了。</span></div>
<div><span style="font-size:18px">不过，要稍微改一改，改成<span style="color:red"><strong>加权平均</strong></span>数，因为质量不是均匀分布的，每个质点代表其所在三角形，其质量就是该三角形的面积（<span style="color:red"><strong>有向面</strong></span><span style="color:red"><strong>积</strong></span><span style="color:red">！</span>），——这就是权！</span></div>
<div><span style="font-size:18px"></span>&nbsp;</div>
</div>
<p>&nbsp;</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></p>
<p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>计算重心：</strong></span></p>
<p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>1.将各个点存入数组；（数组最后增加一个 点 等于第一个 点，为了首尾相接）</strong></span></p>
<p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>2. 以原点为定点，计算每个三角形的（有向）面积和，总面积就是 对和取绝对&#20540;，</strong></span></p>
<p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>3. 计算出每个三角形的（加权）重心， X = S *(x1&#43;x2&#43;0)/3;&nbsp;&nbsp;&nbsp; Y = S *（y1&#43;y2&#43;0）/3;</strong></span></p>
<p><span style="font-family:Microsoft YaHei; font-size:18px"><strong>4.&nbsp;然后多边形的重心坐标为&nbsp;
<span style="font-size:24px">G<span style="font-size:12px">x</span> </span>= <span style="font-size:24px">
X</span><span style="font-size:10px">总</span> <span style="font-size:24px">/</span>
<span style="font-size:24px">S</span><span style="font-size:10px">总</span>;&nbsp; <strong>
<span style="font-size:24px">G</span><span style="font-size:12px">y</span><span style="font-size:24px">
</span><span style="font-size:18px">= </span><span style="font-size:24px">Y</span><span style="font-size:10px">总</span><span style="font-size:18px">
</span><span style="font-size:24px">/</span><span style="font-size:18px"> </span>
<span style="font-size:24px">S</span><span style="font-size:10px">总</span><span style="font-size:18px">;
</span></strong></strong></span></p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
struct point{
	double x,y;
}; point p[10004];

int main()
{
	int n,m,i;
	scanf(&quot;%d&quot;,&amp;n);
	while(n--){
		scanf(&quot;%d&quot;,&amp;m);
		for(i=0;i&lt;m;i++)
			scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);
		p[m] = p[0]; //注意最后一个点与第一个点的相连 
		double x,y,s,temp;
		x = y = s = 0;
		for(i=0;i&lt;m;i++){
			temp = (p[i].x*p[i+1].y-p[i].y*p[i+1].x)/2;//有向面积
			s += temp;//总有向面积
			x += temp * (p[i].x+p[i+1].x)/3; //加权 
			y += temp * (p[i].y+p[i+1].y)/3;  
		}
		if(fabs(s)&lt;0.0000001) printf(&quot;0.000 0.000\n&quot;); //面积为0
		else printf(&quot;%.3lf %.3lf\n&quot;,fabs(s),(x+y)/s); 
	}
	return 0; 
} </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-poj_题目2398_Toy_Storage_（简单计算几何）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/12/poj_题目2398_Toy_Storage_（简单计算几何）/">poj 题目2398 Toy Storage （简单计算几何）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div lang="en-US" class="ptt" align="center"><strong><span style="font-size:18px; color:#3333ff">Toy Storage</span></strong></div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><span style="color:#33cc00"><strong>Time Limit:</strong> 1000MS</span></td>
<td width="10"><span style="color:#33cc00"></span></td>
<td><span style="color:#33cc00"><strong>Memory Limit:</strong> 65536K</span></td>
</tr>
<tr>
<td><span style="color:#33cc00"><strong>Total Submissions:</strong> 3299</span></td>
<td width="10"><span style="color:#33cc00"></span></td>
<td><span style="color:#33cc00"><strong>Accepted:</strong> 1887</span></td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div lang="en-US" class="ptx">Mom and dad have a problem: their child, Reza, never puts his toys away when he is finished playing with them. They gave Reza a rectangular box to put his toys in. Unfortunately, Reza is rebellious and obeys his parents by simply
 throwing his toys into the box. All the toys get mixed up, and it is impossible for Reza to find his favorite toys anymore.
<br>
Reza's parents came up with the following idea. They put cardboard partitions into the box. Even if Reza keeps throwing his toys into the box, at least toys that get thrown into different partitions stay separate. The box looks like this from the top:
<br>
<center><img src="http://poj.org/images/2398_1.jpg" alt=""></center>
<br>
We want for each positive integer t, such that there exists a partition with t toys, determine how many partitions have t, toys.</div>
<p class="pst">Input</p>
<div lang="en-US" class="ptx">The input consists of a number of cases. The first line consists of six integers n, m, x1, y1, x2, y2. The number of cardboards to form the partitions is n (0 &lt; n &lt;= 1000) and the number of toys is given in m (0 &lt; m &lt;= 1000). The
 coordinates of the upper-left corner and the lower-right corner of the box are (x1, y1) and (x2, y2), respectively. The following n lines each consists of two integers Ui Li, indicating that the ends of the ith cardboard is at the coordinates (Ui, y1) and
 (Li, y2). You may assume that the cardboards do not intersect with each other. The next m lines each consists of two integers Xi Yi specifying where the ith toy has landed in the box. You may assume that no toy will land on a cardboard.
<br>
<br>
A line consisting of a single 0 terminates the input.</div>
<p class="pst">Output</p>
<div lang="en-US" class="ptx">For each box, first provide a header stating &quot;Box&quot; on a line of its own. After that, there will be one line of output per count (t &gt; 0) of toys in a partition. The value t will be followed by a colon and a space, followed the number
 of partitions containing t toys. Output will be sorted in ascending order of t for each box.</div>
<p class="pst">Sample Input</p>
<pre class="sio">4 10 0 10 100 0
20 20
80 80
60 60
40 40
5 10
15 10
95 10
25 10
65 10
75 10
35 10
45 10
55 10
85 10
5 6 0 10 60 0
4 3
15 30
3 1
6 8
10 10
2 1
2 8
1 5
5 5
40 10
7 9
0
</pre>
<p class="pst">Sample Output</p>
<pre class="sio">Box
2: 5
Box
1: 4
2: 1
</pre>
<p>&nbsp;</p>
<p>更刚才那道题题目几乎一样，只不过这个需要将边进行排序，然后计算每个区域的点的个数；</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include&lt;iostream&gt; 
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#define N 1005
using namespace std;
struct bian{
	int up;
	int down;
};
bian box[N];
int cnt[N];

bool cmp(bian a,bian b){
	if(a.up&lt;b.up) return true;
	return false;
}
int main()
{
	int n,m,x1,y1,x2,y2,i,j,xj,yj,ui,li;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		scanf(&quot;%d%d%d%d%d&quot;,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
		box[n].up= box[n].down = x2;
		for(i=0;i&lt;n;i++){
			scanf(&quot;%d%d&quot;,&amp;ui,&amp;li);
			box[i].up = ui;  box[i].down=li; 
		}
		sort(box,box+n+1,cmp); //这里需要排序 
		for(i=0;i&lt;=n;i++) cnt[i]=0;
		for(i=0;i&lt;m;i++){
			scanf(&quot;%d%d&quot;,&amp;xj,&amp;yj);
			for(j=0;j&lt;=n;j++)
			{			
				int b1x = box[j].up ;
				int b2x = box[j].down;
				
				if((b2x-b1x)*(yj-y1)-(y2-y1)*(xj-b1x)&lt;0 ) { //判断点与当前边的关系 
					cnt[j]++; break;	
				}	
			}
		}
		sort(cnt,cnt+n+1); //个数排序 
		printf(&quot;Box\n&quot;);	
		for(i=1;i&lt;=n;i++){
			if(cnt[i-1]){	
				int sum = 1;
			
				while(cnt[i]==cnt[i-1]) {
					i++;sum++;
				}
				printf(&quot;%d: %d\n&quot;,cnt[i-1],sum);
				if(i==n)	printf(&quot;%d: 1\n&quot;,cnt[i]); //最后的单独一个 
			}		
		}
	}
	return 0;
}
</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-poj_题目2318_TOYS_（计算几何，点与边的关系）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/12/poj_题目2318_TOYS_（计算几何，点与边的关系）/">poj 题目2318 TOYS （计算几何，点与边的关系）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div lang="en-US" class="ptt" align="center"><span style="font-size:24px; color:#3333ff">TOYS</span></div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><span style="color:#009900"><strong>Time Limit:</strong> 2000MS</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Memory Limit:</strong> 65536K</span></td>
</tr>
<tr>
<td><span style="color:#009900"><strong>Total Submissions:</strong> 9018</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Accepted:</strong> 4288</span></td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div lang="en-US" class="ptx">Calculate the number of toys that land in each bin of a partitioned toy box.
<br>
Mom and dad have a problem - their child John never puts his toys away when he is finished playing with them. They gave John a rectangular box to put his toys in, but John is rebellious and obeys his parents by simply throwing his toys into the box. All the
 toys get mixed up, and it is impossible for John to find his favorite toys. <br>
<br>
John's parents came up with the following idea. They put cardboard partitions into the box. Even if John keeps throwing his toys into the box, at least toys that get thrown into different bins stay separated. The following diagram shows a top view of an example
 toy box. <br>
<img src="http://poj.org/images/2318_1.jpg" alt=""> <br>
For this problem, you are asked to determine how many toys fall into each partition as John throws them into the toy box.</div>
<p class="pst">Input</p>
<div lang="en-US" class="ptx">The input file contains one or more problems. The first line of a problem consists of six integers, n m x1 y1 x2 y2. The number of cardboard partitions is n (0 &lt; n &lt;= 5000) and the number of toys is m (0 &lt; m &lt;= 5000). The coordinates
 of the upper-left corner and the lower-right corner of the box are (x1,y1) and (x2,y2), respectively. The following n lines contain two integers per line, Ui Li, indicating that the ends of the i-th cardboard partition is at the coordinates (Ui,y1) and (Li,y2).
 You may assume that the cardboard partitions do not intersect each other and that they are specified in sorted order from left to right. The next m lines contain two integers per line, Xj Yj specifying where the j-th toy has landed in the box. The order of
 the toy locations is random. You may assume that no toy will land exactly on a cardboard partition or outside the boundary of the box. The input is terminated by a line consisting of a single 0.</div>
<p class="pst">Output</p>
<div lang="en-US" class="ptx">The output for each problem will be one line for each separate bin in the toy box. For each bin, print its bin number, followed by a colon and one space, followed by the number of toys thrown into that bin. Bins are numbered from
 0 (the leftmost bin) to n (the rightmost bin). Separate the output of different problems by a single blank line.</div>
<p class="pst">Sample Input</p>
<pre class="sio">5 6 0 10 60 0
3 1
4 3
6 8
10 10
15 30
1 5
2 1
2 8
5 5
40 10
7 9
4 10 0 10 100 0
20 20
40 40
60 60
80 80
 5 10
15 10
25 10
35 10
45 10
55 10
65 10
75 10
85 10
95 10
0
</pre>
<p class="pst">Sample Output</p>
<pre class="sio">0: 2
1: 1
2: 1
3: 1
4: 0
5: 1

0: 2
1: 2
2: 2
3: 2
4: 2
</pre>
<p class="pst">Hint</p>
<div lang="en-US" class="ptx">As the example illustrates, toys that fall on the boundary of the box are &quot;in&quot; the box.</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size:18px">1.从左到有有右将每条边都存起来，然后输入一个点判断一个；</span></strong></p>
<p><strong><span style="font-size:18px">2.判断一个点的所属区域时，首先从第一条边开始判断，如果该点在第一条边左边 ，则所属区域为边左边的区域，跳出循环，判断下一个点； 若不在第一条边的左边，则继续循环</span></strong></p>
<p><strong><span style="font-size:18px">3.判断点与边的关系的时候，用叉积 判断；</span></strong></p>
<p><strong><span style="font-size:18px"><img src="http://img.blog.csdn.net/20130812183128421" alt=""></span></strong></p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include&lt;stdio.h&gt;
#define N 50005

struct point{
	int x,y; //本题这里y坐标多余 
};
struct bian{
	point up,down;//边的上下顶点 
};
bian box[N];  int cnt[N];

int main()
{
	int n,m,x1,y1,x2,y2,i,j,xj,yj,ui,li;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		scanf(&quot;%d%d%d%d%d&quot;,&amp;m,&amp;x1,&amp;y1,&amp;x2,&amp;y2);

		box[n].up.x = box[n].down.x = x2;
		box[n].up.y = y1; box[n].down.y = y2; //这里有点多余，所有的点纵坐标都是 y1或y2 
		for(i=0;i&lt;n;i++){
			scanf(&quot;%d%d&quot;,&amp;ui,&amp;li);
			box[i].up.x = ui; box[i].up.y = y1;
			box[i].down.x=li; box[i].down.y = y2;
		}
		for(i=0;i&lt;=n;i++) cnt[i]=0; //初始化数组 
		for(i=0;i&lt;m;i++){
			scanf(&quot;%d%d&quot;,&amp;xj,&amp;yj);
			for(j=0;j&lt;=n;j++) {	//查找区域
				int b1x = box[j].up.x ;
				int b2x = box[j].down.x;	
				if((b2x-b1x)*(yj-y1)-(y2-y1)*(xj-b1x)&lt;0 ) {
					cnt[j]++; break;	
				}
			}
		}			
		for(i=0;i&lt;=n;i++)
			printf(&quot;%d: %d\n&quot;,i,cnt[i]);
		puts(&quot;&quot;);
	}
	return 0;
}</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-计算多边形的面积" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/12/计算多边形的面积/">计算多边形的面积</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h2>如何计算一个多边形的面积，首先想到的是划分成多个小的三角形，因为三角形我们比较熟悉，而且三角形计算面积的方法也很多</h2>
<p><span style="font-size:18px">三角形:<br>
1. 半周长 P=(a&#43;b&#43;c)/2<br>
2. 面积 S=aHa/2=absin(C)/2=sqrt(P(P-a)(P-b)(P-c))<br>
3. 中线 Ma=sqrt(2(b^2&#43;c^2)-a^2)/2=sqrt(b^2&#43;c^2&#43;2bccos(A))/2<br>
4. 角平分线 Ta=sqrt(bc((b&#43;c)^2-a^2))/(b&#43;c)=2bccos(A/2)/(b&#43;c)<br>
5. 高线 Ha=bsin(C)=csin(B)=sqrt(b^2-((a^2&#43;b^2-c^2)/(2a))^2)<br>
6. 内切圆半径 r=S/P=asin(B/2)sin(C/2)/sin((B&#43;C)/2)<br>
=4Rsin(A/2)sin(B/2)sin(C/2)=sqrt((P-a)(P-b)(P-c)/P)<br>
=Ptan(A/2)tan(B/2)tan(C/2)<br>
7. 外接圆半径 R=abc/(4S)=a/(2sin(A))=b/(2sin(B))=c/(2sin(C))</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size:18px">计算几何中计算三角形面积</span></p>
<div><span style="font-size:18px">在计算几何里，我们知道，<span style="color:#3366ff">△ABC的面积就是“向量AB”和“向量AC”两个向量叉积的绝对&#20540;的一半。其正负表示三角形顶点是在右手系还是左手系。</span></span></div>
<p><img alt="" src="http://img.blog.csdn.net/20130812113446953" width="507" height="195"></p>
<p>所以得到三角形面积</p>
<p><img alt="" src="http://img.blog.csdn.net/20130812113529546" width="546" height="127"></p>
<h3>特别注意： </h3>
<h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以上得到是有向面积（<span style="color:#ff0000">有正负</span>）！ </h3>
<div><span style="color:#333399"><strong></strong></span>&nbsp;</div>
<h2>凸多边形的三角形剖分</h2>
<div><strong><span style="color:#333399"></span></strong>
<div>
<div>&nbsp;</div>
<div>
<div>
<div><span style="font-size:14px; color:#000000">很自然地，我们会想到以 P1为扇面中心，连接P1Pi就得到N-2个三角形，由于凸性，保证这些三角形全在多边形内，那么，这个凸多边形的有向面积：</span><span style="font-size:14px; color:#000000">A=sigma(Ai)&nbsp; (i=1…N-2)
</span></div>
</div>
</div>
<div><strong><span style="color:#333399"><img alt="" src="http://img.blog.csdn.net/20130812113702812" width="344" height="163"></span></strong></div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<h2>凹多边形的面积</h2>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><img alt="" src="http://img.blog.csdn.net/20130812113732687" width="356" height="172"></div>
<div>
<div><span style="font-family:FangSong_GB2312; font-size:24px">多边形面积公式：A=sigma(Ai)&nbsp; (i=1…N-2)</span></div>
<div>
<div>
<div><span style="font-family:FangSong_GB2312; font-size:24px">结论： </span></div>
<div><span style="font-family:FangSong_GB2312; font-size:24px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; “有向面积”A比“面积”S其实更<span style="color:red"><strong>本质</strong></span>！</span></div>
</div>
</div>
</div>
<div>&nbsp;</div>
</div>
</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div>
<div><span style="font-size:18px"><span style="color:#333399"><strong>任意点为扇心的三角形剖分</strong></span><span style="color:#333399"><strong>：</strong></span></span></div>
<div>
<div>
<div><span style="font-size:14px">我们能把多边形分成N-2个三角形，为什么不能分成N个三角形呢？ </span></div>
<div><span style="font-size:14px">比如，以多边形内部的一个点为扇心，就可以把多边形剖分成 N个三角形。</span></div>
<div><img alt="" src="http://img.blog.csdn.net/20130812113846968"></div>
<div>
<div><span style="font-size:18px; color:#333399"><strong>前面的三角剖分显然对于多边形内部任意一点都是合适的！</strong></span></div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
</div>
</div>
</div>
</div>
<div><strong><span style="color:#333399"><img alt="" src="http://img.blog.csdn.net/20130812113944421" width="504" height="172"></span></strong></div>
<div>
<div><span style="font-size:24px; color:#333399"><strong>能否把扇心移到多边形以外呢？</strong></span></div>
<div><strong><span style="font-size:24px; color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><img alt="" src="http://img.blog.csdn.net/20130812114031187" width="400" height="326"></div>
<div>&nbsp;</div>
<div>
<div><span style="font-size:18px"><span style="color:#333399"><strong>既然内外都可以，为什么不设</strong></span><span style="color:#333399"><strong>P0</strong></span><span style="color:#333399"><strong>为坐标原点呢？</strong></span></span></div>
</div>
<div><img alt="" src="http://img.blog.csdn.net/20130812114042718" width="297" height="225"></div>
<div><span style="font-size:32px; color:#ff0000"></span>&nbsp;</div>
<div><span style="font-size:32px; color:#ff0000">最终简化公式（包括凹多边形）：</span></div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><img alt="" src="http://img.blog.csdn.net/20130812114100093" width="604" height="184"></div>
<div>&nbsp;</div>
<div><span style="font-size:24px"><strong>举个例子：加入上面图中p1(x1,y1) p2(x2,y2),p3(x3,y3),p4(x4,y4);</strong></span></div>
<div><span style="font-size:24px"><strong>那么多边形的面积为 S =&nbsp; ( x1*y2 - y1*x2 &#43; x2*y3 - y2*x3 &#43; x3*y4 - y3*x4 &#43; x4*y1 - y4*x1&nbsp;) / 2;
</strong></span></div>
<div><strong><span style="font-size:24px">求出的面积是有向的，带正负；</span></strong></div>
</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<div><strong><span style="color:#333399"></span></strong>&nbsp;</div>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目2018_Shape_of_HDU（判断凸多边形）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/12/hdu_题目2018_Shape_of_HDU（判断凸多边形）/">hdu 题目2018 Shape of HDU（判断凸多边形）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">Shape of HDU</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 3000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 4395&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1950<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">话说上回讲到海东集团推选老总的事情，最终的结果是XHD以微弱优势当选，从此以后，“徐队”的称呼逐渐被“徐总”所取代，海东集团（HDU）也算是名副其实了。<br>
创业是需要地盘的，HDU向钱江肉丝高新技术开发区申请一块用地，很快得到了批复，据说这是因为他们公司研发的“海东牌”老鼠药科技含量很高，预期将占全球一半以上的市场。政府划拨的这块用地是一个多边形，为了描述它，我们用逆时针方向的顶点序列来表示，我们很想了解这块地的基本情况，现在请你编程判断HDU的用地是凸多边形还是凹多边形呢？<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">输入包含多组测试数据，每组数据占2行，首先一行是一个整数n，表示多边形顶点的个数，然后一行是2×n个整数，表示逆时针顺序的n个顶点的坐标（xi,yi），n为0的时候结束输入。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">对于每个测试实例，如果地块的形状为凸多边形，请输出“convex”,否则输出”concave”，每个实例的输出占一行。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">4
0 0 1 0 1 1 0 1
0</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">convex


</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>判断一个多边形是否为凸多边形 </p>
<p>一次判断新形成的边与前一个边的顺逆关系</p>
<p><img src="http://img.blog.csdn.net/20130812110304562" alt=""></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;stdio.h&gt;

struct point{
	int x,y;
};
double cross(point p0,point p1,point p2)
{	// 两个向量 a-&gt; (p1.x-p0.x, p1.y-p0.y)  和 b-&gt;(p2.x-p1.x, p2.y-p1.y)
	// 两个向量叉积 （a.x*b.y - a.y*b.x）
	//叉积结果 &gt;0 ,则向量 a 在向量 b的顺时针方向； &lt;0则相反； 等于0则在同一直线 
	return (p1.x-p0.x)*(p2.y-p1.y) - (p1.y-p0.y)*(p2.x-p1.x);
}
int main()
{
	int n;
	point p[1010];
	
	while(scanf(&quot;%d&quot;,&amp;n),n )
	{	
		int i,flag = 0;
		for(i=0;i&lt;n;i++){   //逆时针储存多边形各个点的坐标 
			scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y);
		}
		p[n]=p[0]; p[n+1]=p[1]; // 增加两个点代表最开始的两个点，以形成循环 
		for(i=2;i&lt;=n+1;i++){
			if(cross(p[i-2],p[i-1],p[i])&lt;0 ) flag=1;
		}
		if(!flag) printf(&quot;convex\n&quot;);
		else printf(&quot;concave\n&quot;);
	}
	return 0;
}</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目2072_单词数_（字典树）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/12/hdu_题目2072_单词数_（字典树）/">hdu 题目2072 单词数 （字典树）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<h1 style="font-family:'Times New Roman',Times,serif; color:rgb(26,92,200); text-align:center; margin:18px auto; font-size:28px">
单词数</h1>
<h5 style="font-family:'Times New Roman',Times,serif; font-size:13px; text-align:center; color:green; margin:0px auto">
Time Limit : 1000/1000ms (Java/Other)&nbsp;&nbsp;&nbsp;Memory Limit : 32768/32768K (Java/Other)</h5>
<h5 style="font-family:'Times New Roman',Times,serif; font-size:13px; text-align:center; color:green; margin:0px auto">
Total Submission(s) : 6&nbsp;&nbsp;&nbsp;Accepted Submission(s) : 2</h5>
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
lily的好朋友xiaoou333最近很空，他想了一件没有什么意义的事情，就是统计一篇文章里不同单词的总数。下面你的任务是帮助xiaoou333解决这个问题。</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<br style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
有多组数据，每组一行，每组就是一篇小文章。每篇小文章都是由小写字母和空&#26684;组成，没有标点符号，遇到#时表示输入结束。</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<br style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
每组只输出一个整数，其单独成行，该整数代表一篇文章里不同单词的总数。</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<br style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="margin:0px; padding:0px; font-family:'Courier New',Courier,monospace">you are my friend
#
</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<br style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="margin:0px; padding:0px; font-family:'Courier New',Courier,monospace">4
</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<div><br>
</div>
<p></p>
<p><strong><span style="font-size:18px"><br>
</span></strong></p>
<p><strong><span style="font-size:18px">1、简单的字典树，添加单词到字典树时判断单词是不是新单词（单词最后字母的flag 是不是 0 ），若是则NUM&#43;&#43;；</span></strong></p>
<p><strong><span style="font-size:18px">2、输出num即可</span></strong></p>
<p></p>
<p></p>
<p><strong><span style="font-size:18px">分离单词时注意考虑全面！！（因为没考虑完WA了好多次）</span></strong></p>
<p><strong><span style="font-size:18px">要除去单词前面多余的空&#26684;后才能接收单词，，，还有 全是空&#26684;的情况，应该输出0</span></strong></p>
<p><pre name="code" class="cpp">#define N 1000005
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

typedef struct Tire
{
	Tire * child[26];
	bool flag;
}Tire;

Tire * root;
int num;
void insert(char * s)
{
	Tire *p,*q=root;
	for(int i=0;i&lt;strlen(s);i++)	{
		if(q-&gt;child[s[i]-'a']) q = q-&gt;child[s[i]-'a'];
		else{
			p = (Tire *)malloc(sizeof(Tire));
			p-&gt;flag=0;
			for(int j=0;j&lt;26;j++) p-&gt;child[j]=NULL;
			q-&gt;child[s[i]-'a'] = p;
			q = p;
		}
	}
	if(!q-&gt;flag)	num++; //新单词
	q-&gt;flag = 1;
}

int main()
{               
	char s[N],s1[1005];

	while(gets(s) &amp;&amp; s[0]!='#' )
	{	
		root = (Tire *)malloc(sizeof(Tire));
		for(int i=0;i&lt;26;i++) root-&gt;child[i]=NULL;
		num=0;
		for(int j=0;j&lt;strlen(s);j++){
			while(s[j++]==' ') ; j--;
			if(j==strlen(s)) break;
			int k=0;
			while(s[j]!=' ' &amp;&amp; j&lt;strlen(s)) s1[k++]=s[j++];
			s1[k] = '\0';
			insert(s1);
		}
		
		printf(&quot;%d\n&quot;,num);
	}
	return 0;
}</pre><br>
<br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><strong><span style="font-size:18px">STL 将每个单词存入 set &lt;string &gt; sentence;; 最后直接输出元素个数即可，，，，</span></strong></p>
<p><br>
</p>
<p><br>
</p>
<p><pre name="code" class="cpp">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;set&gt;

using namespace std;

int main()
{
	char s[1000005],s1[1005];

	while(gets(s) &amp;&amp; s[0]!='#' )
	{	
		set &lt;string&gt; sentence;
		for(int j=0;j&lt;strlen(s);j++){
			while(s[j++]==' ') ; j--; /除去多余的空格
			if(j==strlen(s)) break;
			int k=0;
			while(s[j]!=' ' &amp;&amp; j&lt;strlen(s)) s1[k++]=s[j++]; //接收每个单词
			s1[k] = '\0';
			sentence.insert(s1);
		}
		
		printf(&quot;%d\n&quot;,sentence.size());
	}
	return 0;
}</pre><br>
<br>
</p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1247_Hat’s_Words（字典树）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/11/hdu_题目1247_Hat’s_Words（字典树）/">hdu 题目1247 Hat’s Words（字典树）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<h1 style="font-family:'Times New Roman',Times,serif; color:rgb(26,92,200); text-align:center; margin:18px auto; font-size:28px">
Hat’s Words</h1>
<h5 style="font-family:'Times New Roman',Times,serif; font-size:13px; text-align:center; color:green; margin:0px auto">
Time Limit : 2000/1000ms (Java/Other)&nbsp;&nbsp;&nbsp;Memory Limit : 65536/32768K (Java/Other)</h5>
<h5 style="font-family:'Times New Roman',Times,serif; font-size:13px; text-align:center; color:green; margin:0px auto">
Total Submission(s) : 5&nbsp;&nbsp;&nbsp;Accepted Submission(s) : 3</h5>
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
A hat’s word is a word in the dictionary that is the concatenation of exactly two other words in the dictionary.<br>
You are to find all the hat’s words in a dictionary.<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<br style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
Standard input consists of a number of lowercase words, one per line, in alphabetical order. There will be no more than 50,000 words.<br>
Only one case.<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<br style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
Your output should contain all the hat’s words, one per line, in alphabetical order.</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<br style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="margin:0px; padding:0px; font-family:'Courier New',Courier,monospace">a
ahat
hat
hatword
hziee
word
</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<br style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="margin:0px; padding:0px; font-family:'Courier New',Courier,monospace">ahat
hatword
</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px">
&nbsp;</div>
<div><br>
</div>
<br>
<p></p>
<p><strong><span style="font-size:18px">1.将所有单词创建字典树</span></strong></p>
<p><strong><span style="font-size:18px">2.将每个单词拆分成两个，（如单词 ahat 依次拆分成 a,hat ; &nbsp;ah,at; &nbsp; aha,t; ）依次判断拆分的两个单词是否存在与字典树</span></strong></p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><pre name="code" class="cpp">#define N 50005
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

typedef struct Tire
{
	Tire * child[26];
	bool flag;
}Tire;

Tire * root;
void insert(char * s)//创建字典树
{
	Tire *p,*q=root;
	for(int i=0;i&lt;strlen(s);i++)	{
		if(q-&gt;child[s[i]-'a']) q = q-&gt;child[s[i]-'a'];
		else{
			p = (Tire *)malloc(sizeof(Tire));
			p-&gt;flag=0;
			for(int j=0;j&lt;26;j++) p-&gt;child[j]=NULL;
			q-&gt;child[s[i]-'a'] = p;
			q = p;
		}
	}
	q-&gt;flag = 1;//标志为1的代表这里是某个单词的结尾
}
bool find(char *s)
{
	Tire * q=root;
	for(int i=0;i&lt;strlen(s);i++){	
		if(q-&gt;child[s[i]-'a']) q = q-&gt;child[s[i]-'a'];
		else	return false;
	}
	if(q-&gt;flag==1) return true;//在字典树中找到该单词
	else return false;
}
int main()
{
	char s[N][20],s1[20],s2[20];
	root = (Tire *)malloc(sizeof(Tire));
	for(int i=0;i&lt;26;i++) root-&gt;child[i]=NULL;
	
	int k=0;
	while(scanf(&quot;%s&quot;,s[k])!=EOF )
		insert(s[k++]);
	for(int i=0;i&lt;k;i++){
		for(int j=1;j&lt;strlen(s[i]);j++){
			for(int m=0;m&lt;j;m++) s1[m]=s[i][m]; //将每个单词拆分成两个
			s1[j] = '\0';
			sscanf(s[i]+j,&quot;%s&quot;,s2);

			if(find(s1)&amp;&amp;find(s2)) { //拆分的两个单词都存在与字典树
				puts(s[i]);	break;
			}
		}
	}
	return 0;
}</pre><br>
<br>
</p>
<p><strong><span style="font-size:18px"><br>
</span></strong></p>
<p><strong><span style="font-size:18px">别人的STL 简单代码，没用过，不懂！！！先贴着，学过STL 以后看，这个效率不高。。</span></strong></p>
<p><pre name="code" class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;
map &lt;string, int&gt; m_v;
string str[50006];
int main() {
    int k(-1);
    while(cin &gt;&gt; str[++k]) {
        m_v[str[k]] = 1;
    }
    for(int i = 0; i &lt;= k; i++) {
        int e = str[i].size()-1;
        for(int j = 1; j &lt; e; j++) {
            string s1(str[i], 0, j);
            string s2(str[i], j);
            if(m_v[s1] == 1 &amp;&amp; m_v[s2] == 1) {
                cout &lt;&lt; str[i] &lt;&lt; endl;
                break;
            }
        }
    }
    return 0;
}</pre><br>
<br>
</p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-题目1045_Fire_Net_（DFS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/11/题目1045_Fire_Net_（DFS）/">题目1045 Fire Net （DFS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<h1 style="color:rgb(26,92,200); text-align:center; font-family:'Times New Roman'">
Fire Net</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green"><span style="white-space:pre"></span>Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
<span style="white-space:pre"></span>Total Submission(s): 4961&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 2784<br>
</span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
Suppose that we have a square city with straight streets. A map of a city is a square board with n rows and n columns, each representing a street or a piece of wall.&nbsp;<br>
<br>
A blockhouse is a small castle that has four openings through which to shoot. The four openings are facing North, East, South, and West, respectively. There will be one machine gun shooting through each opening.&nbsp;<br>
<br>
Here we assume that a bullet is so powerful that it can run across any distance and destroy a blockhouse on its way. On the other hand, a wall is so strongly built that can stop the bullets.&nbsp;<br>
<br>
The goal is to place as many blockhouses in a city as possible so that no two can destroy each other. A configuration of blockhouses is legal provided that no two blockhouses are on the same horizontal row or vertical column in a map unless there is at least
 one wall separating them. In this problem we will consider small square cities (at most 4x4) that contain walls through which bullets cannot run through.&nbsp;<br>
<br>
The following image shows five pictures of the same board. The first picture is the empty board, the second and third pictures show legal configurations, and the fourth and fifth pictures show illegal configurations. For this board, the maximum number of blockhouses
 in a legal configuration is 5; the second picture shows one way to do it, but there are several other ways.&nbsp;<br>
<br>
<img src="http://acm.hdu.edu.cn/data/images/1045-1.jpg" alt="" style="border:none"><br>
<br>
Your task is to write a program that, given a description of a map, calculates the maximum number of blockhouses that can be placed in the city in a legal configuration.&nbsp;<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
The input file contains one or more map descriptions, followed by a line containing the number 0 that signals the end of the file. Each map description begins with a line containing a positive integer n that is the size of the city; n will be at most 4. The
 next n lines each describe one row of the map, with a '.' indicating an open space and an uppercase 'X' indicating a wall. There are no spaces in the input file.&nbsp;<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
For each test case, output one line containing the maximum number of blockhouses that can be placed in the city in a legal configuration.<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">4
.X..
....
XX..
....
2
XX
.X
3
.X.
X.X
.X.
3
...
.XX
.XX
4
....
....
....
....
0</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">5
1
5
2
4</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<div><br>
</div>
<br>
<p></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:24px; color:#cc0000">1.首先把 n*n 的大方&#26684;里的每个小方&#26684;编号 i（0,1，2,3,4,5....n*n-1），每一小&#26684;的横纵坐标分别为 row = i/n; &nbsp; col = i%n;</span></strong></p>
<p><strong><span style="font-family:KaiTi_GB2312; font-size:24px; color:#cc0000">2.从一号&#26684;&#26684;开始放置，判断能否放置，若能，则将能放置的元素个数&#43;1，继续判断第二个&#26684;&#26684;，循环直到所有的都判断完。取最大&#20540;</span></strong></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px; color:#cc0000"><strong>3.判断该位置能否放置，必须该元素所在行和列没有放置过元素（在遇到‘X’之前）</strong></span></p>
<p><br>
</p>
<p><br>
</p>
<p></p>
<pre name="code" class="cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

char a[4][4]; bool vis[4][4];
int n,maxnum;

bool place(int x,int y)//判断该位置是否能放置
{
    for(int i=x-1; i&gt;=0 &amp;&amp; a[i][y]!='X';i--)
        if(vis[i][y]) return false;    

    for(int j=y-1; j&gt;=0 &amp;&amp; a[x][j]!='X';j--)
        if(vis[x][j]) return false;    
    
    return true;
}
void DFS(int i,int num)
{
    if(i== n*n){//已经判断完每一格
        maxnum = maxnum&gt;num ? maxnum : num;
        return;
    }    
    else{
        int row = i/n;   int col = i%n;
        
        if(a[row][col]=='.' &amp;&amp; place(row,col)){
            vis[row][col] = 1;
            DFS(i+1,num+1);
            vis[row][col] = 0;
        }
        DFS(i+1,num);
    }
}
int main()
{
    while(scanf(&quot;%d&quot;,&amp;n),n)
    {
        for(int i=0;i&lt;n;i++)    scanf(&quot;%s&quot;,a[i]);
        maxnum=0;
        memset(vis,0,sizeof(vis));
        DFS(0,0);
        printf(&quot;%d\n&quot;,maxnum);        
    }
    return 0;
}</pre><br>
<br>
<p></p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-OJ_系统_C___与_G___提交时。。。" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/11/OJ_系统_C___与_G___提交时。。。/">OJ 系统 C++ 与 G++ 提交时。。。</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p style="text-align:center"><strong><span style="font-size:24px; color:#3333ff">百度搜索整理</span></strong></p>
<h2>oj 中G&#43;&#43;和C&#43;&#43;区别</h2>
<span style="font-family:SimSun; font-size:14px">1、输出double类型时，如果采用G&#43;&#43;提交，scanf采用%lf,prinf采用%f，否则会报错<br>
<br>
<br>
2、使用GCC/G&#43;&#43;的提醒:<br>
<br>
<br>
</span>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"><span style="font-family:SimSun; font-size:14px">对于64位整数, long long int 和 __int64 都是支持并且等价的.但是在读和写的时候只支持scanf(&quot;%<br>
</span><span style="font-family:SimSun; font-size:14px">I64d&quot;, ...)和printf(&quot;%I64d&quot;, ...).<br>
</span><span style="font-family:SimSun; font-size:14px">不支持&quot;%lld&quot;是因为MinGW下的GCC和G&#43;&#43;使用的msvcrt.dll动态链接库并不支持C99标准.<br>
</span><span style="font-family:SimSun; font-size:14px">根据ISO C&#43;&#43;标准,在G&#43;&#43;下,main函数的返回&#20540;必须是int,否则将会导致Compile Error(编译错误)的判答</span></blockquote>
<span style="font-family:SimSun; font-size:14px"><br>
<br>
3、G&#43;&#43;/GCC使用scanf、printf时注意引用&lt;stdio.h&gt;，只引用&lt;iostream&gt;不识别<br>
<br>
<br>
4、GCC/G&#43;&#43; 用的是MinGW的编译器 &nbsp;，C/C&#43;&#43; 用的是VC的编译器<br>
<br>
</span>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"><span style="font-family:SimSun; font-size:14px">有细节区别<br>
</span><span style="font-family:SimSun; font-size:14px">比如MinGW的iostream不包含printf但VC包含<br>
</span><span style="font-family:SimSun; font-size:14px">VC有&gt;?=运算符但MinGW没有</span></blockquote>
<br>
<br>
<h2><br>
C&#43;&#43;64位整型</h2>
<br>
在做ACM题时，经常都会遇到一些比较大的整数。而常用的内置整数类型常常显得太小了：其中long 和 int 范围是[-2^31,2^31)，即-2147483648~2147483647。而unsigned范围是[0,2^32)，即0~4294967295。也就是说，常规的32位整数只能够处理40亿以下的数。<br>
　　那遇到比40亿要大的数怎么办呢？这时就要用到C&#43;&#43;的64位扩展了。不同的编译器对64位整数的扩展有所不同。基于ACM的需要，下面仅介绍VC6.0与g&#43;&#43;编译器的扩展。<br>
　　VC的64位整数分别叫做__int64与unsigned __int64，其范围分别是[-2^63, 2^63)与[0,2^64)，即-9223372036854775808~9223372036854775807与0~18446744073709551615(约1800亿亿)。对64位整数的运算与32位整数基本相同，都支持四则运算与位运算等。当进行64位与32位的混合运算时，32位整数会被隐式转换成64位整数。但是，VC的输入输出与__int64的兼容就不是很好了，如果你写下这样一段代码：<br>
1 __int64 a;<br>
2 cin &gt;&gt; a;<br>
3 cout &lt;&lt; a;<br>
<br>
<br>
那么，在第2行会收到“error C2679: binary '&gt;&gt;' : no operator defined which takes a right-hand operand of type '__int64' (or there is no acceptable conversion)”的错误；在第3行会收到“error C2593: 'operator &lt;&lt;' is ambiguous”的错误。那是不是就不能进行输入输出呢？当然不是，你可以使用C的写法：<br>
scanf(&quot;%I64d&quot;,&amp;a);<br>
printf(&quot;%I64d&quot;,a);<br>
就可以正确输入输出了。当使用unsigned __int64时，把&quot;I64d&quot;改为&quot;I64u&quot;就可以了。<br>
　　OJ通常使用g&#43;&#43;编译器。其64位扩展方式与VC有所不同，它们分别叫做long long 与 unsigned long long。处理规模与除输入输出外的使用方法同上。对于输入输出，它的扩展比VC好。既可以使用<br>
1 long long a;<br>
2 cin&gt;&gt;a;<br>
3 cout&lt;&lt;a;<br>
也可以使用<br>
scanf(&quot;%lld&quot;,&amp;a);<br>
printf(&quot;%lld&quot;,a);<br>
<br>
<br>
<p>使用无符号数时，将&quot;%lld&quot;改成&quot;%llu&quot;即可</p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1298_T9（字典树）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/11/hdu_题目1298_T9（字典树）/">hdu 题目1298 T9（字典树）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<h1 style="color:rgb(26,92,200); text-align:center; font-family:'Times New Roman'">
T9</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green"><span style="white-space:pre"></span>Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
<span style="white-space:pre"></span>Total Submission(s): 1272&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 505<br>
</span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
A while ago it was quite cumbersome to create a message for the Short Message Service (SMS) on a mobile phone. This was because you only have nine keys and the alphabet has more than nine letters, so most characters could only be entered by pressing one key
 several times. For example, if you wanted to type &quot;hello&quot; you had to press key 4 twice, key 3 twice, key 5 three times, again key 5 three times, and finally key 6 three times. This procedure is very tedious and keeps many people from using the Short Message
 Service.<br>
<br>
This led manufacturers of mobile phones to try and find an easier way to enter text on a mobile phone. The solution they developed is called T9 text input. The &quot;9&quot; in the name means that you can enter almost arbitrary words with just nine keys and without pressing
 them more than once per character. The idea of the solution is that you simply start typing the keys without repetition, and the software uses a built-in dictionary to look for the &quot;most probable&quot; word matching the input. For example, to enter &quot;hello&quot; you
 simply press keys 4, 3, 5, 5, and 6 once. Of course, this could also be the input for the word &quot;gdjjm&quot;, but since this is no sensible English word, it can safely be ignored. By ruling out all other &quot;improbable&quot; solutions and only taking proper English words
 into account, this method can speed up writing of short messages considerably. Of course, if the word is not in the dictionary (like a name) then it has to be typed in manually using key repetition again.<br>
<br>
<center><img src="http://acm.hdu.edu.cn/data/images/1298-1.gif" alt="" style="border:none"><br>
Figure 8: The Number-keys of a mobile phone.</center>
<br>
<br>
More precisely, with every character typed, the phone will show the most probable combination of characters it has found up to that point. Let us assume that the phone knows about the words &quot;idea&quot; and &quot;hello&quot;, with &quot;idea&quot; occurring more often. Pressing the
 keys 4, 3, 5, 5, and 6, one after the other, the phone offers you &quot;i&quot;, &quot;id&quot;, then switches to &quot;hel&quot;, &quot;hell&quot;, and finally shows &quot;hello&quot;.<br>
<br>
Write an implementation of the T9 text input which offers the most probable character combination after every keystroke. The probability of a character combination is defined to be the sum of the probabilities of all words in the dictionary that begin with
 this character combination. For example, if the dictionary contains three words &quot;hell&quot;, &quot;hello&quot;, and &quot;hellfire&quot;, the probability of the character combination &quot;hell&quot; is the sum of the probabilities of these words. If some combinations have the same probability,
 your program is to select the first one in alphabetic order. The user should also be able to type the beginning of words. For example, if the word &quot;hello&quot; is in the dictionary, the user can also enter the word &quot;he&quot; by pressing the keys 4 and 3 even if this
 word is not listed in the dictionary.<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
The first line contains the number of scenarios.<br>
<br>
Each scenario begins with a line containing the number w of distinct words in the dictionary (0&lt;=w&lt;=1000). These words are given in the next w lines. (They are not guaranteed in ascending alphabetic order, although it's a dictionary.) Every line starts with
 the word which is a sequence of lowercase letters from the alphabet without whitespace, followed by a space and an integer p, 1&lt;=p&lt;=100, representing the probability of that word. No word will contain more than 100 letters.<br>
<br>
Following the dictionary, there is a line containing a single integer m. Next follow m lines, each consisting of a sequence of at most 100 decimal digits 2-9, followed by a single 1 meaning &quot;next word&quot;.<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
The output for each scenario begins with a line containing &quot;Scenario #i:&quot;, where i is the number of the scenario starting at 1.<br>
<br>
For every number sequence s of the scenario, print one line for every keystroke stored in s, except for the 1 at the end. In this line, print the most probable word prefix defined by the probabilities in the dictionary and the T9 selection rules explained above.
 Whenever none of the words in the dictionary match the given number sequence, print &quot;MANUALLY&quot; instead of a prefix.<br>
<br>
Terminate the output for every number sequence with a blank line, and print an additional blank line at the end of every scenario.<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">2
5
hell 3
hello 4
idea 8
next 8
super 3
2
435561
43321
7
another 5
contest 6
follow 3
give 13
integer 6
new 14
program 4
5
77647261
6391
4681
26684371
77771</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">Scenario #1:
i
id
hel
hell
hello

i
id
ide
idea


Scenario #2:
p
pr
pro
prog
progr
progra
program

n
ne
new

g
in
int

c
co
con
cont
anoth
anothe
another

p
pr
MANUALLY
MANUALLY</div></pre>
</div>
<br>
<p></p>
<p><br>
</p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#6600cc"><strong>1.建立字典树，把每个字典单词都存入字典树</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px"></span></p>
<p><span style="font-family:KaiTi_GB2312"><span style="font-size:18px; color:rgb(255,0,0)"><strong>注意</strong></span><span style="font-size:18px; color:rgb(255,102,0)"><strong>：</strong></span><span style="color:#ff6600; font-size:18px"><strong>题目中说</strong></span><span style="font-family:'Times New Roman'"><span style="font-size:14px">For
 example, if the dictionary contains three words &quot;hell&quot;, &quot;hello&quot;, and &quot;hellfire&quot;, the probability of the character combination &quot;hell&quot; is</span><span style="color:#ff0000"><strong><em><u> the sum</u></em></strong></span><span style="font-size:14px"> of the probabilities
 of these words</span></span></span></p>
<p style="font-weight:bold"><span style="font-family:KaiTi_GB2312; font-size:18px"><strong><span style="font-family:'Times New Roman'; font-size:14px"><span style="color:#ff6600">所以建立字典树时多次次出现的字符</span><span style="color:#6633ff">，优先级要累加</span><span style="color:#ff6600">
 ，一开始没看清题目，一直错误的以为是只要有优先级高的，替换原来的优先级<img alt="大哭" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/wail.gif">，</span></span></strong></span></p>
<p style="font-weight:bold"><span style="font-family:KaiTi_GB2312; font-size:18px"><strong><span style="font-family:'Times New Roman'; font-size:14px"><span style="color:#ff6600">实在WA的受不了看了别人的代码，自己一开始写的也比较乱</span></span></strong></span></p>
<br>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#6600cc"><strong>2.接受按键字符串，循环从第一个字符到后一个字符（除去1）；</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#6600cc"><strong>3 dfs 参数：int &nbsp;len 当前所要搜索的长度，</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#6600cc"><strong><span style="white-space:pre"></span>&nbsp; &nbsp; int &nbsp;cur 当前已经搜索的长度</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#6600cc"><strong><span style="white-space:pre"></span>&nbsp; &nbsp; Tire * p 当前所在结点</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#6600cc"><strong>4.每搜索到一个字母，将其存入 find[cur]，然后cur&#43;1；</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#6600cc"><strong>当 cur == len 时，返回当前结点的优先级最高的find[]</strong></span></p>
<p><br>
</p>
<p></p>
<pre name="code" class="cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
const int N = 102;

typedef struct Tire
{
	Tire * child[26];
	int pro;
}Tire;

Tire * root;    int Max;         char key[N],ans[N],find[N];

void insert(char * s,int pr)
{
	Tire * p, * q = root;
	for(int i=0;i&lt;strlen(s);i++){	
		if(q-&gt;child[s[i]-'a']) {
			q = q-&gt;child[s[i]-'a'];
			q-&gt;pro += pr;//优先级累加
		}
		else{
			p = (Tire *)malloc(sizeof(Tire));
			for(int j=0;j&lt;26;j++) p-&gt;child[j] = NULL;
			p-&gt;pro = pr;//新结点直接把优先级赋值
			
			q-&gt;child[s[i]-'a'] = p;
			q = p;
		}	
	}
}

void dfs(int len,int cur,Tire *p)
{
	int i,x,y;
	if(cur == len)
	{
		if(p-&gt;pro &gt; Max) //总是存优先级最高的
		{
			Max = p-&gt;pro;
			for(i=0; i&lt;len;i++)   ans[i] = find[i];
			ans[i] = '\0';
		}
		return;
	}
	int k = key[cur]-'0';
	switch(k)
	{
		case 2: x=0; y=2; break;
		case 3: x=3; y=5; break;
		case 4: x=6; y=8; break;
		case 5: x=9; y=11; break;
		case 6: x=12; y=14; break;
		case 7: x=15; y=18; break;
		case 8: x=19; y=21; break;
		case 9: x=22; y=25; break;
	}
	for(i=x;i&lt;=y;i++){
		if(p-&gt;child[i]==NULL) continue;
		find[cur] = i+'a';
		dfs(len,cur+1,p-&gt;child[i]);
	}
}
int main()
{
	int t,w,m,i,pr,Case;
	char s[N];
	
	scanf(&quot;%d&quot;,&amp;Case);
	for(t=1;t&lt;=Case;t++)
	{
		root = (Tire *)malloc(sizeof(Tire));
		for(i=0;i&lt;26;i++) root-&gt;child[i] = NULL;
		scanf(&quot;%d&quot;,&amp;w);
		while(w--){
			scanf(&quot;%s%d&quot;,s,&amp;pr);
			insert(s,pr);
		}
		scanf(&quot;%d&quot;,&amp;m);
		printf(&quot;Scenario #%d:\n&quot;,t);
		while(m--){
			scanf(&quot;%s&quot;,key);
			for(i=1;i&lt;strlen(key);i++){
				Max = 0;
				dfs(i,0,root);
				if(Max == 0) printf(&quot;MANUALLY\n&quot;);
				else puts(ans);
			}
			puts(&quot;&quot;);
		}
		puts(&quot;&quot;);
	}
	return 0;
}</pre><br>
<br>
<p></p>
<p><br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1078FatMouse_and_Cheese（记忆搜索）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/09/hdu_题目1078FatMouse_and_Cheese（记忆搜索）/">hdu 题目1078FatMouse and Cheese（记忆搜索）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">FatMouse and Cheese</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 3706&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1472<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">FatMouse has stored some cheese in a city. The city can be considered as a square grid of dimension n: each grid location is labelled (p,q) where 0 &lt;= p &lt; n and 0 &lt;= q &lt; n. At each grid location Fatmouse has hid between 0 and 100
 blocks of cheese in a hole. Now he's going to enjoy his favorite food.<br>
<br>
FatMouse begins by standing at location (0,0). He eats up the cheese where he stands and then runs either horizontally or vertically to another location. The problem is that there is a super Cat named Top Killer sitting near his hole, so each time he can run
 at most k locations to get into the hole before being caught by Top Killer. What is worse -- after eating up the cheese at one location, FatMouse gets fatter. So in order to gain enough energy for his next run, he has to run to a location which have more blocks
 of cheese than those that were at the current hole.<br>
<br>
Given n, k, and the number of blocks of cheese at each grid location, compute the maximum amount of cheese FatMouse can eat before being unable to move.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">There are several test cases. Each test case consists of<br>
<br>
a line containing two integers between 1 and 100: n and k <br>
n lines, each with n numbers: the first line contains the number of blocks of cheese at locations (0,0) (0,1) ... (0,n-1); the next line contains the number of blocks of cheese at locations (1,0), (1,1), ... (1,n-1), and so on.<br>
The input ends with a pair of -1's. <br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each test case output in a line the single integer giving the number of blocks of cheese collected.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">3 1
1 2 5
10 11 6
12 12 7
-1 -1</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">37</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>类&#20284;于POJ1088 滑雪问题，也是经典记忆搜索，</p>
<pre class="cpp" name="code">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
#define N 110
int n,k;

int a[N][N],v[N][N];

int DFS(int i,int j)
{
	
	if(v[i][j]) return v[i][j];//上次的记忆
	
	int temp,max=0,x;
	for(x=1;x&lt;=k;x++)//四个方向各走x步，找最大值 
	{
		if(i+x&lt;n &amp;&amp; a[i+x][j]&gt;a[i][j]   ){
			temp = DFS(i+x,j) ;
			max = temp&gt;max?temp:max;
		}
		if(j+x&lt;n &amp;&amp; a[i][j+x]&gt;a[i][j] ){
			temp = DFS(i,j+x) ;
			max = temp&gt;max?temp:max;
		}
		if(i-x&gt;=0 &amp;&amp; a[i-x][j]&gt;a[i][j] ){
			temp = DFS(i-x,j) ;
			max = temp&gt;max?temp:max;
		}
		if(j-x&gt;=0 &amp;&amp; a[i][j-x]&gt;a[i][j] ){
			temp = DFS(i,j-x) ;
			max = temp&gt;max?temp:max;
		}	
	}
		
	v[i][j] = max+ a[i][j];//记录当前点到四个方向的最大值
	return  v[i][j];
	
}

int main()
{
	int i,j;
	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k),n!=-1 &amp;&amp; k!=-1)	
	{	
		for(i=0;i&lt;n;i++) 
			for(j=0;j&lt;n;j++)
				scanf(&quot;%d&quot;,&amp;a[i][j]);
		int temp,max=0;
		memset(v,0,sizeof(v));
		temp = DFS(0,0);//qidian
		printf(&quot;%d\n&quot;,temp);
	}
	return 0;
}</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1010_Tempter_of_the_Bone（DFS_奇偶剪枝）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/09/hdu_题目1010_Tempter_of_the_Bone（DFS_奇偶剪枝）/">hdu 题目1010 Tempter of the Bone（DFS+奇偶剪枝）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">Tempter of the Bone</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 54205&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 14593<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately
 to get out of this maze.<br>
<br>
The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the
 T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for
 more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively.
 The next N lines give the maze layout, with each line containing M characters. A character is one of the following:<br>
<br>
'X': a block of wall, which the doggie cannot enter; <br>
'S': the start point of the doggie; <br>
'D': the Door; or<br>
'.': an empty block.<br>
<br>
The input is terminated with three 0's. This test case is not to be processed.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each test case, print in one line &quot;YES&quot; if the doggie can survive, or &quot;NO&quot; otherwise.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">4 4 5
S.X.
..X.
..XD
....
3 4 5
S.X.
..X.
...D
0 0 0</div></pre>
</div>
<div class="panel_bottom">&nbsp;<br>
</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">NO
YES</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>DFS&#43;奇偶剪枝：</p>
<p>1.先按照原来的DFS来写，最后加上奇偶剪枝的条件</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

char a[9][9];
bool vis[9][9],flag;
int m,n,e_x,e_y;

void DFS(int x,int y,int step)
{
    if(flag || x&lt;0 || x&gt;=n || y&lt;0 || y&gt;=m ) return;//已到达终点后面不需再判断
  
    if(step==0 &amp;&amp; a[x][y]=='D') { flag=1;  return;}//到达终点
    
    if(step&lt; abs(x-e_x)+abs(y-e_y) || (step-(abs(x-e_x)+abs(y-e_y))&amp;1)) return ;//奇偶剪枝
    
    if(!vis[x+1][y] &amp;&amp; a[x+1][y]!='X') 
	{  vis[x+1][y]=1;  DFS(x+1,y,step-1); vis[x+1][y]=0; }
	
    if(!vis[x][y+1] &amp;&amp; a[x][y+1]!='X')
	{  vis[x][y+1]=1;  DFS(x,y+1,step-1); vis[x][y+1]=0; } 
	
    if(!vis[x-1][y] &amp;&amp; a[x-1][y]!='X') 
	{ vis[x-1][y]=1;   DFS(x-1,y,step-1); vis[x-1][y]=0;}
	
    if(!vis[x][y-1] &amp;&amp; a[x][y-1]!='X') 
	{ vis[x][y-1]=1;   DFS(x,y-1,step-1); vis[x][y-1]=0;}
}

int main()
{
    int t,i,j,s_x,s_y;
    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t),!(n==0&amp;&amp;m==0&amp;&amp;t==0))
    {
        getchar();//吸收回车 
        
        for(i=0;i&lt;n;i++){
            for(j=0;j&lt;m;j++){
                a[i][j] = getchar();
                if(a[i][j]=='S'){ s_x = i; s_y = j;}//起点位置
                if(a[i][j]=='D'){ e_x = i; e_y = j;} //终点位置
            }  getchar();//吸收回车 
        }

        flag=0;	memset(vis,0,sizeof(vis));  
	vis[s_x][s_y]=1; //!!!!!!!!!起点置1 ，这一点在开始忘了</pre><pre class="cpp" name="code">
        DFS(s_x,s_y,t); 
		 
        if(flag) printf(&quot;YES\n&quot;);
        else printf(&quot;NO\n&quot;);
    }
    return 0;
}</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-POJ_题目1088_滑雪（记忆搜索）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/09/POJ_题目1088_滑雪（记忆搜索）/">POJ 题目1088 滑雪（记忆搜索）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<div lang="en-US" class="ptt" align="center"><span style="font-size:24px; color:#3366ff"><strong>滑雪</strong></span></div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><span style="color:#009900"><strong>Time Limit:</strong> 1000MS</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Memory Limit:</strong> 65536K</span></td>
</tr>
<tr>
<td><span style="color:#009900"><strong>Total Submissions:</strong> 67994</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Accepted:</strong> 25014</span></td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div lang="en-US" class="ptx">Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子
<br>
<pre> 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9</pre>
<br>
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。</div>
<p class="pst">Input</p>
<div lang="en-US" class="ptx">输入的第一行表示区域的行数R和列数C(1 &lt;= R,C &lt;= 100)。下面是R行，每行有C个整数，代表高度h，0&lt;=h&lt;=10000。</div>
<p class="pst">Output</p>
<div lang="en-US" class="ptx">输出最长区域的长度。</div>
<p class="pst">Sample Input</p>
<pre class="sio">5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
</pre>
<p>&nbsp;</p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#cc6600"><strong>1.从每个点都要搜索，将该点四个方向搜素的最大长度 记录在vis[][],相应的位置，如：（1,1）点（17那个） 四个方向最大长度为 3，则在vis[1][1]中存3</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#cc6600"><strong>2,.注意每次都要几率最大&#20540;max，并且，每次更新</strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px; color:#cc6600"><strong>3.超出边界的情况</strong></span></p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int R,C;
int a[101][101],vis[101][101];

int DFS(int i,int j)
{
	int max=0,tem=0;
	if(i&lt;0 || i+1 &gt;R || j&lt;0 || j+1&gt; C) return 0;
	
	if(vis[i][j]) return vis[i][j];
	
	if( a[i+1][j] &lt;a[i][j] )
	{
		tem = DFS(i+1,j);
		max = max&gt;tem?max:tem;
	}
	if( a[i-1][j] &lt;a[i][j] )
	{
		tem = DFS(i-1,j);
		max = max&gt;tem?max:tem;
	}
	if( a[i][j-1] &lt;a[i][j] )
	{
		tem = DFS(i,j-1);
		max = max&gt;tem?max:tem;
	}
	if( a[i][j+1] &lt;a[i][j] )
	{
		tem = DFS(i,j+1);
		max = max&gt;tem?max:tem;
	}
	
	return  vis[i][j] = max+1;
	
}
int main()
{
	int i,j,max,tem;
	while(scanf(&quot;%d%d&quot;,&amp;R,&amp;C)!=EOF)
	{
		memset(vis,0,sizeof(vis));
		memset(a,0,sizeof(a));
		for(i=0;i&lt;R;i++)
			for(j=0;j&lt;C;j++)
				scanf(&quot;%d&quot;,&amp;a[i][j]);
		max = 0;
		for(i=0;i&lt;R;i++)
			for(j=0;j&lt;C;j++)
			{
				tem = DFS(i,j);
				max = max&gt;tem?max:tem;	
			}
		printf(&quot;%d\n&quot;,max);
	} 
	return 0;
}</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-POJ_题目1579_Function_Run_Fun（记忆搜索）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/09/POJ_题目1579_Function_Run_Fun（记忆搜索）/">POJ 题目1579 Function Run Fun（记忆搜索）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div lang="en-US" class="ptt" align="center"><span style="font-size:24px; color:#3366ff"><strong>Function Run Fun</strong></span></div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><span style="color:#009900"><strong>Time Limit:</strong> 1000MS</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Memory Limit:</strong> 10000K</span></td>
</tr>
<tr>
<td><span style="color:#009900"><strong>Total Submissions:</strong> 14815</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Accepted:</strong> 7659</span></td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div lang="en-US" class="ptx">We all love recursion! Don't we? <br>
<br>
Consider a three-parameter recursive function w(a, b, c): <br>
<br>
if a &lt;= 0 or b &lt;= 0 or c &lt;= 0, then w(a, b, c) returns: <br>
1 <br>
<br>
if a &gt; 20 or b &gt; 20 or c &gt; 20, then w(a, b, c) returns: <br>
w(20, 20, 20) <br>
<br>
if a &lt; b and b &lt; c, then w(a, b, c) returns: <br>
w(a, b, c-1) &#43; w(a, b-1, c-1) - w(a, b-1, c) <br>
<br>
otherwise it returns: <br>
w(a-1, b, c) &#43; w(a-1, b-1, c) &#43; w(a-1, b, c-1) - w(a-1, b-1, c-1) <br>
<br>
This is an easy function to implement. The problem is, if implemented directly, for moderate values of a, b and c (for example, a = 15, b = 15, c = 15), the program takes hours to run because of the massive recursion.
<br>
</div>
<p class="pst">Input</p>
<div lang="en-US" class="ptx">The input for your program will be a series of integer triples, one per line, until the end-of-file flag of -1 -1 -1. Using the above technique, you are to calculate w(a, b, c) efficiently and print the result.</div>
<p class="pst">Output</p>
<div lang="en-US" class="ptx">Print the value for w(a,b,c) for each triple.</div>
<p class="pst">Sample Input</p>
<pre class="sio">1 1 1
2 2 2
10 4 6
50 50 50
-1 7 18
-1 -1 -1</pre>
<p class="pst">Sample Output</p>
<pre class="sio">w(1, 1, 1) = 2
w(2, 2, 2) = 4
w(10, 4, 6) = 523
w(50, 50, 50) = 1048576
w(-1, 7, 18) = 1
</pre>
<p>&nbsp;</p>
<p>经典记忆化搜索：就是将每次搜索的结果保存在一个数组内，计算过的结果不必再重复计算；</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int vis[22][22][22];//用来保存每次递归调用的结果

int w(int a,int b,int c)
{
	if (a&lt;=0 || b &lt;= 0 || c&lt;=0) return 1;		
	if (a&gt;20 || b &gt; 20 || c&gt;20)     return	vis[20][20][20] = w(20, 20, 20);//直接返回vis[20][20][20]里面的值 
	if(vis[a][b][c]) return vis[a][b][c];//如果已经计算过，直接返回		
	if (a&lt;b  &amp;&amp; b &lt; c) return	vis[a][b][c] = w(a,b,c-1) + w(a,b-1,c-1) - w(a,b-1,c) ; //每次返回前保存结果在vis[][][];
	else return  vis[a][b][c] = w(a-1,b,c) + w(a-1,b-1,c) + w(a-1,b,c-1) - w(a-1,b-1,c-1); 
}
int main()
{
	int ans,a,b,c;
	while(scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c),!(a==-1&amp;&amp;b==-1&amp;&amp; c==-1))
	{
		memset(vis,0,sizeof(vis));
	
		printf(&quot;w(%d, %d, %d) = %d\n&quot;,a,b,c,w(a,b,c));
	}
	return 0;
}</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  

  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/12/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/14/">Next &raquo;</a>
    </nav>
  


</section>
      </div>
      <footer id="footer">
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      &copy; 2017 <a href="https://github.com/hanks-zyh"> Hanks</a>
	  </div>
  </div>
 <div id="share">
  <a id="totop" title="" style="display: block;">返回顶部</a>
 </div>
</footer>

    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
