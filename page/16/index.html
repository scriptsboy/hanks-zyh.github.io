<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hanks&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="android,web,node,python">
<meta property="og:type" content="website">
<meta property="og:title" content="Hanks' Blog">
<meta property="og:url" content="http://hanks.pub/page/16/index.html">
<meta property="og:site_name" content="Hanks' Blog">
<meta property="og:description" content="android,web,node,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hanks' Blog">
<meta name="twitter:description" content="android,web,node,python">
  
  
    <link rel="icon" href="/images/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'> -->
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo"></a>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      
        <a class="main-nav-link" href="/archives">归档</a>
      
        <a class="main-nav-link" href="/daily">日报</a>
      
        <a class="main-nav-link" href="/eye-video">开眼</a>
      
        <a class="main-nav-link" href="/joke">joke</a>
      
        <a class="main-nav-link" href="/picture-fight">斗图</a>
      
        <a class="main-nav-link" href="/atom.xml">RSS</a>
      
    </nav>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/daily" class="mobile-nav-link">日报</a>
  
    <a href="/eye-video" class="mobile-nav-link">开眼</a>
  
    <a href="/joke" class="mobile-nav-link">joke</a>
  
    <a href="/picture-fight" class="mobile-nav-link">斗图</a>
  
    <a href="/atom.xml" class="mobile-nav-link">RSS</a>
  
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="info">
     <div class="content">
       <div>
         <a href="https://github.com/hanks-zyh"><img class="avatar" src="https://avatars2.githubusercontent.com/u/6268322?v=3&s=460" alt="" /></a>
       </div>
       <div class="name">
         <h2 >Hanks</h2>
       </div>
       <p>‭100100011101‬</p>
       <div class="account">
         <div class="account-item">
           <a href="http://weibo.com/u/2359002991"><img src="http://ww1.sinaimg.cn/large/8c9b876fjw1f3ik9y4q7hj205k05kdfx.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
              <a href="http://www.zhihu.com/people/yuhan-zhang-36"><img src="http://ww2.sinaimg.cn/large/8c9b876fjw1f3ik7sv63wj205k05k3yg.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
           <a href="https://github.com/hanks-zyh"> <img src="http://ww1.sinaimg.cn/large/8c9b876fly1fe196fbtiqj205k05ka9u.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
       </div>
     </div>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">最新发布</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/28/lua-in-android/">探究 lua 在 Android 中的应用</a>
          </li>
        
          <li>
            <a href="/2017/03/26/node-image-recognition/">Node 识别图片中的文字</a>
          </li>
        
          <li>
            <a href="/2017/03/22/proxy-test/">请求代理</a>
          </li>
        
          <li>
            <a href="/2017/02/16/android-customview-inputmethod/">Android 自定义 view 连接输入法</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-lua/">Android 与 Lua</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-markdown-render/">Android 下 Markdown 渲染</a>
          </li>
        
          <li>
            <a href="/2017/01/09/android-webview-font/">Android 中 webview 自定义字体</a>
          </li>
        
          <li>
            <a href="/2016/09/25/slack-bot/">slack bot</a>
          </li>
        
          <li>
            <a href="/2016/09/19/webapp/">让网页更适配移动设备</a>
          </li>
        
          <li>
            <a href="/2016/09/05/weex-2333/">体验 weex —— 写一个表情包应用</a>
          </li>
        
          <li>
            <a href="/2016/08/31/nestedscrollchild/">WebView 实现 NestedScrollingChild</a>
          </li>
        
          <li>
            <a href="/2016/08/29/nestedchildparent/">NestedScrollingParent 实现复杂交互效果</a>
          </li>
        
          <li>
            <a href="/2016/08/04/telegram-bot/">写一个福利 Telegram 机器人</a>
          </li>
        
          <li>
            <a href="/2016/07/31/write-butterkinfe/">写一个 ButterKnife</a>
          </li>
        
          <li>
            <a href="/2016/07/24/edittext-cursor/">多行 EditText 的光标高度问题</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Atom/" style="font-size: 10px;">Atom</a> <a href="/tags/Dagger2/" style="font-size: 10px;">Dagger2</a> <a href="/tags/EditText/" style="font-size: 10px;">EditText</a> <a href="/tags/Express/" style="font-size: 11.67px;">Express</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/Framework/" style="font-size: 11.67px;">Framework</a> <a href="/tags/HTML-CSS/" style="font-size: 10px;">HTML/CSS</a> <a href="/tags/Jade/" style="font-size: 10px;">Jade</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/LAMP/" style="font-size: 10px;">LAMP</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Lua/" style="font-size: 11.67px;">Lua</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/NestedScrolling/" style="font-size: 13.33px;">NestedScrolling</a> <a href="/tags/Node-js/" style="font-size: 13.33px;">Node.js</a> <a href="/tags/OS-X/" style="font-size: 10px;">OS X</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Python/" style="font-size: 11.67px;">Python</a> <a href="/tags/React-Native/" style="font-size: 18.33px;">React-Native</a> <a href="/tags/Refactoring/" style="font-size: 10px;">Refactoring</a> <a href="/tags/Rx/" style="font-size: 10px;">Rx</a> <a href="/tags/RxJava/" style="font-size: 13.33px;">RxJava</a> <a href="/tags/Rxandroid/" style="font-size: 10px;">Rxandroid</a> <a href="/tags/Rxjava/" style="font-size: 11.67px;">Rxjava</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Scrapy/" style="font-size: 11.67px;">Scrapy</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/SwipeRefreshLayout/" style="font-size: 10px;">SwipeRefreshLayout</a> <a href="/tags/Telegram/" style="font-size: 10px;">Telegram</a> <a href="/tags/TextView/" style="font-size: 10px;">TextView</a> <a href="/tags/Ubuntu/" style="font-size: 16.67px;">Ubuntu</a> <a href="/tags/VPS/" style="font-size: 10px;">VPS</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/WebView/" style="font-size: 11.67px;">WebView</a> <a href="/tags/bot/" style="font-size: 10px;">bot</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/interpolator/" style="font-size: 10px;">interpolator</a> <a href="/tags/leancloud/" style="font-size: 10px;">leancloud</a> <a href="/tags/mac-os/" style="font-size: 10px;">mac os</a> <a href="/tags/slack/" style="font-size: 10px;">slack</a> <a href="/tags/virtualBox/" style="font-size: 10px;">virtualBox</a> <a href="/tags/weex/" style="font-size: 10px;">weex</a> <a href="/tags/代理/" style="font-size: 10px;">代理</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/学习/" style="font-size: 10px;">学习</a> <a href="/tags/必备知识/" style="font-size: 10px;">必备知识</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/热修复/" style="font-size: 11.67px;">热修复</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/自动化/" style="font-size: 10px;">自动化</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/hanks-zyh">hanks-zyh</a>
          </li>
        
          <li>
            <a href="http://kiya.space">Kiya‘s space</a>
          </li>
        
          <li>
            <a href="http://rocko.xyz/">Rocko&#39;s blog</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="wx">
      <h3 class="widget-title">微信公众号</h3>
      <img src='http://ww1.sinaimg.cn/large/8c9b876fly1fe0nnlvokpj20by0bywfi.jpg' height="100%" width="100%" >
      <p>搜索公众号: CodeProvider</p>
    </div>
  </div>


  
</aside>
        
        <section id="main" class="mdl-shadow--2dp">
  
    <article id="post-贪心——HDU题目1009_FatMouse&#39;_Trade" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/26/贪心——HDU题目1009_FatMouse'_Trade/">贪心——HDU题目1009 FatMouse&#39; Trade</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 style="color:#1a5cc8">FatMouse' Trade</h1>
<p><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 33504&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 10897<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br>
The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of
 cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case
 is followed by two -1's. All integers are not greater than 1000.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">5 3
7 2
4 3
5 2
20 3
25 18
24 15
15 10</div><div style="font-family:Courier New,Courier,monospace">1 0</div><div style="font-family:Courier New,Courier,monospace">0 1</div><div style="font-family:Courier New,Courier,monospace">1 0</div><div style="font-family:Courier New,Courier,monospace">-1 -1</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">13.333
31.500</div><div style="font-family:Courier New,Courier,monospace">0.000</div><div style="font-family:Courier New,Courier,monospace">1.000</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p>类&#20284;于0-1背包问题<br>
</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;

using namespace std;

typedef struct ROOM
{
    int j,f;
}ROOM;
ROOM room[10001];

bool cmp(ROOM a,ROOM b)
{
    return 1.0*a.j/a.f &gt; 1.0*b.j/b.f;    
}
int main()
{
    int n,m,i;
    double max;
    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n) &amp;&amp; (m!=-1||n!=-1))
    {
        if(n==0)//zhe里是特殊情况 
        {
            printf(&quot;0.000\n&quot;);continue;    
        }
        for(i=0;i&lt;n;i++) 
            scanf(&quot;%d%d&quot;,&amp;room[i].j,&amp;room[i].f);    
        sort(room,room+n,cmp);
        //for(i=0;i&lt;n;i++)
        //    printf(&quot;%d %d\n&quot;,room[i].j,room[i].f);
        max = i = 0;
        if(m==0)//第一次提交没考虑特殊情况
        {
            if(room[i].f==0)
            {
                max+=room[i].j;    
            }    
            i++;
        }
        while(m)
        {
            if(m&gt;=room[i].f)
            {
                max += room[i].j;    
                m -= room[i].f;
            }
            else
            {
                max += 1.0 * room[i].j/room[i].f *m;    
                m=0;    
            }
            i++;
        }
        printf(&quot;%.3lf\n&quot;,max);
    }
    return 0;
}
</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-贪心——NYOJ_题目236_心急的C小加" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/25/贪心——NYOJ_题目236_心急的C小加/">贪心——NYOJ 题目236 心急的C小加</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div class="problem-display">
<h4></h4>
<h2>心急的C小加</h2>
<div class="problem-ins">时间限制：<span id="problem[time_limit]" class="editable highlight">1000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB
</div>
<div class="problem-ins">难度：<span class="editable highlight">4</span></div>
</div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>
<p>C小加有一些木棒，它们的长度和质量都已经知道，需要一个机器处理这些木棒，机器开启的时候需要耗费一个单位的时间，如果第i&#43;1个木棒的重量和长度都大于等于第i个处理的木棒，那么将不会耗费时间，否则需要消耗一个单位的时间。因为急着去约会，C小加想在最短的时间内把木棒处理完，你能告诉他应该怎样做吗？<br>
<br>
</p>
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>第一行是一个整数T(1&lt;T&lt;1500)，表示输入数据一共有T组。<br>
每组测试数据的第一行是一个整数N（1&lt;=N&lt;=5000）,表示有N个木棒。接下来的一行分别输入N个木棒的L，W（0 &lt; L ,W &lt;= 10000），用一个空&#26684;隔开，分别表示木棒的长度和质量。
</dd><dt>输出 </dt><dd>处理这些木棒的最短时间。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">3 
5 
4 9 5 2 2 1 3 5 1 4 
3 
2 2 1 1 2 2 
3 
1 3 2 2 3 1 
</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">2
1
3
</pre>
</dd></dl>
</dd></dl>
<dl>
<p>分析：只要将长度重量排序，找出其中的递增子序列个数即可，</p>
<p>先按长度排序，（长度相等，按重量） 然后看排好序的 数组中 ，只看重量的递增子序列即可（长度已排好序）</p>
<p>重点求递增子序列个数， 求一个数组中递增子序列个数，可以在附加设置一个标志数组flag[],用来标记对应的元素</p>
<p>如 a[8]={2,3,5,4,6,8,7}; </p>
<p>从i=0开始比当前元素大的即与当前元素属于同一个子序列，将当前元素加入到子序列中，并且标记为已读，再<span style="color:#3333ff">继续判读下一个元素是否大于已有子序列最后(最大)一个元素</span>，判断完即可</p>
<p>[code]</p>
<pre class="cpp" name="code"> 

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;

using namespace std;

typedef struct Stick
{
	int L,W;
}Stick;

Stick stick [5001];
bool flag[5001];//标记数组，定义成bool可节省内存，也可减少判断时间

bool cmp(Stick  a,Stick b)//先按长度排序，长度相等按重量排序 
{
	if(a.L==b.L)	return  a.W&lt;b.W ;
	else return a.L&lt;b.L;	
}

int main()
{
	int t,s,n,m,i,j,cnt;
	int value,weight;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
			memset(flag,0,sizeof(flag)); 
            scanf(&quot;%d&quot;,&amp;n);
            for(i=0;i&lt;n;i++)     scanf(&quot;%d%d&quot;,&amp;stick[i].L,&amp;stick[i].W); 
            sort(stick,stick+n,cmp);
			
			//for(i=0;i&lt;n;i++) printf(&quot;L=%d W=%d\n&quot;,stick[i].L,stick[i].W);
			
			cnt = 0;
			for(i=0;i&lt;n;i++) 
			{
			//	printf(&quot;flag=%d\n&quot;,flag[i]);
				if(!flag[i])
				{
					//printf(&quot;**\n&quot;);
					cnt++;
					int last = stick[i].W;//设置子序列为第一个元素 
					for(j=i+1;j&lt;n;j++)
					{
						if(last&lt;=stick[j].W &amp;&amp; !flag[j])//因为是求递增子序列故 stick[j].w 必须大于子序列最后一个元素 
						{
							flag[j]=1;//标记j位置变为已处理木棍	
							last = stick[j].W;//记录递增子序列的最后一个元素 ，将stick[j]添加进来 
						}	
					}	
				}
			}
 
			printf(&quot;%d\n&quot;,cnt);    
    }
   //system(&quot;pause&quot;);
 return 0;    
}        </pre>
<p><br>
&nbsp;</p>
</dl>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-STL中sort函数的用法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/25/STL中sort函数的用法/">STL中sort函数的用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div class="articalTitle">
<h2 id="t_8c9b876f0101dnf0" class="titName SG_txta">
<div id="article_details" class="details">
<div style="clear:both"></div>
<div style="clear:both"></div>
<div id="article_content" class="article_content">
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
<a name="0_STL"></a><a name="0_STL_"></a>0 前言: STL，为什么你必须掌握</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
&nbsp;</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
stable_sort(array,array&#43;n,cmp);</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
sort(array,array&#43;n,cmp);</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
cmp函数的书写，</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
对于结构体</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
bool cmp(STRUCT a, STRUCT b)//STRUCT为结构体leixing名</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
{</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a.aa&gt;b.aa;//这里写条件</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
}</p>
<div class="postText" style="line-height:19px; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; font-size:13px">
<hr>
对于程序员来说，数据结构是必修的一门课。从查找到排序，从链表到二叉树，几乎所有的算法和原理都需要理解，理解不了也要死记硬背下来。幸运的是这些理论都已经比较成熟，算法也基本固定下来，不需要你再去花费心思去考虑其算法原理，也不用再去验证其准确性。不过，等你开始应用计算机语言来工作的时候，你会发现，面对不同的需求你需要一次又一次去用代码重复实现这些已经成熟的算法，而且会一次又一次陷入一些由于自己疏忽而产生的bug中。这时，你想找一种工具，已经帮你实现这些功能，你想怎么用就怎么用，同时不影响性能。你需要的就是STL,
 标准模板库！
<p style="margin-top:10px; margin-bottom:10px">西方有句谚语：不要重复发明轮子！</p>
<p style="margin-top:10px; margin-bottom:10px">STL几乎封装了所有的数据结构中的算法，从链表到队列，从向量到堆栈，对hash到二叉树，从搜索到排序，从增加到删除......可以说，如果你理解了STL，你会发现你已不用拘泥于算法本身，从而站在巨人的肩膀上去考虑更高级的应用。</p>
<p style="margin-top:10px; margin-bottom:10px">排序是最广泛的算法之一，本文详细介绍了STL中不同排序算法的用法和区别。</p>
<h3 style="border-bottom:rgb(214,214,214) 1px dotted; background-color:transparent; font-size:10pt">
<a name="t3"></a><a name="1_STL_Sort"></a><a name="1_STL_Sort_"></a>1 STL提供的Sort 算法</h3>
<hr>
C&#43;&#43;之所以得到这么多人的喜欢，是因为它既具有面向对象的概念，又保持了C语言高效的特点。STL 排序算法同样需要保持高效。因此，对于不同的需求，STL提供的不同的函数，不同的函数，实现的算法又不尽相同。
<h4><a name="t4"></a><a name="1_1_sort"></a><a name="1_1_sort_"></a>1.1 所有sort算法介绍</h4>
所有的sort算法的参数都需要输入一个范围，[begin, end)。这里使用的迭代器(iterator)都需是随机迭代器(RadomAccessIterator), 也就是说可以随机访问的迭代器，如：it&#43;n什么的。（partition 和stable_partition 除外）
<p style="margin-top:10px; margin-bottom:10px">如果你需要自己定义比较函数，你可以把你定义好的仿函数(functor)作为参数传入。每种算法都支持传入比较函数。以下是所有STL sort算法函数的名字列表:
<table border="1" cellspacing="1" cellpadding="0" style="width:841px">
<tbody>
<tr>
<th class="twikiFirstCol" bgcolor="#99cccc"><a title="Sort by this column" href="http://www.stlchina.org/twiki/bin/view.pl/Main/STLSortAlgorithms?sortcol=0&amp;table=1&amp;up=0#sorted_table" style="color:rgb(0,102,170); text-decoration:none" target="_blank" rel="external">函数名</a></th>
<th bgcolor="#99cccc"><a title="Sort by this column" href="http://www.stlchina.org/twiki/bin/view.pl/Main/STLSortAlgorithms?sortcol=1&amp;table=1&amp;up=0#sorted_table" style="color:rgb(0,102,170); text-decoration:none" target="_blank" rel="external">功能描述</a></th>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffff">sort</td>
<td bgcolor="#ffffff">对给定区间所有元素进行排序</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffcc">stable_sort</td>
<td bgcolor="#ffffcc">对给定区间所有元素进行稳定排序</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffff">partial_sort</td>
<td bgcolor="#ffffff">对给定区间所有元素部分排序</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffcc">partial_sort_copy</td>
<td bgcolor="#ffffcc">对给定区间复制并排序</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffff">nth_element</td>
<td bgcolor="#ffffff">找出给定区间的某个位置对应的元素</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffcc">is_sorted</td>
<td bgcolor="#ffffcc">判断一个区间是否已经排好序</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffff">partition</td>
<td bgcolor="#ffffff">使得符合某个条件的元素放在前面</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffcc">stable_partition</td>
<td bgcolor="#ffffcc">相对稳定的使得符合某个条件的元素放在前面</td>
</tr>
</tbody>
</table>
其中nth_element 是最不易理解的，实际上，这个函数是用来找出第几个。例如：找出包含7个元素的数组中排在中间那个数的&#20540;，此时，我可能不关心前面，也不关心后面，我只关心排在第四位的元素&#20540;是多少。</p>
<h4><a name="t5"></a><a name="1_2_sort"></a><a name="1_2_sort_"></a>1.2 sort 中的比较函数</h4>
当你需要按照某种特定方式进行排序时，你需要给sort指定比较函数，否则程序会自动提供给你一个比较函数。
<div class="fragment">
<pre>vector &lt; <span style="color:brown">int</span> &gt; vect;
<span style="color:green">//...</span>
sort(vect.begin(), vect.end());
<span style="color:green">//此时相当于调用</span>
sort(vect.begin(), vect.end(), less&lt;<span style="color:brown">int</span>&gt;() );</pre>
<pre></pre>
</div>
上述例子中系统自己为sort提供了less仿函数。在STL中还提供了其他仿函数，以下是仿函数列表:
<table border="1" cellspacing="1" cellpadding="0" style="width:841px">
<tbody>
<tr>
<th class="twikiFirstCol" bgcolor="#99cccc"><a title="Sort by this column" href="http://www.stlchina.org/twiki/bin/view.pl/Main/STLSortAlgorithms?sortcol=0&amp;table=2&amp;up=0#sorted_table" style="color:rgb(0,102,170); text-decoration:none" target="_blank" rel="external">名称</a></th>
<th bgcolor="#99cccc"><a title="Sort by this column" href="http://www.stlchina.org/twiki/bin/view.pl/Main/STLSortAlgorithms?sortcol=1&amp;table=2&amp;up=0#sorted_table" style="color:rgb(0,102,170); text-decoration:none" target="_blank" rel="external">功能描述</a></th>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffff">equal_to</td>
<td bgcolor="#ffffff">相等</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffcc">not_equal_to</td>
<td bgcolor="#ffffcc">不相等</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffff">less</td>
<td bgcolor="#ffffff">小于</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffcc">greater</td>
<td bgcolor="#ffffcc">大于</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffff">less_equal</td>
<td bgcolor="#ffffff">小于等于</td>
</tr>
<tr>
<td class="twikiFirstCol" bgcolor="#ffffcc">greater_equal</td>
<td bgcolor="#ffffcc">大于等于</td>
</tr>
</tbody>
</table>
需要注意的是，这些函数不是都能适用于你的sort算法，如何选择，决定于你的应用。另外，不能直接写入仿函数的名字，而是要写其重载的()函数：
<pre>less&lt;int&gt;()
greater&lt;int&gt;()
</pre>
当你的容器中元素时一些标准类型（int float char)或者string时，你可以直接使用这些函数模板。但如果你时自己定义的类型或者你需要按照其他方式排序，你可以有两种方法来达到效果：一种是自己写比较函数。另一种是重载类型的'&lt;'操作赋。
<div class="fragment">
<pre><span style="color:navy">#include</span> &lt;iostream&gt;
<span style="color:navy">#include</span> &lt;algorithm&gt;
<span style="color:navy">#include</span> &lt;functional&gt;
<span style="color:navy">#include</span> &lt;vector&gt;
<span style="color:brown">using</span> <span style="color:brown">namespace</span> std;

<span style="color:brown">class</span> myclass {
        <span style="color:brown">public</span>:
        myclass(<span style="color:brown">int</span> a, <span style="color:brown">int</span> b):first(a), second(b){}
        <span style="color:brown">int</span> first;
        <span style="color:brown">int</span> second;
        <span style="color:brown">bool</span> <span style="color:brown">operator</span> &lt; (<span style="color:brown">const</span> myclass &amp;m)<span style="color:brown">const</span> {
                <span style="color:brown">return</span> first &lt; m.first;
        }
};

<span style="color:brown">bool</span> less_second(<span style="color:brown">const</span> myclass &amp; m1, <span style="color:brown">const</span> myclass &amp; m2) {
        <span style="color:brown">return</span> m1.second &lt; m2.second;
}

<span style="color:brown">int</span> main() {

        vector&lt; myclass &gt; vect;
        <span style="color:brown">for</span>(<span style="color:brown">int</span> i = 0 ; i &lt; 10 ; i &#43;&#43;){
                myclass my(10-i, i*3);
                vect.push_back(my);
        }
        <span style="color:brown">for</span>(<span style="color:brown">int</span> i = 0 ; i &lt; vect.size(); i &#43;&#43;)
        cout&lt;&lt;&quot;<span style="color:blue">(</span>&quot;&lt;&lt;vect[i].first&lt;&lt;&quot;<span style="color:blue">,</span>&quot;&lt;&lt;vect[i].second&lt;&lt;&quot;<span style="color:blue">)\n</span>&quot;;
        sort(vect.begin(), vect.end());
        cout&lt;&lt;&quot;<span style="color:blue">after sorted by first:</span>&quot;&lt;&lt;endl;
        <span style="color:brown">for</span>(<span style="color:brown">int</span> i = 0 ; i &lt; vect.size(); i &#43;&#43;)
        cout&lt;&lt;&quot;<span style="color:blue">(</span>&quot;&lt;&lt;vect[i].first&lt;&lt;&quot;<span style="color:blue">,</span>&quot;&lt;&lt;vect[i].second&lt;&lt;&quot;<span style="color:blue">)\n</span>&quot;;
        cout&lt;&lt;&quot;<span style="color:blue">after sorted by second:</span>&quot;&lt;&lt;endl;
        sort(vect.begin(), vect.end(), less_second);
        <span style="color:brown">for</span>(<span style="color:brown">int</span> i = 0 ; i &lt; vect.size(); i &#43;&#43;)
        cout&lt;&lt;&quot;<span style="color:blue">(</span>&quot;&lt;&lt;vect[i].first&lt;&lt;&quot;<span style="color:blue">,</span>&quot;&lt;&lt;vect[i].second&lt;&lt;&quot;<span style="color:blue">)\n</span>&quot;;

        <span style="color:brown">return</span> 0 ;
}</pre>
<pre></pre>
</div>
知道其输出结果是什么了吧：
<pre>(10,0)
(9,3)
(8,6)
(7,9)
(6,12)
(5,15)
(4,18)
(3,21)
(2,24)
(1,27)
after sorted by first:
(1,27)
(2,24)
(3,21)
(4,18)
(5,15)
(6,12)
(7,9)
(8,6)
(9,3)
(10,0)
after sorted by second:
(10,0)
(9,3)
(8,6)
(7,9)
(6,12)
(5,15)
(4,18)
(3,21)
(2,24)
(1,27)
</pre>
<h4><a name="t6"></a><a name="1_3_sort"></a><a name="1_3_sort_"></a>1.3 sort 的稳定性</h4>
你发现有sort和stable_sort，还有 partition 和stable_partition， 感到奇怪吧。其中的区别是，带有stable的函数可保证相等元素的原本相对次序在排序后保持不变。或许你会问，既然相等，你还管他相对位置呢，也分不清楚谁是谁了？这里需要弄清楚一个问题，这里的相等，是指你提供的函数表示两个元素相等，并不一定是一摸一样的元素。
<p style="margin-top:10px; margin-bottom:10px">例如，如果你写一个比较函数:</p>
<div class="fragment">
<pre><span style="color:brown">bool</span> less_len(<span style="color:brown">const</span> string &amp;str1, <span style="color:brown">const</span> string &amp;str2)
{
        <span style="color:brown">return</span> str1.length() &lt; str2.length();
}</pre>
<pre></pre>
</div>
此时，&quot;apple&quot; 和 &quot;winter&quot; 就是相等的，如果在&quot;apple&quot; 出现在&quot;winter&quot;前面，用带stable的函数排序后，他们的次序一定不变，如果你使用的是不带&quot;stable&quot;的函数排序，那么排序完后，&quot;Winter&quot;有可能在&quot;apple&quot;的前面。
<p style="margin-top:10px; margin-bottom:10px"></p>
<h4><a name="t7"></a><a name="1_4"></a><a name="1_4_"></a>1.4 全排序</h4>
全排序即把所给定范围所有的元素按照大小关系顺序排列。用于全排序的函数有
<p style="margin-top:10px; margin-bottom:10px"></p>
<div class="fragment">
<pre><span style="color:brown">template</span> &lt;<span style="color:brown">class</span> RandomAccessIterator&gt;
<span style="color:brown">void</span> sort(RandomAccessIterator first, RandomAccessIterator last);

<span style="color:brown">template</span> &lt;<span style="color:brown">class</span> RandomAccessIterator, <span style="color:brown">class</span> StrictWeakOrdering&gt;
<span style="color:brown">void</span> sort(RandomAccessIterator first, RandomAccessIterator last,
StrictWeakOrdering comp);

<span style="color:brown">template</span> &lt;<span style="color:brown">class</span> RandomAccessIterator&gt;
<span style="color:brown">void</span> stable_sort(RandomAccessIterator first, RandomAccessIterator last);

<span style="color:brown">template</span> &lt;<span style="color:brown">class</span> RandomAccessIterator, <span style="color:brown">class</span> StrictWeakOrdering&gt;
<span style="color:brown">void</span> stable_sort(RandomAccessIterator first, RandomAccessIterator last,
StrictWeakOrdering comp);</pre>
<pre></pre>
</div>
在第1，3种形式中，sort 和 stable_sort都没有指定比较函数，系统会默认使用operator&lt; 对区间[first,last)内的所有元素进行排序, 因此，如果你使用的类型义军已经重载了operator&lt;函数，那么你可以省心了。第2, 4种形式，你可以随意指定比较函数，应用更为灵活一些。来看看实际应用：
<p style="margin-top:10px; margin-bottom:10px">班上有10个学生，我想知道他们的成绩排名。</p>
<div class="fragment">
<pre><span style="color:navy">#include</span> &lt;iostream&gt;
<span style="color:navy">#include</span> &lt;algorithm&gt;
<span style="color:navy">#include</span> &lt;functional&gt;
<span style="color:navy">#include</span> &lt;vector&gt;
<span style="color:navy">#include</span> &lt;string&gt;
<span style="color:brown">using</span> <span style="color:brown">namespace</span> std;

<span style="color:brown">class</span> student{
        <span style="color:brown">public</span>:
        student(<span style="color:brown">const</span> string &amp;a, <span style="color:brown">int</span> b):name(a), score(b){}
        string name;
        <span style="color:brown">int</span> score;
        <span style="color:brown">bool</span> <span style="color:brown">operator</span> &lt; (<span style="color:brown">const</span> student &amp;m)<span style="color:brown">const</span> {
                <span style="color:brown">return</span> score&lt; m.score;
        }
};

<span style="color:brown">int</span> main() {
        vector&lt; student&gt; vect;
        student st1(&quot;<span style="color:blue">Tom</span>&quot;, 74);
        vect.push_back(st1);
        st1.name=&quot;<span style="color:blue">Jimy</span>&quot;;
        st1.score=56;
        vect.push_back(st1);
        st1.name=&quot;<span style="color:blue">Mary</span>&quot;;
        st1.score=92;
        vect.push_back(st1);
        st1.name=&quot;<span style="color:blue">Jessy</span>&quot;;
        st1.score=85;
        vect.push_back(st1);
        st1.name=&quot;<span style="color:blue">Jone</span>&quot;;
        st1.score=56;
        vect.push_back(st1);
        st1.name=&quot;<span style="color:blue">Bush</span>&quot;;
        st1.score=52;
        vect.push_back(st1);
        st1.name=&quot;<span style="color:blue">Winter</span>&quot;;
        st1.score=77;
        vect.push_back(st1);
        st1.name=&quot;<span style="color:blue">Andyer</span>&quot;;
        st1.score=63;
        vect.push_back(st1);
        st1.name=&quot;<span style="color:blue">Lily</span>&quot;;
        st1.score=76;
        vect.push_back(st1);
        st1.name=&quot;<span style="color:blue">Maryia</span>&quot;;
        st1.score=89;
        vect.push_back(st1);
        cout&lt;&lt;&quot;<span style="color:blue">------before sort...</span>&quot;&lt;&lt;endl;
        <span style="color:brown">for</span>(<span style="color:brown">int</span> i = 0 ; i &lt; vect.size(); i &#43;&#43;) cout&lt;&lt;vect[i].name&lt;&lt;&quot;<span style="color:blue">:\t</span>&quot;&lt;&lt;vect[i].score&lt;&lt;endl;
        stable_sort(vect.begin(), vect.end(),less&lt;student&gt;());
        cout &lt;&lt;&quot;<span style="color:blue">-----after sort ....</span>&quot;&lt;&lt;endl;
        <span style="color:brown">for</span>(<span style="color:brown">int</span> i = 0 ; i &lt; vect.size(); i &#43;&#43;) cout&lt;&lt;vect[i].name&lt;&lt;&quot;<span style="color:blue">:\t</span>&quot;&lt;&lt;vect[i].score&lt;&lt;endl;
        <span style="color:brown">return</span> 0 ;
}</pre>
<pre></pre>
</div>
其输出是：
<pre>------before sort...
Tom:    74
Jimy:   56
Mary:   92
Jessy:  85
Jone:   56
Bush:   52
Winter: 77
Andyer: 63
Lily:   76
Maryia: 89
-----after sort ....
Bush:   52
Jimy:   56
Jone:   56
Andyer: 63
Tom:    74
Lily:   76
Winter: 77
Jessy:  85
Maryia: 89
Mary:   92
</pre>
sort采用的是成熟的&quot;快速排序算法&quot;(目前大部分STL版本已经不是采用简单的快速排序，而是结合内插排序算法)。<a class="twikiAnchorLink" href="http://www.stlchina.org/twiki/bin/view.pl/Main/STLSortAlgorithms#MyNote1" style="color:rgb(0,102,170); text-decoration:none" target="_blank" rel="external">注1</a>，可以保证很好的平均性能、复杂度为n*log(n)，由于单纯的快速排序在理论上有最差的情况，性能很低，其算法复杂度为n*n，但目前大部分的STL版本都已经在这方面做了优化，因此你可以放心使用。stable_sort采用的是&quot;归并排序&quot;，分派足够内存是，其算法复杂度为n*log(n),
 否则其复杂度为n*log(n)*log(n)，其优点是会保持相等元素之间的相对位置在排序前后保持一致。
<h4><a name="t8"></a><a name="1_5"></a><a name="1_5_"></a>1.5 局部排序</h4>
局部排序其实是为了减少不必要的操作而提供的排序方式。其函数原型为：
<div class="fragment">
<pre><span style="color:brown">template</span> &lt;<span style="color:brown">class</span> RandomAccessIterator&gt;
<span style="color:brown">void</span> partial_sort(RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last);

<span style="color:brown">template</span> &lt;<span style="color:brown">class</span> RandomAccessIterator, <span style="color:brown">class</span> StrictWeakOrdering&gt;
<span style="color:brown">void</span> partial_sort(RandomAccessIterator first,
RandomAccessIterator middle,
RandomAccessIterator last,
StrictWeakOrdering comp);

<span style="color:brown">template</span> &lt;<span style="color:brown">class</span> InputIterator, <span style="color:brown">class</span> RandomAccessIterator&gt;
RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last);

<span style="color:brown">template</span> &lt;<span style="color:brown">class</span> InputIterator, <span style="color:brown">class</span> RandomAccessIterator,
<span style="color:brown">class</span> StrictWeakOrdering&gt;
RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last,
RandomAccessIterator result_first,
RandomAccessIterator result_last, Compare comp);</pre>
<pre></pre>
</div>
理解了sort 和stable_sort后，再来理解partial_sort 就比较容易了。先看看其用途: 班上有10个学生，我想知道分数最低的5名是哪些人。如果没有partial_sort，你就需要用sort把所有人排好序，然后再取前5个。现在你只需要对分数最低5名排序，把上面的程序做如下修改：
<div class="fragment">
<pre>stable_sort(vect.begin(), vect.end(),less&lt;student&gt;());
替换为：
partial_sort(vect.begin(), vect.begin()&#43;5, vect.end(),less&lt;student&gt;());</pre>
<pre></pre>
</div>
输出结果为：
<pre>------before sort...
Tom:    74
Jimy:   56
Mary:   92
Jessy:  85
Jone:   56
Bush:   52
Winter: 77
Andyer: 63
Lily:   76
Maryia: 89
-----after sort ....
Bush:   52
Jimy:   56
Jone:   56
Andyer: 63
Tom:    74
Mary:   92
Jessy:  85
Winter: 77
Lily:   76
Maryia: 89
</pre>
这样的好处知道了吗？当数据量小的时候可能看不出优势，如果是100万学生，我想找分数最少的5个人......
<p style="margin-top:10px; margin-bottom:10px">partial_sort采用的堆排序（heapsort），它在任何情况下的复杂度都是n*log(n). 如果你希望用partial_sort来实现全排序，你只要让middle=last就可以了。</p>
<p style="margin-top:10px; margin-bottom:10px">partial_sort_copy其实是copy和partial_sort的组合。被排序(被复制)的数量是[first, last)和[result_first, result_last)中区间较小的那个。如果[result_first, result_last)区间大于[first, last)区间，那么partial_sort相当于copy和sort的组合。</p>
<h4><a name="t9"></a><a name="1_6_nth_element"></a><a name="1_6_nth_element_"></a>1.6 nth_element 指定元素排序</h4>
nth_element一个容易看懂但解释比较麻烦的排序。用例子说会更方便：<br>
班上有10个学生，我想知道分数排在倒数第4名的学生。<br>
如果要满足上述需求，可以用sort排好序，然后取第4位（因为是由小到大排), 更聪明的朋友会用partial_sort, 只排前4位，然后得到第4位。其实这是你还是浪费，因为前两位你根本没有必要排序，此时，你就需要nth_element:
<div class="fragment">
<pre><span style="color:brown">template</span> &lt;<span style="color:brown">class</span> RandomAccessIterator&gt;
<span style="color:brown">void</span> nth_element(RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last);

<span style="color:brown">template</span> &lt;<span style="color:brown">class</span> RandomAccessIterator, <span style="color:brown">class</span> StrictWeakOrdering&gt;
<span style="color:brown">void</span> nth_element(RandomAccessIterator first, RandomAccessIterator nth,
RandomAccessIterator last, StrictWeakOrdering comp);</pre>
<pre></pre>
</div>
对于上述实例需求，你只需要按下面要求修改1.4中的程序：
<div class="fragment">
<pre>stable_sort(vect.begin(), vect.end(),less&lt;student&gt;());
替换为：
nth_element(vect.begin(), vect.begin()&#43;3, vect.end(),less&lt;student&gt;());</pre>
<pre></pre>
</div>
运行结果为：
<pre>------before sort...
Tom:    74
Jimy:   56
Mary:   92
Jessy:  85
Jone:   56
Bush:   52
Winter: 77
Andyer: 63
Lily:   76
Maryia: 89
-----after sort ....
Jone:   56
Bush:   52
Jimy:   56
Andyer: 63
Jessy:  85
Mary:   92
Winter: 77
Tom:    74
Lily:   76
Maryia: 89
</pre>
第四个是谁？Andyer，这个倒霉的家伙。为什么是begin()&#43;3而不是&#43;4? 我开始写这篇文章的时候也没有在意，后来在<a href="http://www.stlchina.org/bbs/viewpro.php?uid=350" target="_top" style="color:rgb(0,102,170); text-decoration:none">ilovevc</a>&nbsp;的提醒下，发现了这个问题。begin()是第一个，begin()&#43;1是第二个，... begin()&#43;3当然就是第四个了。
<h4><a name="t10"></a><a name="1_7_partition_stable_partition"></a>1.7 partition 和stable_partition</h4>
好像这两个函数并不是用来排序的，'分类'算法，会更加贴切一些。partition就是把一个区间中的元素按照某个条件分成两类。其函数原型为：
<div class="fragment">
<pre><span style="color:brown">template</span> &lt;<span style="color:brown">class</span> ForwardIterator, <span style="color:brown">class</span> Predicate&gt;
ForwardIterator partition(ForwardIterator first,
ForwardIterator last, Predicate pred)
<span style="color:brown">template</span> &lt;<span style="color:brown">class</span> ForwardIterator, <span style="color:brown">class</span> Predicate&gt;
ForwardIterator stable_partition(ForwardIterator first, ForwardIterator last,
Predicate pred);</pre>
<pre></pre>
</div>
看看应用吧：班上10个学生，计算所有没有及&#26684;（低于60分）的学生。你只需要按照下面&#26684;式替换1.4中的程序：
<div class="fragment">
<pre>stable_sort(vect.begin(), vect.end(),less&lt;student&gt;());
替换为：
student exam(&quot;<span style="color:blue">pass</span>&quot;, 60);
stable_partition(vect.begin(), vect.end(), bind2nd(less&lt;student&gt;(), exam));</pre>
<pre></pre>
</div>
其输出结果为：
<pre>------before sort...
Tom:    74
Jimy:   56
Mary:   92
Jessy:  85
Jone:   56
Bush:   52
Winter: 77
Andyer: 63
Lily:   76
Maryia: 89
-----after sort ....
Jimy:   56
Jone:   56
Bush:   52
Tom:    74
Mary:   92
Jessy:  85
Winter: 77
Andyer: 63
Lily:   76
Maryia: 89
</pre>
看见了吗，Jimy，Jone, Bush(难怪说美国总统比较笨&nbsp;<img title="smile" border="0" alt="smile" src="http://www.stlchina.org/twiki/pub/TWiki/SmiliesPlugin/smile.gif">&nbsp;)都没有及&#26684;。而且使用的是stable_partition, 元素之间的相对次序是没有变.
<h3 style="border-bottom:rgb(214,214,214) 1px dotted; background-color:transparent; font-size:10pt">
<a name="t11"></a><a name="2_Sort"></a><a name="2_Sort_"></a>2 Sort 和容器</h3>
<hr>
STL中标准容器主要vector, list, deque, string, set, multiset, map, multimay， 其中set, multiset, map, multimap都是以树结构的方式存储其元素详细内容请参看：<a href="http://stl.winterxy.com/html/000039.html" target="_top" style="color:rgb(0,102,170); text-decoration:none">学习STL map, STL set之数据结构基础</a>.
 因此在这些容器中，元素一直是有序的。
<p style="margin-top:10px; margin-bottom:10px">这些容器的迭代器类型并不是随机型迭代器，因此，上述的那些排序函数，对于这些容器是不可用的。上述sort函数对于下列容器是可用的：</p>
<ul>
<li>vector </li><li>string </li><li>deque</li></ul>
如果你自己定义的容器也支持随机型迭代器，那么使用排序算法是没有任何问题的。
<p style="margin-top:10px; margin-bottom:10px">对于list容器，list自带一个sort成员函数list::sort(). 它和算法函数中的sort差不多，但是list::sort是基于指针的方式排序，也就是说，所有的数据移动和比较都是此用指针的方式实现，因此排序后的迭代器一直保持有效（vector中sort后的迭代器会失效).</p>
<p style="margin-top:10px; margin-bottom:10px"></p>
<h3 style="border-bottom:rgb(214,214,214) 1px dotted; background-color:transparent; font-size:10pt">
<a name="t12"></a><a name="3"></a><a name="3_"></a>3 选择合适的排序函数</h3>
<hr>
为什么要选择合适的排序函数？可能你并不关心效率(这里的效率指的是程序运行时间), 或者说你的数据量很小， 因此你觉得随便用哪个函数都无关紧要。
<p style="margin-top:10px; margin-bottom:10px">其实不然，即使你不关心效率，如果你选择合适的排序函数，你会让你的代码更容易让人明白，你会让你的代码更有扩充性，逐渐养成一个良好的习惯，很重要吧&nbsp;<img title="smile" border="0" alt="smile" src="http://www.stlchina.org/twiki/pub/TWiki/SmiliesPlugin/smile.gif">&nbsp;。</p>
<p style="margin-top:10px; margin-bottom:10px">如果你以前有用过C语言中的qsort, 想知道qsort和他们的比较，那我告诉你，qsort和sort是一样的，因为他们采用的都是快速排序。从效率上看，以下几种sort算法的是一个排序，效率由高到低（耗时由小变大）：</p>
<ol>
<li>partion </li><li>stable_partition </li><li>nth_element </li><li>partial_sort </li><li>sort </li><li>stable_sort</li></ol>
记得，以前翻译过Effective STL的文章，其中对<a href="http://stl.winterxy.com/html/000026.html" target="_top" style="color:rgb(0,102,170); text-decoration:none">如何选择排序函数</a>总结的很好：
<ul>
<li>若需对vector, string, deque, 或 array容器进行全排序，你可选择sort或stable_sort； </li><li>若只需对vector, string, deque, 或 array容器中取得top n的元素，部分排序partial_sort是首选. </li><li>若对于vector, string, deque, 或array容器，你需要找到第n个位置的元素或者你需要得到top n且不关系top n中的内部顺序，nth_element是最理想的；</li><li>若你需要从标准序列容器或者array中把满足某个条件或者不满足某个条件的元素分开，你最好使用partition或stable_partition； </li><li>若使用的list容器，你可以直接使用partition和stable_partition算法，你可以使用list::sort代替sort和stable_sort排序。若你需要得到partial_sort或nth_element的排序效果，你必须间接使用。正如上面介绍的有几种方式可以选择。</li></ul>
总之记住一句话：&nbsp;<strong>如果你想节约时间，不要走弯路, 也不要走多余的路!</strong>
<h3 style="border-bottom:rgb(214,214,214) 1px dotted; background-color:transparent; font-size:10pt">
<a name="t13"></a><a name="4"></a><a name="4_"></a>4 小结</h3>
<hr>
讨论技术就像个无底洞，经常容易由一点可以引申另外无数个技术点。因此需要从全局的角度来观察问题，就像观察STL中的sort算法一样。其实在STL还有make_heap, sort_heap等排序算法。本文章没有提到。本文以实例的方式，解释了STL中排序算法的特性，并总结了在实际情况下应如何选择合适的算法。
<p style="margin-top:10px; margin-bottom:10px"></p>
<h3 style="border-bottom:rgb(214,214,214) 1px dotted; background-color:transparent; font-size:10pt">
<a name="t14"></a><a name="5"></a><a name="5_"></a>5 参考文档</h3>
<a href="http://stl.winterxy.com/html/000026.html" target="_top" style="color:rgb(0,102,170); text-decoration:none">条款31：如何选择排序函数</a>&nbsp;<br>
<a href="http://www.cuj.com/documents/s=7992/cujcexp1908austern/" target="_top" style="color:rgb(0,102,170); text-decoration:none">The Standard Librarian: Sorting in the Standard Library</a>&nbsp;<br>
<a href="http://www.stlchina.org/documents/EffectiveSTL/index.html" target="_top" style="color:rgb(0,102,170); text-decoration:none">Effective STL中文版</a>&nbsp;<br>
<a href="http://www.stlchina.org/stl_doc/" target="_top" style="color:rgb(0,102,170); text-decoration:none">Standard Template Library Programmer's Guide</a>&nbsp;vvvv</div>
上文转自：<a href="http://www.cppblog.com/mzty/archive/2005/12/15/1770.html" target="_blank" rel="external">http://www.cppblog.com/mzty/archive/2005/12/15/1770.html</a>
<p></p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
<span style="font-size:12px">--------------------------------------------------------------------------------------------------------------------------------------------------------------</span></p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
<span style="font-size:12px"><span style="font-family:Arial; color:#333333; line-height:26px">对象数组排序这里展示了两种方法，定义比较函数或通过重载比较运算符使得类本身是可以比较的，就像基本类型一样。<br>
定义比较函数，既可以通过定义比较运算符（如operator &lt;），也可以直接定义函数（如compare）。<br>
重载运算符之后，可以在sort函数中通过less或greater或less_equal等来调整升序还是降序，默认是升序。<br>
</span><span style="font-family:Arial; color:#333333; line-height:26px">另外，重载运算符后，函数bool operator &lt; 就不要了，否则用g&#43;&#43;编译出错。</span></span></p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
</p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a class="ViewSource" title="view plain" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">
view plain</a><a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">copy</a><a class="PrintSource" title="print" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">print</a><a class="About" title="?" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt;&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;iostream&gt;&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt;&nbsp;&nbsp; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">class</span><span>&nbsp;MyClass&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;id;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;MyClass()&nbsp;{}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;MyClass(</span><span class="datatypes">int</span><span>&nbsp;i):&nbsp;id(&nbsp;i&nbsp;)&nbsp;{}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;operator&nbsp;&lt;&nbsp;(&nbsp;</span><span class="keyword">const</span><span>&nbsp;MyClass&nbsp;&amp;b&nbsp;)&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;id&nbsp;&lt;&nbsp;b.id;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;operator&nbsp;&gt;&nbsp;(&nbsp;</span><span class="keyword">const</span><span>&nbsp;MyClass&nbsp;&amp;b&nbsp;)&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;id&nbsp;&gt;&nbsp;b.id;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>};&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="comment">/*&nbsp;</span>&nbsp;</li><li><span><span class="comment">bool&nbsp;operator&nbsp;&lt;&nbsp;(&nbsp;MyClass&nbsp;a,&nbsp;MyClass&nbsp;b&nbsp;)&nbsp;</span>&nbsp;</span></li><li class="alt"><span><span class="comment">{&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a.id&nbsp;&lt;&nbsp;b.id;&nbsp;</span>&nbsp;</span></li><li class="alt"><span><span class="comment">}&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">*/</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span></span><span class="datatypes">bool</span><span>&nbsp;compare(&nbsp;MyClass&nbsp;a,&nbsp;MyClass&nbsp;b&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;a.id&nbsp;&lt;&nbsp;b.id;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//数组&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;数组&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;MyClass&nbsp;arr[10];&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;srand(time(NULL));&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i].id&nbsp;=&nbsp;rand()%101;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;before&nbsp;sort&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;arr[i].id&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;sort(arr,arr&#43;10,less&lt;MyClass&gt;());&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;after&nbsp;sort&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;arr[i].id&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//动态数组vector&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;动态数组vector&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;MyClass&gt;&nbsp;list;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.push_back(&nbsp;MyClass(&nbsp;rand()%101&nbsp;)&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;before&nbsp;sort&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;list[i].id&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;sort(list.begin(),list.end(),greater&lt;MyClass&gt;());&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;after&nbsp;sort&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;list[i].id&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//定义比较函数&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;定义比较函数&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;MyClass&gt;&nbsp;list2;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list2.push_back(&nbsp;MyClass(&nbsp;rand()%101&nbsp;)&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;before&nbsp;sort&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;list2[i].id&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;sort(list2.begin(),list2.end(),compare);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;after&nbsp;sort&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;list2[i].id&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//使得类本身就是可以比较的&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;使得类本身就是可以比较的&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;MyClass&gt;&nbsp;list3;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list3.push_back(&nbsp;MyClass(&nbsp;rand()%101&nbsp;)&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;before&nbsp;sort&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;list3[i].id&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;sort(list3.begin(),list3.end());&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;</span><span class="string">&quot;after&nbsp;sort&quot;</span><span>&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;list3[i].id&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="BACKGROUND-COLOR: rgb(240,240,240); MARGIN: 4px 0px; DISPLAY: none" class="cpp" name="code">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
class MyClass
{
public:
    int id;
    MyClass() {}
    MyClass(int i): id( i ) {}
    bool operator &lt; ( const MyClass &amp;b ) const
    {
         return id &lt; b.id;
    }

    bool operator &gt; ( const MyClass &amp;b ) const
    {
         return id &gt; b.id;
    }
};
/*
bool operator &lt; ( MyClass a, MyClass b )
{
    return a.id &lt; b.id;
}
*/
bool compare( MyClass a, MyClass b )
{
    return a.id &lt; b.id;
}
int main()
{
    //数组
    cout&lt;&lt;&quot;数组&quot;&lt;&lt;endl;
    MyClass arr[10];
    srand(time(NULL));
    for( int i = 0; i &lt; 10; i++ )
        arr[i].id = rand()%101;
    cout&lt;&lt;&quot;before sort&quot;&lt;&lt;endl;
    for( int i = 0; i &lt; 10; i++ )
        cout&lt;&lt;arr[i].id&lt;&lt;endl;

    sort(arr,arr+10,less&lt;MyClass&gt;());
    cout&lt;&lt;&quot;after sort&quot;&lt;&lt;endl;
    for( int i = 0; i &lt; 10; i++ )
        cout&lt;&lt;arr[i].id&lt;&lt;endl;
    //动态数组vector
    cout&lt;&lt;&quot;动态数组vector&quot;&lt;&lt;endl;
    vector&lt;MyClass&gt; list;
    for( int i = 0; i &lt; 10; i++ )
        list.push_back( MyClass( rand()%101 ) );
    cout&lt;&lt;&quot;before sort&quot;&lt;&lt;endl;
    for( int i = 0; i &lt; 10; i++ )
        cout&lt;&lt;list[i].id&lt;&lt;endl;

    sort(list.begin(),list.end(),greater&lt;MyClass&gt;());
    cout&lt;&lt;&quot;after sort&quot;&lt;&lt;endl;
    for( int i = 0; i &lt; 10; i++ )
        cout&lt;&lt;list[i].id&lt;&lt;endl;

    //定义比较函数
    cout&lt;&lt;&quot;定义比较函数&quot;&lt;&lt;endl;
    vector&lt;MyClass&gt; list2;
    for( int i = 0; i &lt; 10; i++ )
        list2.push_back( MyClass( rand()%101 ) );
    cout&lt;&lt;&quot;before sort&quot;&lt;&lt;endl;
    for( int i = 0; i &lt; 10; i++ )
        cout&lt;&lt;list2[i].id&lt;&lt;endl;

    sort(list2.begin(),list2.end(),compare);
    cout&lt;&lt;&quot;after sort&quot;&lt;&lt;endl;
    for( int i = 0; i &lt; 10; i++ )
        cout&lt;&lt;list2[i].id&lt;&lt;endl;

    //使得类本身就是可以比较的
    cout&lt;&lt;&quot;使得类本身就是可以比较的&quot;&lt;&lt;endl;
    vector&lt;MyClass&gt; list3;
    for( int i = 0; i &lt; 10; i++ )
        list3.push_back( MyClass( rand()%101 ) );
    cout&lt;&lt;&quot;before sort&quot;&lt;&lt;endl;
    for( int i = 0; i &lt; 10; i++ )
        cout&lt;&lt;list3[i].id&lt;&lt;endl;

    sort(list3.begin(),list3.end());
    cout&lt;&lt;&quot;after sort&quot;&lt;&lt;endl;
    for( int i = 0; i &lt; 10; i++ )
        cout&lt;&lt;list3[i].id&lt;&lt;endl;

    return 0;
}  </pre>
<p></p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
sort函数是一个比较方便使用的STL函数，可以直接来进行各种排序。&nbsp;</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
由于在工作的时候有一个排序，刚开始没怎么注意！就用sort算法来实现了，后来出现了一些问题才导致我才对sort算法的一些注意事项的总结：&nbsp;</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort&nbsp;算法函数的用法。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
vector&lt;int&gt; vect;</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
//….</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
Sort(vect.begin(),vect.end();</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
//相当于下面的调用</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
Sort(vect.begin(),vect.end(),less&lt;int&gt;()); //如果不提供比较函数是系统默认从小到大排序</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
当我们要按某种方式进行排序时，需要指定自己的排序函数，否则系统默认提供一个比较函数。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
2．Sort用法挺简单，不过在这儿打算介绍一下&#20540;得注意的一点地方。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
看下面程序（1）：</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
</p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a class="ViewSource" title="view plain" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">
view plain</a><a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">copy</a><a class="PrintSource" title="print" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">print</a><a class="About" title="?" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt; </span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;iostream&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;string&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">class</span><span>&nbsp;A&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;A()&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dict.push_back(</span><span class="string">&quot;owen&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dict.push_back(</span><span class="string">&quot;messi&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dict.push_back(</span><span class="string">&quot;figo&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;less(</span><span class="keyword">const</span><span>&nbsp;string&nbsp;&amp;s1,&nbsp;</span><span class="keyword">const</span><span>&nbsp;string&nbsp;&amp;s2)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;s1&nbsp;&lt;&nbsp;s2;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;Sort()&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort(dict.begin(),&nbsp;dict.end(),&nbsp;less);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;output()&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(vector&lt;string&gt;::iterator&nbsp;iter=dict.begin();&nbsp;iter&nbsp;!=dict.end();&nbsp;&#43;&#43;iter)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">private</span><span>:&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;string&gt;&nbsp;dict;&nbsp;&nbsp;</span></li><li><span>};&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;</span></li><li><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;myclass;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;myclass.output();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;myclass.Sort();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;myclass.output();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="BACKGROUND-COLOR: rgb(240,240,240); MARGIN: 4px 0px; DISPLAY: none" class="cpp" name="code">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

class A
{
public:
    A()
         {
        dict.push_back(&quot;owen&quot;);
        dict.push_back(&quot;messi&quot;);
        dict.push_back(&quot;figo&quot;);
    }

    int less(const string &amp;s1, const string &amp;s2)
         {
        return s1 &lt; s2;
    }

    void Sort()
         {
        sort(dict.begin(), dict.end(), less);
    }
    void output()
         {
        for(vector&lt;string&gt;::iterator iter=dict.begin(); iter !=dict.end(); ++iter)
            cout &lt;&lt; *iter &lt;&lt; endl;
    }
private:
    vector&lt;string&gt; dict;
};

int main() {
    A myclass;
    myclass.output();
    myclass.Sort();
    myclass.output();

    return 0;
}</pre>
<p></p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
编译的时候就报错。Why？难道不是这么用的。。。。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
下面我们来看看&nbsp;正确的例子（2）:</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
</p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a class="ViewSource" title="view plain" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">
view plain</a><a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">copy</a><a class="PrintSource" title="print" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">print</a><a class="About" title="?" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt; </span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;iostream&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;string&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;less(</span><span class="keyword">const</span><span>&nbsp;string&nbsp;&amp;s1,</span><span class="keyword">const</span><span>&nbsp;string&nbsp;&amp;s2)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;s1&lt;s2;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">class</span><span>&nbsp;A&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;A()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dict.push_back(</span><span class="string">&quot;owen&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dict.push_back(</span><span class="string">&quot;messi&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dict.push_back(</span><span class="string">&quot;figo&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;Sort()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort(dict.begin(),&nbsp;dict.end(),&nbsp;less);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;output()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(vector&lt;string&gt;::iterator&nbsp;iter=dict.begin();&nbsp;iter&nbsp;!=dict.end();&nbsp;&#43;&#43;iter)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">private</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;string&gt;&nbsp;dict;&nbsp;&nbsp;</span></li><li class="alt"><span>};&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;myclass;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;myclass.output();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;myclass.Sort();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;myclass.output();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="BACKGROUND-COLOR: rgb(240,240,240); MARGIN: 4px 0px; DISPLAY: none" class="cpp" name="code">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

int less(const string &amp;s1,const string &amp;s2)
{
         return s1&lt;s2;
}
class A
{
public:
    A()
         {
        dict.push_back(&quot;owen&quot;);
        dict.push_back(&quot;messi&quot;);
        dict.push_back(&quot;figo&quot;);
    }
    void Sort()
         {
        sort(dict.begin(), dict.end(), less);
    }
    void output()
         {
        for(vector&lt;string&gt;::iterator iter=dict.begin(); iter !=dict.end(); ++iter)
            cout &lt;&lt; *iter &lt;&lt; endl;
    }
private:
    vector&lt;string&gt; dict;
};

int main() {
    A myclass;
    myclass.output();
    myclass.Sort();
    myclass.output();

    return 0;
}</pre>
<p></p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
这个例子是正确的!&nbsp;为什么有这个差异？这个问题出在哪儿，思考下上面两个例子的不同！&nbsp;也许你不难发现其中的问题？this指针！！</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
例(1)中发现&nbsp;int less(const string &amp;s1, const string &amp;s2)也就相当于int less( A* const this,const string &amp;s1,const string &amp;s2)&nbsp;所以问题的答案一目了然！所以有两种解决方法：</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
1）&nbsp;&nbsp;利用类的静态函数---面向类的属性、。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
2）&nbsp;&nbsp;利用仿函数来实现比较函数。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
以上两种方法都巧妙的避开了this指针。当然以上部分还是为了解决下面的话题！&nbsp;如果有这样的一个类&nbsp;A中有成员int x.而类B&nbsp;中有成员vector&lt;A&gt; vec.map&lt;int,类C&gt;mapVec .这样的情况对vector&lt;A&gt;vec,以A中的X&nbsp;作为map表的索引排序。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
类A&nbsp;&nbsp;&nbsp;int x;</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
类C&nbsp;&nbsp;&nbsp;int y;l</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
类B&nbsp;&nbsp;&nbsp;map&lt;int,C&gt;mapVec;&nbsp;&nbsp;vector&lt;A&gt; vec;对vector&lt;A&gt;用sort算法排序，其中A作为map表的索引查找C&nbsp;类中的Y来进行排序。这儿问题就来了？如上面所说在B类中的Sort()-中的&nbsp;sort()函数的比较函数如何写？&nbsp;&nbsp;我们来看下伪代码:</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
</p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a class="ViewSource" title="view plain" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">
view plain</a><a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">copy</a><a class="PrintSource" title="print" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">print</a><a class="About" title="?" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span>Class&nbsp;A{&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Int&nbsp;&nbsp;x;&nbsp;&nbsp;</span></li><li><span>};&nbsp;&nbsp;</span></li><li class="alt"><span>Class&nbsp;C{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Int&nbsp;&nbsp;y;&nbsp;&nbsp;</span></li><li><span>};&nbsp;&nbsp;</span></li><li class="alt"><span>Class&nbsp;B{&nbsp;&nbsp;</span></li><li><span>Public:&nbsp;&nbsp;</span></li><li class="alt"><span>B(){};&nbsp;&nbsp;</span></li><li><span>Void&nbsp;Sort()&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>Sort(vec.begin(),vec.end(),比较函数);&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">private</span><span>:&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&lt;A&gt;&nbsp;vec;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;</span><span class="datatypes">int</span><span>,C&gt;&nbsp;mapVec;&nbsp;&nbsp;</span></li><li class="alt"><span>};&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="BACKGROUND-COLOR: rgb(240,240,240); MARGIN: 4px 0px; DISPLAY: none" class="cpp" name="code">Class A{
         public:
                   Int  x;
};
Class C{
         public:
                   Int  y;
};
Class B{
Public:
B(){};
Void Sort()
{
Sort(vec.begin(),vec.end(),比较函数);
}
private:
                   Vector&lt;A&gt; vec;
                   Map&lt;int,C&gt; mapVec;
};</pre>
<p></p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
当然看到这个问题也许第一影响应该是在Sort()中做一个快排就可以，当然这样可以。不过让我们结合上面的例子想想这个问题如果用纯STL的方法如何解决。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用类的静态函数-----这个方法当然不行。静态函数是类的属性而我们需要map表。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用仿函数来解决。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
那这个仿函数如何来写？---仿函数中需要有map&lt;int,C&gt;表，且不能是通过this指针带入的。好了基于上面的我们来看下例子3：</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
</p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a class="ViewSource" title="view plain" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">
view plain</a><a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">copy</a><a class="PrintSource" title="print" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">print</a><a class="About" title="?" href="http://blog.csdn.net/tianmo2010/article/details/7532932#" target="_blank" rel="external">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="preprocessor">#include&nbsp;&lt;iostream&gt; </span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;map&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">class</span><span>&nbsp;A&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;x;&nbsp;&nbsp;</span></li><li class="alt"><span>};&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">class</span><span>&nbsp;C</span><span class="comment">//XXX</span><span>&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;y;&nbsp;&nbsp;</span></li><li class="alt"><span>};&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">class</span><span>&nbsp;B&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;B():cmp(mapVec)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;Sort()&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort(vec.begin(),vec.end(),cmp);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">protected</span><span>:&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">class</span><span>&nbsp;InnerCmp&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InnerCmp(map&lt;</span><span class="datatypes">int</span><span>,C&gt;&nbsp;&amp;map):m(map)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;operator()&nbsp;(</span><span class="keyword">const</span><span>&nbsp;A&nbsp;&amp;a,</span><span class="keyword">const</span><span>&nbsp;A&nbsp;&amp;b)&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;m[a.x].y&lt;m[b.x].y;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">private</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map&lt;</span><span class="datatypes">int</span><span>,C&gt;&nbsp;&amp;m;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">private</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;InnerCmp&nbsp;cmp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;A&gt;&nbsp;vec;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;map&lt;</span><span class="datatypes">int</span><span>,C&gt;&nbsp;mapVec;&nbsp;&nbsp;</span></li><li class="alt"><span>};&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="BACKGROUND-COLOR: rgb(240,240,240); MARGIN: 4px 0px; DISPLAY: none" class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

class A
{
public:
    int x;
};

class C//XXX
{
public:
    int y;
};

class B
{
public:
    B():cmp(mapVec)
    {

    }

    void Sort()
    {
        sort(vec.begin(),vec.end(),cmp);
    }

protected:
    class InnerCmp
    {
    public:
        InnerCmp(map&lt;int,C&gt; &amp;map):m(map)
        {
        }

        bool operator() (const A &amp;a,const A &amp;b) const
        {
            return m[a.x].y&lt;m[b.x].y;
        }

    private:
        map&lt;int,C&gt; &amp;m;
    };

private:
    const InnerCmp cmp;
    vector&lt;A&gt; vec;
    map&lt;int,C&gt; mapVec;
};

int main()
{
    return 0;
}</pre>
<p></p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
如上面的例子，我们构造的仿函数完全符合规则。同时巧妙的把map&nbsp;放到类InnerCmp中。这样我们就可以达到上面问题的目的。当然这样做只是为了更好的理解&nbsp;比较函数。</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
<br>
</p>
<p style="padding-bottom:2px; margin:4px 0px; padding-left:0px; padding-right:0px; padding-top:2px">
以上来自互联网，在此表示感谢</p>
</div>
</div>
</h2>
</div>
<div class="blogzz_acon">
<p>&nbsp;</p>
</div>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-贪心——NYOJ题目106_背包问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/25/贪心——NYOJ题目106_背包问题/">贪心——NYOJ题目106 背包问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div class="problem-display">
<h4></h4>
<h2>&nbsp;</h2>
<h2>背包问题</h2>
<div class="problem-ins">时间限制：<span id="problem[time_limit]" class="editable highlight">3000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB
</div>
<div class="problem-ins">难度：<span class="editable highlight">3</span></div>
</div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>现在有很多物品（它们是可以分割的），我们知道它们每个物品的单位重量的价&#20540;v和重量w（1&lt;=v,w&lt;=10）；如果给你一个背包它能容纳的重量为m（10&lt;=m&lt;=20）,你所要做的就是把物品装到背包里，使背包里的物品的价&#20540;总和最大。
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>第一行输入一个正整数n（1&lt;=n&lt;=5）,表示有n组测试数据；<br>
随后有n测试数据，每组测试数据的第一行有两个正整数s，m（1&lt;=s&lt;=10）;s表示有s个物品。接下来的s行每行有两个正整数v，w。 </dd><dt>输出 </dt><dd>输出每组测试数据中背包内的物品的价&#20540;和，每次输出占一行。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">1
3 15
5 10
2 8
3 9
</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">65</pre>
</dd></dl>
</dd></dl>
<dl>
<p>分析：贪心原理，要求背包物品总价&#20540;最大，故尽可能多存放价&#20540;大的物品；如图 题目中给出的例子， 背包可容纳重量15，故先放价&#20540;最大的A，将10斤A全部放入背包，然后放入价&#20540;次大的C，此时背包容纳量剩下15-10=5，而C还有9斤，因此剩下的全放C，总价&#20540;=（10*5）&#43;（5*3）=65</p>
<p><img src="http://img.blog.csdn.net/20130725165508062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTI4MjA2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" width="754" height="206" alt=""></p>
<p>代码：</p>
<pre class="cpp" name="code"> 

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

using namespace std;

typedef struct GOODS
{
	int v,w;//价值和重量都比较小&lt;256 
}GOODS;

GOODS goods [10];

int cmp(const void * a,const void *b)
{
	return (*(GOODS *)a).v&lt;  (*(GOODS *)b).v ? 1: -1;
}
int main()
{
	int s,n,m,i;
	int value,weight;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    {
              scanf(&quot;%d%d&quot;,&amp;s,&amp;m);
              for(i=0;i&lt;s;i++)     scanf(&quot;%d%d&quot;,&amp;goods[i].v,&amp;goods[i].w); 
			 qsort(goods,s,sizeof(goods[0]),cmp);  //将物品按价值从大到小排序 
			 //for(i=0;i&lt;s;i++) printf(&quot;%d %d\n&quot;,goods[i].v,goods[i].w);
			 value = weight = i = 0;
			 
			 while(m)
			 {
					if(goods[i].w &lt;= m)//这种物品的总质量 还小与目前背包容纳量，则全部装入 
					{
						m -= goods[i].w;
						value += goods[i].v *goods[i].w; //w重量的单价为v的物品价值 
					}
					else//将背包剩下的容量全部装这种物品 
					{
						value += goods[i].v * m; 
						m=0;
					} 
				
				i++;
			}   
			printf(&quot;%d\n&quot;,value);    
    }
  // system(&quot;pause&quot;);
 return 0;    
}        </pre>
<p><br>
&nbsp;</p>
</dl>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-贪心——NYOJ_题目71_独木舟上的旅行" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/25/贪心——NYOJ_题目71_独木舟上的旅行/">贪心——NYOJ 题目71 独木舟上的旅行</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div>
<h2>独木舟上的旅行</h2>
<div>时间限制：<span id="problem[time_limit]">3000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]">65535</span> KB</div>
<div>难度：2</div>
</div>
<dl><dt>描述 </dt><dd>
<p><span style="font-size:12px"><span style="color:black">进行一次独木舟的旅行活动，独木舟可以在港口租到，并且之间没有区别。一条独木舟最多只能乘坐两个人，且乘客的总重量不能超过独木舟的最大承载量。我们要尽量减少这次活动中的花销，所以要找出可以安置所有旅客的最少的独木舟条数。现在请写一个程序，读入独木舟的最大承载量、旅客数目和每位旅客的重量。根据给出的规则，计算要安置所有旅客必须的最少的独木舟条数，并输出结果。</span></span></p>
<dl><dt>输入 </dt><dd>第一行输入s,表示测试数据的组数；<br>
每组数据的第一行包括两个整数w，n，80&lt;=w&lt;=200,1&lt;=n&lt;=300，w为一条独木舟的最大承载量,n为人数；<br>
接下来的一组数据为每个人的重量（不能大于船的承载量）； </dd><dt>输出 </dt><dd>每组人数所需要的最少独木舟的条数。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">3</pre>
</dd><dd>
<pre>85 6</pre>
</dd><dd>
<pre>5 84 85 80 84 83</pre>
</dd><dd>
<pre>90 3</pre>
</dd><dd>
<pre>90 45 60</pre>
</dd><dd>
<pre>100 5</pre>
</dd><dd>
<pre>50 50 90 40 60</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">5</pre>
</dd><dd>
<pre>3</pre>
</dd><dd>
<pre>3</pre>
</dd></dl>
</dd></dl>
<dl>
<p>分析：要求使用的独木舟最少，而且题目是每个最多承载两个人，每个独木舟都有最大载重，故要尽量使每个独木舟装载尽可能多的乘客，可以将乘客质量按总小到大排序，然后以质量大的优先使用独木舟和质量小得结合，以此类推，得到使用最少的独木舟。</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

using namespace std;

int weight[301];

int main()
{
    int n,m,w,i,j,cnt;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    {
              scanf(&quot;%d%d&quot;,&amp;w,&amp;m);
              for(i=1;i&lt;=m;i++) 
                   scanf(&quot;%d&quot;,&amp;weight[i]); 
               sort(weight+1,weight+m+1) ;//质量排序
		//qsort(weight,m,sizeof(int),cmp); 因为是从下表1到m排序，这样写不对 
		// for(i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;,weight[i]);
			 cnt = 0;
			 for(i=1,j=m;i&lt;j;)
			 {
				if(weight[i]+weight[j] &lt;= w)// 质量大的跟质量小的可以乘坐一个 
				{
					cnt++;
					i++;j--; //乘客减少两个 
				}
				else  //质量太大不能和小的结合，故自己使用一个 
				{
					cnt++;
					j--; //乘客减少1个 
				} 
			}   
			if(i==j) cnt++; //如果最后剩下中间一个乘客 ，cnt++ 
			printf(&quot;%d\n&quot;,cnt);    
    }
   //system(&quot;pause&quot;);
 return 0;    
}</pre>
<p><br>
</p>
<p>&nbsp;</p>
</dl>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-贪心——NYOJ_题目6_喷水装置（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/25/贪心——NYOJ_题目6_喷水装置（一）/">贪心——NYOJ 题目6 喷水装置（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div class="problem-display">
<h4></h4>
<h2>喷水装置（一）</h2>
<div class="problem-ins">时间限制：<span id="problem[time_limit]" class="editable highlight">3000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB</div>
<div class="problem-ins">难度：<span class="editable highlight">3</span></div>
</div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>现有一块草坪，长为20米，宽为2米，要在横中心线上放置半径为Ri的喷水装置，每个喷水装置的效果都会让以它为中心的半径为实数Ri(0&lt;Ri&lt;15)的圆被湿润，这有充足的喷水装置i（1&lt;i&lt;600)个，并且一定能把草坪全部湿润，你要做的是：选择尽量少的喷水装置，把整个草坪的全部湿润。
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>第一行m表示有m组测试数据<br>
每一组测试数据的第一行有一个整数数n，n表示共有n个喷水装置，随后的一行，有n个实数ri，ri表示该喷水装置能覆盖的圆的半径。 </dd><dt>输出 </dt><dd>输出所用装置的个数 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">2
5
2 3.2 4 4.5 6 
10
1 2 3 1 2 1.2 3 1.1 1 2</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">2
5
</pre>
</dd></dl>
</dd></dl>
<dl>
<p>&nbsp;</p>
<p>分析:</p>
<p>优先使用半径大的，来达到最大的覆盖面积，可以先对半径进行排序，计算出大的喷水装置所能覆盖的最大长度（因为在中心横线，长度能覆盖完，宽度肯定也覆盖了）</p>
<p>来计算每个喷水装置所能覆盖的长度</p>
<p>&nbsp;<img src="http://img.blog.csdn.net/20130725202723421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTI4MjA2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="501" height="237" alt=""></p>
<pre class="cpp" name="code"> 

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;

double r[601];


int  cmp(const void * a,const void * b)
{
    return *(double *)a &lt; *(double*)b ? 1:-1; //从大到小 
}
int main()
{
    int m,n,i,j;
    double length;
    scanf(&quot;%d&quot;,&amp;m);
    while(m--)
    {
           scanf(&quot;%d&quot;,&amp;n);
           for(i=0;i&lt;n;i++)  scanf(&quot;%lf&quot;,&amp;r[i]);  
           qsort(r,n,sizeof(double),cmp);//将半径从大到小排序 
           //for(i=0;i&lt;n;i++)  printf(&quot;%lf\n&quot;,r[i]);
           int cnt = 1;
           length = 0;//设置i为上一个已安排活动
           for(j=0;j&lt;n;j++)
           {
                 length += 2 * sqrt(r[j]*r[j]-1);//每一个喷水装置所能覆盖的面积的最大长度  
                 if(length&gt;=20.0) break;
                 cnt++;                              
           }
           printf(&quot;%d\n&quot;,cnt);
    }
   //system(&quot;PAUSE&quot;);
    return 0;    
}        </pre><br>
</dl>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-贪心——NYOJ_题目14_会场安排问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/25/贪心——NYOJ_题目14_会场安排问题/">贪心——NYOJ 题目14 会场安排问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div class="problem-display">
<h4></h4>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 会场安排问题</h2>
<div class="problem-ins">时间限制：<span id="problem[time_limit]" class="editable highlight">3000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB</div>
<div class="problem-ins">难度：<span class="editable highlight">4</span></div>
</div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>学校的小&#31036;堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校小&#31036;堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。<br>
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>第一行是一个整型数m(m&lt;100)表示共有m组测试数据。<br>
每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。<br>
随后的n行，每行有两个正整数Bi,Ei(0&lt;=Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;=Ei)<br>
</dd><dt>输出 </dt><dd>对于每一组输入，输出最多能够安排的活动数量。<br>
每组的输出占一行 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">2
2
1 10
10 11
3
1 10
10 11
11 20
</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">1
2</pre>
</dd><dt>提示 </dt><dd>注意：如果上一个活动在t时间结束，下一个活动最早应该在t&#43;1时</dd></dl>
</dd></dl>
<p><strong><span style="font-size:24px; color:#ff0000">分析：</span>&nbsp; <span style="font-size:18px">
做这道题目的时候，我们先来想一下下面的情况：如果有两个活动让你选择一个，它们的结束时间一前一后，那么，我们应该选择哪一个才能有利于之后选取更多的活动呢？&nbsp; 很明显，我们应该选择的是结束时间较早的那个活动。&nbsp; 同样，在有一大堆活动时，我们最先应该选择结束时间最早的那个，以利于之后能安排更多的活动，然后，再在剩下的可选的会场中选择最可能结束时间最早的那个，依次类推，直到无法安排任何活动为止。&nbsp; 也就是说，每次选择时，都应该贪婪的选择结束时间最短的那个活动。 现在我们来证明刚才的贪心方法是正确的：假设有哪一次选择的不是结束时间最早的那个活动，那么，此次选择之后，剩下的可选活动一定没有选择结束时间最早的活动时多，用这种方法之后可再选择的活动数目一定不会比上面思路中的方法更多。</span></strong></p>
<p><strong><span style="font-size:18px"></span></strong>&nbsp;</p>
<p><strong><span style="font-size:18px">代码：</span></strong></p>
<pre class="cpp" name="code"> 
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;

using namespace std;

typedef struct Party
{
     int start,end;        
}Party;

Party PARTY[10001];


int  cmp(const void * a,const void * b)
{
    return (*(Party *)a).end &gt; (*(Party*)b).end ? 1:-1;
}
int main()
{
    int m,n,i,j;
    scanf(&quot;%d&quot;,&amp;m);
    while(m--)
    {
           scanf(&quot;%d&quot;,&amp;n);
           for(i=0;i&lt;n;i++)  scanf(&quot;%d%d&quot;,&amp;PARTY[i].start,&amp;PARTY[i].end);  
           qsort(PARTY,n,sizeof(Party),cmp);
           //for(i=0;i&lt;n;i++)  printf(&quot;%d %d\n&quot;,PARTY[i].start,PARTY[i].end);
           int cnt = 1;
           i = 0;//设置i为上一个已安排活动
           for(j=1;j&lt;n;j++)
           {
                 if(PARTY[i].end&lt;PARTY[j].start) 
                 {
                    cnt++;
                    i = j;//安排一个活动之后 i 的值变化为已安排的活动                        
                 }
           }
           printf(&quot;%d\n&quot;,cnt);
    }
   // system(&quot;PAUSE&quot;);
    return 0;    
}        </pre>
<p><br>
时间：88 内存：388</p>
<dl class="problem-display">
<dl class="others"></dl>
</dl>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-ACM—NYOJ小小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/20/ACM—NYOJ小小结/">ACM—NYOJ小小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>我觉得做题不是越多越好，而是善于总结！</p>
<p>做南阳理工题目也有一段时间了，我觉得还是有必要总结一下，把以前做过的题目再重新看看，提取其中的知识点，重点，达到灵活运用才是王道！</p>
<p><br>
</p>
<p>算法的五个特点：<span style="font-family:arial; font-size:13px; line-height:19.5px">&nbsp;</span><span style="font-family:arial; font-size:13px; line-height:19.5px">1. 能行性(或有效的)&nbsp;</span><span style="font-family:arial; font-size:13px; line-height:19.5px">&nbsp;2. 有限性 3. 确定性
 4. 输入 5. 输出</span></p>
<p><br>
</p>
<p>一、基本输入：</p>
<p>每道题目基本上都要求输入数据，因此你的程序要准确接收输入的数据，这步做好了，下面的才有可能进行，并且输入都得有个结束标示，不然一直输入是不可能的吧。下面对这些基本的输入做些总结。</p>
<p><span style="font-size:18px"><strong>1. 先输入一个整数，代表测试数据组数&nbsp;</strong></span></p>
<p>例如：<span style="font-family:Tahoma,Arial,sans-serif,simsun; line-height:21px"><span style="font-size:18px; color:#cc0000">第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据</span></span></p>
<p><br>
</p>
<p>&nbsp;我一般这样写代码</p>
<p></p>
<pre name="code" class="cpp">int n;
scanf(&quot;%d&quot;,&amp;n);
while(n--)
{
     //........核心程序
}</pre>这样看起来简洁，直接n--
<p></p>
<p>不过结尾如果要求输出 case n : .....</p>
<p>用个for循环比较好，循环一次，case&#43;&#43;；</p>
<p><br>
</p>
<p><strong><span style="font-size:18px">2.没有说明几组测试数据的，一般是以EOF结束输入，或者指明EOF结束</span></strong></p>
<p></p>
<pre name="code" class="cpp">C语法：
	while( scanf(&quot;%d %d&quot;,&amp;a, &amp;b) != EOF) 
	{ &nbsp; &nbsp; .... } 
C++语法：
	while( cin &gt;&gt; a &gt;&gt; b ) { &nbsp; &nbsp; .... } </pre><br>
Scanf函数返回&#20540;就是读出的变量个数，
<p></p>
<p>如：scanf( “%d &nbsp;%d”, &amp;a, &amp;b ); 如果a和b都被成功读入整数，那么scanf的返回&#20540;就是2； 如果只有a被成功读入整数，返回&#20540;为1；</p>
<p>如果a和b都未被成功读入整数，返回&#20540;为0；</p>
<p>如果遇到错误或遇到end of file，返回&#20540;为EOF&nbsp;<br>
EOF是一个预定义的常量，等于-1。</p>
<p><strong><span style="font-size:18px">3.输入不说明有多少个Input Block,但以某个特殊输入为结束标志。</span></strong></p>
<p><span style="font-size:18px; color:#cc0000">Input contains multiple test cases. Each test case contains a pair of integers a and b, one pair of integers per line.&nbsp;</span></p>
<p><span style="font-size:18px; color:#cc0000">A test case containing 0 0 terminates the input and this test case is not to be processed.&nbsp;</span></p>
<p>2010-10-13<br>
20<br>
本类输入解决方案：<br>
&#61550;<br>
</p>
<pre name="code" class="cpp">C语法：
while(scanf(&quot;%d&quot;,&amp;n)  &amp;&amp; n!=0 ) { .... } 

C++语法：
while( cin &gt;&gt; n &amp;&amp; n != 0 ) { .... }</pre><strong><span style="font-size:18px"><br>
4.输入是一整行字符串的：</span></strong>
<p></p>
<p></p>
<pre name="code" class="cpp">C语法：
	&nbsp; char buf[20];  &nbsp;gets(buf); 
C++语法：
	如果用string buf;来保存：getline( cin , buf ); 
	如果用char buf[ 255 ]; 来保存： cin.getline( buf, 255 );</pre><br>
scanf(“ %s%s”,str1,str2)，在多个字符串之间用一个或多个空&#26684;分隔；
<p></p>
<p><br>
若使用gets函数，应为gets(str1); gets(str2); 字符串之间用回车符作分隔。</p>
<p><br>
通常情况下，接受短字符用scanf函数，接受长字符用gets函数。</p>
<p><br>
而getchar函数每次只接受一个字符，经常c=getchar()这样来使用。<br>
</p>
<p><br>
</p>
<p>getline 是一个函数，它可以接受用户的输入的字符，直到已达指定个数，或者用户输入了特定的字符。它的函数声明形式（函数原型）如下：<br>
<span style="white-space:pre"></span><span style="color:#ff0000">iostream&amp; getline(char line[], int size, char endchar = '\n');</span><br>
不用管它的返回类型，来关心它的三个参数：<br>
char line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。<br>
int size : 最多接受几个字符？用户超过size的输入都将不被接受。<br>
char endchar :当用户输入endchar指定的字符时，自动结束。默认是回车符。<br>
</p>
<p>结合后两个参数，getline可以方便地实现： 用户最多输入指定个数的字符，如果超过，则仅指定个数的前面字符有效，如果没有超过，则用户可以通过回车来结束输入。<br>
char name[4];<br>
cin.getline(name,4,'\n');<br>
由于 endchar 默认已经是 '\n'，所以后面那行也可以写成：<br>
cin.getline(name,4);<br>
</p>
<p><br>
</p>
<p>5.接受字符串，以一个空行结束</p>
<p></p>
<pre name="code" class="cpp">while( gets(str) )
{....}</pre><br>
（粘贴吧，太累了。。）
<p></p>
<p><strong><span style="font-size:18px">二、输出问题</span></strong></p>
<p></p>
<h2>&nbsp;一个Input Block对应一个Output Block，OutputBlock之间空行。</h2>
<h2>l&nbsp;&nbsp;<strong>ProblemDescription</strong> <br>
Your task is to calculate the sum of some integers. </h2>
<h2>l&nbsp;&nbsp;<strong>Input</strong> <br>
Input contains an integer N in the first line, and then N lines follow. Eachline starts with a integer M, and then M integers follow in the same line.</h2>
<h2>l&nbsp;&nbsp;<strong>Output</strong><br>
For each group of input integers you should output their sum in one line, andyou must note that there is a blank line between outputs.&nbsp;<br>
<br>
</h2>
<h2>l&nbsp;&nbsp;<strong>Sampleinput<br>
</strong>3 <br>
4 1 2 3 4 <br>
5 1 2 3 4 5 <br>
3 1 2 3 </h2>
<h2>l&nbsp;&nbsp;<strong>Sampleoutput<br>
</strong>10<br>
<br>
15<br>
<br>
6 </h2>
<h2><br>
</h2>
<h2><pre name="code" class="cpp"> C语法：

 { 
    .... 
   printf(&quot;%d\n\n&quot;,ans);

}

C++语法：

 { 
    ... 
    cout &lt;&lt; ans &lt;&lt; endl&lt;&lt; endl; 
}</pre><br>
2.输出数据中间有空行，最后一个数据后面没有空行</h2>
<h1><br>
</h1>
<h2>C语法：</h2>
<h2><pre name="code" class="cpp"> for (k=0;k&lt;count;k++) 
{ 
      while (…) 
      { 
             printf(&quot; %d\n&quot;,result); 
      } 
      if (k!=count-1) printf(&quot;\n&quot;); 
} </pre><br>
<br>
<br>
</h2>
<h2>&nbsp;</h2>
<h2>l&nbsp;<u>http://acm.hdu.edu.cn/showproblem.php?pid=1016</u></h2>
<h2>l&nbsp;<u>http://acm.hdu.edu.cn/showproblem.php?pid=1017</u></h2>
<h1>&nbsp;</h1>
<h2 align="center"><span style="font-size:18px; color:#000099">初学者常见问题</span></h2>
<h1><span style="color:#330066">编译错误</span></h1>
<h2>l&nbsp;Main函数必须返回int类型(正式比赛)</h2>
<h2>l&nbsp; 不要在for语句中定义类型</h2>
<h2>l&nbsp;__int64不支持，可以用long long代替</h2>
<h2>l&nbsp; 使用了汉语的标点符号</h2>
<h2>l&nbsp; itoa不是ANSI函数</h2>
<h3>&nbsp;&nbsp;能将整数转换为字符串而且与ANSI标准兼容的方法是使用sprintf()函数</h3>
<h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int num = 100;<br>
&nbsp;&nbsp;&nbsp; char str[25];<br>
&nbsp;&nbsp;&nbsp; sprintf(str, &quot; %d&quot; , num);<br>
<br>
</h4>
<h2>l&nbsp; 另外，拷贝程序容易产生错误</h2>
<h1><span style="color:#330066">不常规的编程方式</span></h1>
<h2>l&nbsp;&nbsp;<strong>Printf和cout混用的问题</strong></h2>
<h2>l&nbsp;&nbsp;以下的程序输出什么？</h2>
<h2>l&nbsp;&nbsp;#include&lt;stdio.h&gt;</h2>
<h2>l&nbsp;&nbsp;#include&lt;iostream.h&gt;</h2>
<h2>l&nbsp;&nbsp;int main()</h2>
<h2>l&nbsp;&nbsp;{</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j=0;</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(j=0;j&lt;5;j&#43;&#43;)</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;&quot;j=&quot;;</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%d\n&quot;,j);</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</h2>
<h2>l&nbsp;&nbsp;}</h2>
<h2>&nbsp;</h2>
<h1><span style="color:#330066">什么问题？</span></h1>
<h2>l&nbsp;&nbsp;<strong>一个带缓冲输出（cout）</strong></h2>
<h2>l&nbsp;&nbsp; <strong>一个不带缓冲输出(printf)</strong></h2>
<h2>l&nbsp;&nbsp;<strong>Goole你的问题，充分利用网络资源</strong></h2>
<h1><br>
</h1>
<div><br>
</div>
<div>
<h2 align="center"><strong><span style="color:#7E9CE8">ACM</span><span style="color:#7E9CE8">菜鸟的</span><span style="color:#7E9CE8">21</span><span style="color:#7E9CE8">个经典错误</span></strong></h2>
<h1><span style="color:#7E9CE8">以</span><span style="color:#7E9CE8">HDU</span><span style="color:#7E9CE8">1089 A</span><span style="color:#7E9CE8">＋</span><span style="color:#7E9CE8">B</span><span style="color:#7E9CE8">为例</span></h1>
<h2>l&nbsp;SampleInput</h2>
<h2>l&nbsp;1 5</h2>
<h2>l&nbsp;10 20</h2>
<h2>l&nbsp;SampleOutput</h2>
<h2>l&nbsp;6</h2>
<h2>l&nbsp;30</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">1</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp"> #include&lt;stdio.h&gt;

void main()

{

l int a,b;

scanf(“%d%d”,&amp;a,&amp;b);

printf(“%d\n”,a+b);

 }</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">1</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; 程序不能处理多组数据的问题是最常见的入门问题，只要掌握几种常见的类型，就可以轻松掌握了，具体处理方法曾在第一次课件有详细描述，这里省略了～</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">2</span><span style="color:#7E9CE8">）</span></h1>
<div><span style="color:#7E9CE8"></span><pre name="code" class="cpp">#include&lt;stdio.h&gt;
 void main()
{
  int a,b;
  while(scanf(“%d%d”,&amp;a,&amp;b)!=0)
  printf(“%d\n”,a+b);
}
</pre><br>
<br>
</div>
<h1><span style="color:rgb(126,156,232)">菜鸟之伤（</span><span style="color:#7E9CE8">2</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：文件结束符EOF的&#20540;是-1而不是0，所以while(scanf(…)!=0)常常会因为死循环而造成TLE，这个必须牢记。</h2>
<h2>l&nbsp; 说明：不仅仅菜鸟，很多老鸟也常常因为不注意这点而犯错误，而且还常常因为想不到会犯这种低级错误而想不到原因。</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">3</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()
{

   int a,b;

   while(scanf(“%d%d”,&amp;a,&amp;b)!=EOF);  //这里多了分号

   printf(“%d\n”,a+b);

 }</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">3</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：while 或者&nbsp;for循环的条件外面误加了分号，编译不影响，但是结果循环体没有真正得到多次执行；</h2>
<h2>l&nbsp; 说明：菜鸟常犯的错误，往往因为编译能通过而不能迅速察觉，尤其比赛中～</h2>
<h2><span style="color:#7E9CE8">l&nbsp; </span><strong><span style="color:#7E9CE8">提醒：</span></strong>当你将scanf();语句加上while循环以处理多组数据问题的时候尤其注意——<span style="color:#7E9CE8">因为之前有分号，很容易忘记去掉！</span></h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">4</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp"> #include&lt;stdio.h&gt;

 void main()

 {

   int a,b;

   while(scanf(“%d%d”,&amp;a,&amp;b) =2) //应为-1 或 EOF

      printf(“%d\n”,a+b);

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">4</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C语言中，赋&#20540;符号＝和判断是否相等的逻辑符号＝＝具有完全不同的含义，往往因为我们的习惯问题，<span style="color:#CC0000">在编程中误将判断是否相等的逻辑符号写成赋&#20540;符号＝</span>。同样的，这种失误也会因为不影响编译而影响查错的时间。</h2>
<h2>&nbsp;</h2>
<h2>l&nbsp; 说明：菜鸟常犯的错误，但是有过几次教训就会牢记了，呵呵～</h2>
<h1><span style="color:#7E9CE8">以</span><span style="color:#7E9CE8">HDU</span><span style="color:#7E9CE8">1001 Sum Problem</span><span style="color:#7E9CE8">为例</span></h1>
<h2>l&nbsp;SampleInput</h2>
<h2>l&nbsp;1</h2>
<h2>l&nbsp;100</h2>
<h2>l&nbsp;SampleOutput</h2>
<h2>l&nbsp;1</h2>
<h2>&nbsp;</h2>
<h2>l&nbsp;5050</h2>
<h2>&nbsp;</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">5</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{    int i,n,s;

     while(scanf(“%d”,&amp;n) ==1)

     {

          for(i=1;i&lt;=n;i++)

              s+=i; //s为初始化

          printf(“%d\n\n”,s);

     }

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">5</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#CC0000">忘记变量的初始化</span>是典型的菜鸟问题，不必紧张，多经历几次就牢记了～</h2>
<h2>&nbsp;</h2>
<h2><span style="color:#CC0000">l&nbsp; </span>说明：<span style="color:#CC0000">普通变量的初始化还比较容易查找，而用来保存计算结果的数组的初始化更是容易忘记！</span></h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">6</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{    int i,n,s=0;

     while(scanf(“%d”,&amp;n) ==1)

     {

          for(i=1;i&lt;=n;i++)

              s+=i; //第二次循环s的初始值不一定为0

          printf(“%d\n\n”,s);

     }

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">6</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：<span style="color:#CC0000">变量初始化放在循环外，是一个典型的</span><span style="color:#CC0000">ACM</span><span style="color:#CC0000">初级错误，因为</span><span style="color:#CC0000">ACM</span><span style="color:#CC0000">赛题的多组测试特性，如果不能在循环内初始化，将只能确保第一组数据没问题，而很多入门者习惯只测试一组数据，很容易忽略这个问题</span>。</h2>
<h2>l&nbsp; &nbsp;&nbsp;&nbsp; </h2>
<h2>l&nbsp; 说明：菜鸟常犯的错误，关键是要理解为什么这样会有问题，真正理解后，修改也就不难了。</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">7</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp"> #include&lt;stdio.h&gt;

 void main()

 {int i,n,s;

  while(scanf(“%d”,&amp;n) ==1)

  {

     s=n*(n+1)/2; //s有可能越界溢出

     printf(“%d\n\n”,s);

 }

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">7</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 数组越界还能在提交后收到Runtime Error的信息反馈，而运算中的数据溢出则往往只能收到Wrong Answer的错误提示，所以这种错误往往容易被误导成算法问题；</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </h2>
<h2>l&nbsp; 说明：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不仅菜鸟，就是大牛甚至大神，也常常犯这种错误，只是情况复杂些而已～</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">8</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{int i,n,s;

 while(scanf(“%d”,&amp;n) ==1)

 {

 s=n/2*(n+1);

 printf(“%d\n\n”,s);//结果为整数

 }

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">8</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#CC0000">当两个整数进行运算的时候，运算结果一定还是整数，所以不要因为常规数学惯性思维的影响而认为结果可能为浮点数；</span></h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; 而不同数据类型一同运算的时候，运算结果的数据类型和相对复杂的类型一致（比如 整数&#43;实数，结果类型是实数）</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; </h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">9</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{    int i,n,s;

     while(scanf(“%d”,&amp;n)==1) //丢失大括号，使得循环体不完整而出错

          if(n%2==0)

            s=n/2*(n+1);

           else

               s=(n+1)/2*n;

      printf(“%d\n\n”,s);

 }</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">9</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; 写for或者while等任何循环语句的时候，不管循环体内有几个语句，务必养成都加上一对大括号的好习惯。</h2>
<h2>l&nbsp; 常常碰到的情况是这样的——本来循环体内只有一条语句，确实不用大括号，但是在修改程序的过程中，循环体内增加了其他语句，而这时却忘记了添加大括号！</h2>
<h2><span style="color:#7E9CE8">l&nbsp; </span><span style="color:#7E9CE8">所以说</span><span style="color:#7E9CE8">——</span><span style="color:#7E9CE8">好习惯很重要！</span></h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">10</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{    int i,n,s;

      while(scanf(“%d”,&amp;n)==1)

       { if(n%2==0)

              s=n/2*(n+1);

           else

               s=(n+1)/2*n;     }

       printf(“%d\n\n”,s); //没包含到大括号里面，没有循环

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">10</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; 这也是一个经典错误，虽然为循环体加了大括号，但是并没有包含全部的信息，造成的后果是只有一次输出——尽管对于每组数据都处理了，但是只输出最后一组结果。</h2>
<h2><span style="color:#CC0000">l&nbsp;</span><span style="color:#CC0000">由于很多同学习惯每次只测试一组数据，就更容易忽略这个错误了</span><span style="color:#CC0000">...</span></h2>
<h2><span style="color:#7E9CE8">l&nbsp; </span><strong><span style="color:#7E9CE8">再次证明</span><span style="color:#7E9CE8">——</span><span style="color:#7E9CE8">好习惯很重要！</span></strong></h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">11</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp;&nbsp;假设不会中间溢出，下面的程序是否有问题？</h2>
<h2>l&nbsp;&nbsp;#include&lt;stdio.h&gt;</h2>
<h2>l&nbsp;&nbsp;void main()</h2>
<h2>l&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp; int i,n,s;</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(scanf(“%d”,&amp;n) ==1)</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s=n(n&#43;1)/2;</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(“%d\n\n”,s);</h2>
<h2>l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</h2>
<h2>l&nbsp;&nbsp;}</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">11</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; 这也是受数学习惯影响而可能出现的一个错误，当然，这个错误很好检查，因为编译不能通过的~</h2>
<h2>l&nbsp;总结出这个只是因为确实会出现这个情况，而对于极度没有编程经验的同学来说，有时候也会带来困扰~</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; </h2>
<h1><span style="color:#7E9CE8">还是以</span><span style="color:#7E9CE8">A</span><span style="color:#7E9CE8">＋B</span><span style="color:#7E9CE8">为例</span></h1>
<h2>l&nbsp; 题目描述：计算A＋B的&#20540;，输入数据每行包含2个正整数，如果输入数据是两个负数，则结束输入。</h2>
<h2>l&nbsp;SampleInput</h2>
<h2>l&nbsp;1 5</h2>
<h2>l&nbsp;-1 -1</h2>
<h2>l&nbsp;SampleOutput</h2>
<h2>l&nbsp;6</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">12</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{
    int a,b;

     while(scanf(“%d%d”,&amp;a,&amp;b)==2)

    {  if(a==-1&amp; b==-1) return; //相与应用 &amp;&amp;

     printf(“%d\n”,a+b);

    }     }</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">12</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp;总结：正如判断相等要用“==”一样，C语言中进行逻辑与的运算也是需要两个字符“&amp;&amp;”，类&#20284;的逻辑或运算也是两个字符“||”，如果是单个的字符，含义就完全不同了~</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">13</span><span style="color:#7E9CE8">）</span></h1>
<h2><span style="color:#7E9CE8">l&nbsp;&nbsp; </span><strong><span style="color:#7E9CE8">上一个程序的改进版：</span></strong></h2>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{

   int a,b;

   while(scanf(“%d%d”,&amp;a,&amp;b)==2)

  { if(a==-1&amp;&amp; b==-1) return;

   printf(“%d\n”,a+b);

  }   }</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">13</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：题目描述是负数结束输入，Sample Input最后给出的是-1，如果读题不仔细，很容易陷入思维定势，而会不加思索在程序中用-1判断，这样就真的会发生不幸的事件——尽管我也认为这个陷阱有点阴，而且未必有很大意义，但是题目并没错，而你确实读题不仔细～</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </h2>
<h2>l&nbsp; 说明：算是经典的小陷阱，现在很少出现了</h2>
<h1><span style="color:#7E9CE8">继续以</span><span style="color:#7E9CE8">A</span><span style="color:#7E9CE8">＋B</span><span style="color:#7E9CE8">为例</span></h1>
<h2>l&nbsp;题目描述：给定2个整数A和B，如果A&#43;B&gt;0，请输出”OK!”，否则请输出”No~”</h2>
<h2>l&nbsp;SampleInput</h2>
<h2>l&nbsp;1 5</h2>
<h2>l&nbsp;1 -5</h2>
<h2>l&nbsp;SampleOutput</h2>
<h2>l&nbsp;OK!</h2>
<h2>l&nbsp;No~</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">14</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{

 int a,b;

 while(scanf(“%d%d”,&amp;a,&amp;b)==2)

 {if(a+b&gt;0)   printf(“OK!\n”);

  else            printf(“NO~\n”);   } //大小写与题目不符

 }</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">14</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：字符串输出的大小写问题对于菜鸟需要特别注意，其实，不管是——全大写、全小写，还是首字母大写，你尽管复制即可（没有电子版，另当别论），当然还要注意是否有标点符号等情况。</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; </h2>
<h2>l&nbsp; 说明：菜鸟常犯错误，稍有经验即可避免</h2>
<h1><span style="color:#7E9CE8">以</span><span style="color:#7E9CE8">1170</span><span style="color:#7E9CE8">Balloon Comes!</span><span style="color:#7E9CE8">为例</span></h1>
<h2>l&nbsp;SampleInput</h2>
<h2>l&nbsp;4</h2>
<h2>l&nbsp;&#43; 1 2</h2>
<h2>l&nbsp;- 1 2</h2>
<h2>l&nbsp;* 1 2</h2>
<h2>l&nbsp;/ 1 2</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">15</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">  int n,a,b,i;

  char p;

  scanf(&quot;%d&quot;,&amp;n);

  for(i=0;i&lt;n;i++)

  {

      scanf(&quot;%c%d%d&quot;,&amp;p,&amp;a,&amp;b); // 第一个%c接受的可能是输入n之后的换行符

      if( ……)

  }</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">15</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">刚才程序的改进版:

  int n,a,b,i;

  char p;

  scanf(&quot;%d&quot;,&amp;n);

  getchar(); //这里吸收输入n之后的 ''

  for(i=0;i&lt;n;i++)

  {

      scanf(&quot;%c%d%d&quot;,&amp;p,&amp;a,&amp;b);

      if( ...) ……

  }</pre><br>
<br>
</h2>
<h2><span style="color:#7E9CE8">l&nbsp;&nbsp;</span><span style="color:#7E9CE8">是否还有问题？如何修改？ (只接受的第一次的'\n')</span></h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">15</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：字符和数字的混合输入带来的问题，也是一个常常困扰使用C语言编程的同学的经典问题，关键就是程序未能及时接收回车符，而误将回车当作下一组数据的首字母，你可以通过添加一句getchar(); 轻松解决该问题。</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </h2>
<h2>l&nbsp; 说明：菜鸟的经典错误，如果之前没有遇到过，很难一下子反应过来，当然，遇到一次以后就不成为问题了～</h2>
<h1><span style="color:#7E9CE8">2007 </span><span style="color:#7E9CE8">平方和与立方和</span></h1>
<h2>l&nbsp; 给定一段连续的整数，求出他们中所有偶数的平方和以及所有奇数的立方和。</h2>
<h2>l&nbsp;SampleInput</h2>
<h2>l&nbsp;1 3</h2>
<h2>l&nbsp;2 5</h2>
<h2>l&nbsp;SampleOutput</h2>
<h2>l&nbsp;4 28</h2>
<h2>l&nbsp;20 152</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">16</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{    int m,n;

     while(scanf(“%d%d” ,&amp;m,&amp;n) ==2)

     {   int i,x=0,y=0;

          for(i=m;i&lt;=n;i++)

          {   if(i%2==0)  y=y+i*i;

               else  x=x+i*i*i;   }

          printf(“%d %d\n”,y,x);

     }

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">16</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：题目并没有保证数据是递增的，但人往往有思维定势，而很多题目的设计就是针对这一点！不要埋怨，这种训练能很好的培养我们审慎的思维习惯。</h2>
<h2>&nbsp;</h2>
<h2>l&nbsp; 说明：这种错误经历过以后还是比较容易牢记的，所以说有时候经验很重要。</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">17</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp;&nbsp;以下的程序输出什么？</h2>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

#include&lt;iostream.h&gt;

int main()

{

     int j=0;

     for(j=0;j&lt;5;j++)

     {

           cout&lt;&lt;&quot;j=&quot;;  // 尽量不要c与c++混合使用

          printf(&quot;%d\n&quot;,j);

    }

    return 0;

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">17</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; &nbsp;期望输出：</h2>
<h2>&nbsp;</h2>
<h2>l&nbsp;j=0</h2>
<h2>l&nbsp;j=1</h2>
<h2>l&nbsp;j=2</h2>
<h2>l&nbsp;j=3</h2>
<h2>l&nbsp;j=4</h2>
<h2>&nbsp;</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">17</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：在一个程序中同时使用C和C&#43;&#43;的输出语句，很容易带来问题，原因就是输出机制不完全一样（一个不带缓冲，一个带缓冲），所以尽量避免C和C&#43;&#43;输出语句混用。</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; </h2>
<h2>l&nbsp;说明：这是传说中的经典错误，据说曾困扰某牛人于现场赛 :-)</h2>
<h1><span style="color:#7E9CE8">以</span><span style="color:#7E9CE8">2004</span><span style="color:#7E9CE8">成绩转换为例</span></h1>
<h2>l&nbsp; <strong><span style="color:#7E9CE8">题目描述：</span></strong>输入一个百分制的成绩t，将其转换成对应的等级，具体转换规则如下：</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 90~100为A;</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80~89为B;</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 70~79为C;</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 60~69为D;</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0~59为E;</h2>
<h2>l&nbsp;<strong><span style="color:#7E9CE8">输出描述：</span></strong>对于每组输入数据，输出一行。如果输入数据不在0~100范围内，请输出一行：“Score iserror!”。</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">18</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

int main()

{    int t,a;

       while(scanf(&quot;%d&quot;,&amp;t)!=EOF)

       {    if(t&gt;100||t&lt;0) printf(&quot;Score iserror!\n&quot;);

            else

            {  a=(t-50)/10;

               switch(a) //注意case的break;

               {  case 5:

                  case4:printf(&quot;A\n&quot;);       case3:printf(&quot;B\n&quot;);

                  case2:printf(&quot;C\n&quot;);       case1:printf(&quot;D\n&quot;);

                  default:printf(&quot;E\n&quot;);     

                }     }    }

               return 0;

       }</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">18</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：C语言中的case语句要求在每个case的处理后面都要跟break；（特殊需求除外），而如果因为不了解或者不小心而缺少部分break;则执行的效果也许会不符合你最初的设计。</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; </h2>
<h2>l&nbsp; 说明：C语言的基本功很重要～</h2>
<h1><span style="color:#7E9CE8">以</span><span style="color:#7E9CE8">2046</span><span style="color:#7E9CE8">骨牌铺方&#26684;为例</span></h1>
<h2>l&nbsp;<strong><span style="color:#7E9CE8">题目描述：</span></strong>在2×n的一个长方形方&#26684;中,用一个1× 2的骨牌铺满方&#26684;,输入n ,输出铺放方案的总数.</h2>
<h2>l&nbsp;<strong><span style="color:#7E9CE8">输入描述：</span></strong>输入数据由多行组成，每行包含一个整数n,表示该测试实例的长方形方&#26684;的规&#26684;是2×n(0&lt;n&lt;=50)。</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">19</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

int main()

{

    int i;

     __int64 a[50]={0,1,2};//数组开的小

      for(i=3;i&lt;=50;i++)

         a[i]=a[i-1]+a[i-2];

    while(scanf(&quot;%d&quot;,&amp;i)!=EOF){

          printf(&quot;%I64d\n&quot;,a[i]);   

     }

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">19</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp;总结：数组下标越界是最常见的Runtime Error，也是菜鸟常犯的错误，除了需要扎实的C语言基本功，编程中的注意力集中也是需要的（很多时候不是不知道理论，而是不注意）~</h2>
<h2>l&nbsp;说明：一般情况，你可以通过将数组开的大点而尽量避免这个问题~</h2>
<h1><span style="color:#7E9CE8">以</span><span style="color:#7E9CE8">1425Sort</span><span style="color:#7E9CE8">为例</span></h1>
<h2>l&nbsp; <strong><span style="color:#7E9CE8">题目描述：</span></strong>给你n个整数，请按从大到小的顺序输出其中前m大的数。</h2>
<h2>l&nbsp; <strong><span style="color:#7E9CE8">输入描述：</span></strong>每组测试数据有两行，第一行有两个数n,m(0&lt;n,m&lt;1000000)，第二行包含n个各不相同，且都处于区间[-500000,500000]的整数。</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">20</span><span style="color:#7E9CE8">）</span></h1>
<h2><pre name="code" class="cpp">#include&lt;stdio.h&gt;

void main()

{

   int n,m,i,num[1000000]; //大数组尽量放在main函数外面，全局变量

    while(scanf(“%d%d”,&amp;n,&amp;m)==2)

    {   ......   }

}</pre><br>
<br>
</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">20</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：ACM编程中，使用很大的数组是很常见的做法，但如果超大的数组被定义成局部变量，则很容易出现Runtime Error，解决办法也很简单：定义成全局变量即可。原因是局部变量分配在栈（较小），全局变量分配在堆（较大）；</h2>
<h2>&nbsp;&nbsp;&nbsp;&nbsp; </h2>
<h2>l&nbsp; 说明：这里所说的超大也不能无限制的大，可以根据题目的内存限制进行估算</h2>
<h1><span style="color:#7E9CE8">以</span><strong><span style="color:#7E9CE8">3199 Hamming Problem</span></strong><span style="color:#7E9CE8">为例</span></h1>
<h2>l&nbsp;&nbsp;<strong><span style="color:#7E9CE8">题目描述：</span></strong>For each three prime numbers p1, p2 and p3, let's define Hammingsequence Hi(p1, p2, p3), i=1, ... as containing in increasing order all thenatural numbers whose only prime divisors are p1, p2 or
 p3. </h2>
<h2>l&nbsp;&nbsp;Forexample, H(2, 3, 5) = 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27,...</h2>
<h2>l&nbsp;&nbsp;So H5(2, 3,5)=6.</h2>
<h2>l&nbsp;&nbsp;<strong><span style="color:#7E9CE8">输出描述</span><span style="color:#7E9CE8">：</span></strong>The output file must contain the single integer - Hi(p1, p2, p3). Allnumbers in input and output are less than<strong><span style="color:#7E9CE8">10^18</span></strong>.</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">21</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp;典型错误——</h2>
<h2>l&nbsp;没有仔细分析...</h2>
<h2>l&nbsp;也不敢尝试...</h2>
<h2>l&nbsp;直接被吓走了......</h2>
<h1><span style="color:#7E9CE8">菜鸟之伤（</span><span style="color:#7E9CE8">21</span><span style="color:#7E9CE8">）</span></h1>
<h2>l&nbsp; 总结：这个题目从本质上来说，和1058Humble Numbers是一样的，唯一吓人的就是数据范围的描述，可能会有人想: i 这么大，没法开数组呀？</h2>
<h2>l&nbsp; 但是，你仔细分析一下会发现：因为输出也是小于10^18，而同时，即使一组内的三个素数是最小的2，3，5，增长的速度也是很快的，所以不必为数组太大而着急。当然，也不必因为发现i很小而觉得数据太水，那是因为只能如此，不然输出就要超范围了~</h2>
</div>
<br>
<p></p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><span style="font-family:Tahoma,Arial,sans-serif,simsun; font-size:14px; line-height:21px"><span style="color:#cc0000"><br>
</span></span></p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-字符串的输入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/15/字符串的输入/">字符串的输入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>字符串的输入的主流函数:</p>
<p>一、<span style="color:#ff0000">scanf()</span>;&nbsp; 二、<span style="color:#ff0000">cin</span>;&nbsp; 三、<span style="color:#ff0000">gets()</span>;&nbsp; 四、<span style="color:#ff0000">getline()</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>五、<span style="color:#ff0000">sscanf() 重点！！！！</span></strong></p>
<p><br>
</p>
<p>一、scanf(&quot;%s&quot;,str);</p>
<p>遇见空&#26684;或换行就停止。</p>
<p><pre class="cpp" name="code">#include&lt;stdio.h&gt;
int main()
{
        char str[100];
        while(true)
        {
               scanf(&quot;%s&quot;,str);
               printf(&quot;%s\n&quot;,str);
        }
        return 0;
}</pre>输入：123 456</p>
<p></p>
<p></p>
<p>输出：123</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 456</p>
<p>&nbsp;</p>
<p>二、cin&gt;&gt;str;与scanf();</p>
<p>相&#20284;遇见空&#26684;或换行就停止；以文件结束。</p>
<p>&nbsp;</p>
<p>三、gets(str);</p>
<p>gets(str)函数与 <strong>scanf(&quot;%s&quot;,&amp;str) </strong>相&#20284;，但不完全相同，使用scanf(&quot;%s&quot;,&amp;s) 函数输入字符串时存在一个问题，</p>
<p>就是如果输入了空&#26684;会认为字符串结束，空&#26684;后的字符将作为下一个输入项处理，但gets()函数将接收输入的整个字符串直到遇到<span style="color:#ff0000">换行为止或文件结束</span>。</p>
<p>&nbsp;</p>
<p>四、getline(cin,str);</p>
<p>需要加头文件#include&lt;stdlib.h&gt; ；<span style="color:#008000">而且str&nbsp;必须是 string类型；</span></p>
<p><span style="color:#008000">读入一行以文件或换行结束。</span></p>
<p>&nbsp;</p>
<p><strong><span style="color:#ff0000">五、sscanf();</span></strong></p>
<p><span style="color:#008000">1、sscanf与scanf类&#20284;，都是用于输入的，只是后者以键盘(stdin)为输入源，前者以固定字符串为输入源。</span></p>
<p><span style="color:#008000">2、 </span><span style="color:#3366ff">%[a-z] 表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)</span></p>
<p><span style="color:#3366ff">　　%[aB'] 匹配a、B、'中一员，贪婪性</span></p>
<p><span style="color:#3366ff">　　%[^a] 匹配非a的任意字符，贪婪性</span></p>
<p><span style="color:#008000">3、用法例子</span></p>
<p><span style="color:#008000">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;a. 常见用法。</span></p>
<blockquote style="border-bottom:medium none; border-left:medium none; padding-bottom:0px; margin:0px 0px 0px 40px; padding-left:0px; padding-right:0px; border-top:medium none; border-right:medium none; padding-top:0px">
<p><span style="color:#008000">　　char buf[512] ;</span></p>
<p><span style="color:#008000">　　sscanf(&quot;123456 &quot;, &quot;%s&quot;, buf);//此处buf是数组名，它的意思是将123456以%s的形式存入buf中！</span></p>
<p><span style="color:#008000">　　printf(&quot;%s\n&quot;, buf);</span></p>
<p><span style="color:#008000">　　结果为：123456</span></p>
</blockquote>
<p><span style="color:#008000">　　b</span><span style="color:#3366ff">. 取指定长度的字符串</span><span style="color:#008000">。如在下例中，取最大长度为4字节的字符串。</span></p>
<blockquote style="border-bottom:medium none; border-left:medium none; padding-bottom:0px; margin:0px 0px 0px 40px; padding-left:0px; padding-right:0px; border-top:medium none; border-right:medium none; padding-top:0px">
<p><span style="color:#008000">　　sscanf(&quot;123456 &quot;, &quot;%4s&quot;, buf);</span></p>
<p><span style="color:#008000">　　printf(&quot;%s\n&quot;, buf);</span></p>
<p><span style="color:#008000">　　结果为：1234</span></p>
</blockquote>
<p><span style="color:#008000">　　c.</span><span style="color:#000099"> 取到指定字符为止的字符串</span><span style="color:#008000">。如在下例中，取遇到空&#26684;为止字符串。</span></p>
<blockquote style="border-bottom:medium none; border-left:medium none; padding-bottom:0px; margin:0px 0px 0px 40px; padding-left:0px; padding-right:0px; border-top:medium none; border-right:medium none; padding-top:0px">
<p><span style="color:#008000">　　sscanf(&quot;123456 abcdedf&quot;, &quot;%[^ ]&quot;, buf);</span></p>
<p><span style="color:#008000">　　printf(&quot;%s\n&quot;, buf);</span></p>
<p><span style="color:#008000">　　结果为：123456</span></p>
</blockquote>
<p><span style="color:#008000">　　d. 取</span><span style="color:#000099">仅包含指定字符集的字符</span><span style="color:#008000">串。如在下例中，取仅包含1到9和小写字母的字符串。</span></p>
<blockquote style="border-bottom:medium none; border-left:medium none; padding-bottom:0px; margin:0px 0px 0px 40px; padding-left:0px; padding-right:0px; border-top:medium none; border-right:medium none; padding-top:0px">
<p><span style="color:#008000">　　sscanf(&quot;123456abcdedfBCDEF&quot;, &quot;%[1-9a-z]&quot;, buf);</span></p>
<p><span style="color:#008000">　　printf(&quot;%s\n&quot;, buf);</span></p>
<div class="spctrl">&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#008000">结果为：123456abcdedf</span></div>
<p><span style="color:#008000">　　当输入：</span></p>
<p><span style="color:#008000">　　sscanf(&quot;123456abcdedfBCDEF&quot;,&quot;%[1-9A-Z]&quot;,buf);</span></p>
<p><span style="color:#008000">　　printf(&quot;%s\n&quot;,buf);</span></p>
</blockquote>
<div class="spctrl">&nbsp;<span style="color:#008000">　<span style="white-space:pre"> </span>
结果为：123456</span></div>
<p><span style="color:#008000">　　e</span><span style="color:#000099">. 取到指定字符集为止的字符串</span><span style="color:#008000">。如在下例中，取遇到大写字母为止的字符串。</span></p>
<p><span style="color:#008000">　　<span style="white-space:pre"> </span>sscanf(&quot;123456abcdedfBCDEF&quot;, &quot;%[^A-Z]&quot;, buf);</span></p>
<p><span style="color:#008000">　　<span style="white-space:pre"> </span>printf(&quot;%s\n&quot;, buf);</span></p>
<p><span style="color:#008000">　　<span style="white-space:pre"> </span>结果为：123456abcdedf</span>&nbsp;</p>
<p><span style="color:#008000">　</span><span style="color:#ff0000">　f、</span><span style="color:#008000">给定一个字符串<a href="mailto:iios/12DDWDFF@122" target="_blank" rel="external">iios/12DDWDFF@122</a>，获取 / 和 @ 之间的字符串，先将 &quot;iios/&quot;过滤掉，再将非<a href="mailto:'@'" target="_blank" rel="external">'@'</a>的一串内容送到buf中</span>&nbsp;</p>
<p><span style="color:#008000">　　sscanf(&quot;iios/12DDWDFF@122&quot;, </span><span style="color:#ff0000">&quot;%*[^/]/%[^@]&quot;</span><span style="color:#008000">, buf);</span></p>
<p><span style="color:#008000">　　printf(&quot;%s\n&quot;, buf);</span></p>
<p><span style="color:#008000">　　结果为：12DDWDFF</span></p>
<p><span style="color:#008000">　　</span><span style="color:#ff0000">g</span><span style="color:#008000">、给定一个字符串&quot;</span><span style="color:#000099">hello, world</span><span style="color:#008000">&quot;，仅保留world。（注意：&quot;，&quot;之后有一空&#26684;，%s遇空&#26684;停止，加&nbsp;</span><span style="color:#000099">*&nbsp;</span><span style="color:#008000">则是忽略第一个读到的字符串）</span></p>
<p><span style="color:#008000">　　<span style="white-space:pre"> </span>sscanf(&quot;hello, world&quot;, &quot;</span><span style="color:#ff0000">%*s%s</span><span style="color:#008000">&quot;, buf);</span></p>
<p><span style="color:#008000">　　<span style="white-space:pre"> </span>printf(&quot;%s\n&quot;, buf);</span></p>
<p><span style="color:#008000">　　<span style="white-space:pre"> </span>结果为：world</span></p>
<p><span style="color:#008000">　　%*s表示第一个匹配到的%s被过滤掉，即hello被过滤了</span></p>
<p><span style="color:#008000">　　如果没有空&#26684;则结果为NULL</span></p>
<p><span style="color:#008000"></span>&nbsp;</p>
<div id="cnblogs_post_body">
<h1 class="title_txt">&nbsp;<span style="font-size:18px"> <span style="color:#ff6600">
sscanf函数的用法</span><cite class="fav_csdnstylebykimi"> </cite></span></h1>
<div class="blogstory">
<p>头文件 #include &lt;stdio.h&gt;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义函数 :&nbsp; int sscanf (const char *str,const char * format,........);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 函数说明&nbsp;:&nbsp;&nbsp; sscanf()会将参数str的字符串根据参数format字符串来转换并&#26684;式化数据。&#26684;式转换形式请参考scanf()。转换后的结果存于对应的参数内。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 返回&#20540; :&nbsp; 成功则返回参数数目，失败则返回-1，错误原因存于errno中。 返回0表示失败&nbsp;&nbsp;&nbsp; 否则，表示正确&#26684;式化数据的个数&nbsp;&nbsp;&nbsp; 例如：sscanf(str，&quot;%d%d%s&quot;, &amp;i,&amp;i2, &amp;s);&nbsp;&nbsp;&nbsp; 如果三个变成都读入成功会返回3。&nbsp;&nbsp;&nbsp; 如果只读入了第一个整数到i则会返回1。证明无法从str读入第二个整数。&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 范例</p>
<pre class="cpp" name="code"> #include &lt;stdio.h&gt;
   main() 
   { 
            int i; 
            unsigned int j; 
            char input[ ]=”10 0x1b aaaaaaaa bbbbbbbb”; 
            char s[5]; 
            sscanf(input,”%d %x %5[a-z] %*s %f”,&amp;i,&amp;j,s,s); 
            printf(“%d %d %s ”,i,j,s); 
   }
//输出：&nbsp;10 27 aaaaa</pre>
<p><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sscanf(stringBuf.c_str(), &quot;%20[^#]#%20[^ ]&quot;,......)语句中&quot;&quot;中的内容含义为：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; “%[ ]”符号用于声明字符串，它比“%s”更具体，可以用于<span style="color:#ff0000">设置读取的样式</span>。例如“%[a-z]”只读取小写字母，读到其它字符就结束。注意，方括号中如果有“^”，代表一直读到某字符为止。例如：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; “%[^#]”：读取字符串，一直到出现“＃”号为止。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; “%20[^#]”：读取20个字节的字符串，出现“＃”号时结束。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以，“%20[^#]#%20[^ ]”的意义就是，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 读取两个20字节大小的字符串，第一个字符串可以用＃结束，第二个字符串可以用回车符结束。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 它们的具体阐述，参见MSDN：“scanf Type Field Characters”章节，和“scanf Width&nbsp; Specification”章节。</p>
<p>*********************************************************************************************************************************************</p>
<p>大家都知道sscanf是一个很好用的函数，利用它可以从字符串中取出整数、浮点数和字符串等等。它的使用方法简单，特别对于整数和浮点数来说。但新手可能并不知道处理字符串时的一些高级用法，这里做个简要说明吧。</p>
<p>1. 常见用法。</p>
<p>以下是引用片段：<br>
　　charstr[512]={0};<br>
　　sscanf(&quot;123456&quot;,&quot;%s&quot;,str);<br>
　　printf(&quot;str=%s&quot;,str);</p>
<p>　　2. 取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。</p>
<p>以下是引用片段：<br>
　　sscanf(&quot;123456&quot;,&quot;%4s&quot;,str);<br>
　　printf(&quot;str=%s&quot;,str);</p>
<p>　　3. 取到指定字符为止的字符串。如在下例中，取遇到空&#26684;为止字符串。</p>
<p>以下是引用片段：<br>
　　sscanf(&quot;123456abcdedf&quot;,&quot;%[^]&quot;,str);<br>
　　printf(&quot;str=%s&quot;,str);</p>
<p>　　4. 取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串。</p>
<p>以下是引用片段：<br>
　　sscanf(&quot;123456abcdedfBCDEF&quot;,&quot;%[1-9a-z]&quot;,str);<br>
　　printf(&quot;str=%s&quot;,str);</p>
<p>　　5. 取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。</p>
<p>以下是引用片段：<br>
　　sscanf(&quot;123456abcdedfBCDEF&quot;,&quot;%[^A-Z]&quot;,str);<br>
　　printf(&quot;str=%s&quot;,str); </p>
<p>*********************************************************************************************************************************************</p>
<p>名称: sscanf() - 从一个字符串中读进与指定&#26684;式相符的数据. <br>
<br>
语法: int sscanf( string str, string fmt, mixed var1, mixed var2 ... );</p>
<p>整数 sscanf( 字符串 str, 字符串 fmt, 混合 var1, 混合 var2 ... );</p>
<p>用法: 以指定的&#26684;式 fmt 去解读字符串 str. fmt 中除了 %d 和 %s 以外, 亦可包含其他的字符串作为&#26684;式. 每一个 %d 或 %s 都对应一个参数, 按顺序为 var1, var2 ... %d 读入一个整数到参数中, 而 %s 读入一个字符串. * 亦可用于&#26684;式中, (即 %*d 和 %*s) 加了星号 (*) 表示跳过此数据不读入. (也就是不把此数据读入参数中) LPC 的 sscanf() 与 C 的 sscanf() 虽然相&#20284;, 但仍有不同之处. LPC 的 sscanf()
 不需要 (也不可) 提供变量的内存位址给 sscanf(), 只需要给予变量的名字. 另一个不同点是, LPC 的 sscanf() 对于: sscanf( str, &quot;%s %s&quot;, str1, str2 ); 的语法, 将会把 str 中的第一个英文单字 (即第一个空白字符以前的内容) 读入 str1, 后面其余的内容读入 str2.</p>
<p>sscanf() 会返回符合&#26684;式的 %d 和 %s 总数.</p>
<p>以前曾经编写过这样的小程序：一个文本文件，每行是一条记录，每条记录中包含多个字段，每个字段之间以某种定界符分开，举例如下：</p>
<p>Notebook,IBM,ThinkPad X32,6,12000<br>
<br>
(各字段以逗号分隔，内容依次是：物品名称，生产厂家，型号，数量，价&#26684;)</p>
<p>如果要对这样的一行记录进行处理，提取出各个字段，怎么做比较好呢？</p>
<p>我以前的做法是在一个循环中用strtok函数每次取一个字段，然后将内容保存到一个字符串数组中。这样做虽然可行，但我总感觉写出的代码有些啰嗦。</p>
<p>最近看到一段代码，用C的标准库函数sscanf，处理这样的数据，只需一行就可以了。我把代码整理了一下，去掉了无关的部分，核心部分如下：</p>
<pre class="cpp" name="code">float price;
int quantity;
char category[21], name[21];
char vendor[21], sku[21];
char buf[201];
fp = fopen(filename, &quot;r&quot;);
fgets(buf, 200, fp);
sscanf(buf,&quot;%20[^#]#%20[^#]#%f#%i#%20[^#]#%20[^\n]&quot;,name, sku, &amp;price, &amp;quantity, category, vendor);

</pre>
<p><br>
下面简单做些解说：</p>
<p><span style="color:#ff0000">%20[^#]# 最多读入20个字符，直到遇见定界符#，但不包含定界符<br>
<br>
%f# 读入一个浮点数，直到遇见定界符#<br>
<br>
%i# 读入一个整数，直到遇见定界符#<br>
<br>
%20[^\n] 最多读入20个字符，忽略行尾的回车符</span></p>
<p>是不是很简洁明了呢？</p>
<pre class="cpp" name="code">#include &lt;stdio.h&gt;
int main()
{

char log[]=&quot;&lt;14&gt;2002-11-11 12:12:12 11.22.33.44 3 3 aaaa aaaaaa&quot;;
//char log[]=&quot;&lt;1&gt;2002-11-11 12:12:12 11.22.33.44 3 aaaa aaaaaa&quot;;
char test[]=&quot;&lt;1111&gt; 22&quot;;
char log2[200];
char str1[20],str2[20],str3[20],str4[20],str5[20],str6[20],char str7[20];
int a1,a2,a3,a4,a5,a6;
<span style="color:#ff0000;">sscanf(log,&quot;&lt;%d&gt;%s %s %s %d %d %s&quot;,&amp;a1,str2,str3,str4,&amp;a5,&amp;a6,str7);
</span>printf(&quot;%d\n&quot;,a1);
printf(&quot;%s\n&quot;,str2);
printf(&quot;%s\n&quot;,str3);
printf(&quot;%s\n&quot;,str4);
printf(&quot;%d\n&quot;,a5);
printf(&quot;%d\n&quot;,a6);
printf(&quot;%s\n&quot;,str7);
sscanf(test,&quot;&lt;%d&gt; %d&quot;,&amp;a5,&amp;a6);
printf(&quot;%d\n&quot;,a5);
printf(&quot;%d\n&quot;,a6);
sscanf(log,&quot;&lt;%[^&gt;]&gt;%[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^$]&quot;,str1,str2,str3,str4,str5,str6,str7);
printf(&quot;%s\n&quot;,str1);
printf(&quot;%s\n&quot;,str2);
printf(&quot;%s\n&quot;,str3);
printf(&quot;%s\n&quot;,str4);
printf(&quot;%s\n&quot;,str5);
printf(&quot;%s\n&quot;,str6);
printf(&quot;%s\n&quot;,str7);
return 1;

}

</pre>
<p><br>
const char *str = &quot;drw-rw-rw- 1 user group 0 Oct 28 2003&quot;;<br>
<br>
上面是源串，我要分别得到drw-rw-rw-，group字段<br>
<br>
注意：因为这几个字段的&#20540;会变化，所以我要用&#26684;式化输入，分别存入下面的a b c中，高手帮忙！<br>
<br>
下面这个是我没成功的尝试</p>
<pre class="cpp" name="code">char a[20];
char b[50];
char c[20];
//int ret = sscanf(str, &quot;%[^'' '']* %[''u''] %[^'' '']&quot;, a, b, c);
int ret = sscanf(str, &quot;%s%*s%*s%s%*s%*s%*s%*s%s&quot;, a, b, c);
</pre>
<p><br>
<br>
这样就可以了，不要的东西都抛弃掉了</p>
<p><br>
<br>
<strong>今天看到一个奇怪的scanf。其实这只是用了正则表达式。<br>
<br>
sscanf(user, &quot;%127[^:]:%127[^ ]&quot;, user_name, password);</strong></p>
<p><strong><span style="color:#ff0000">&quot;%127[^:]:%127[^ ]&quot;，是正则表达式<br>
</span><br>
用scanf或者printf，可以在%后面跟%d,%s等东西，也可以跟一个正则表达式。<br>
<br>
这里，127表示最多可以接受127个字符，[^:]是正则表达式，表示非&quot;:&quot;，到&quot;:&quot;结束<br>
<br>
后面，%127[^ ]，同样，其中[^ ]是正则表达式，表示非&quot; &quot;,到&quot; &quot;结束</strong></p>
<p><strong>所以，如果user是&quot;wpc:123456&quot;的字符串，那么经过上面的sscanf后，<br>
<br>
user_name是wpc，而password是123456</strong></p>
</div>
</div>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-树状数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/15/树状数组/">树状数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<span style="font-size:18px"><strong><span style="color:#ff0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个<span style="color:#000099">数组很大</span>的时候，几项求和（不一定求和，求和最常见），累加就显得太耗时了，时间复杂度为O(n)，并且采用累加的方法还有一个局限，那就是，当<span style="color:#000099">修改掉数组中的元素</span>后，仍然要你<span style="color:#000099">求数组中某段元素的和</span>，就显得麻烦了</span>。所以我们就要用到树状数组，时间复杂度为O（lgn），相比之下就快得多</strong></span>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 树状数组图：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img border="0" alt="" src="http://images.cnblogs.com/cnblogs_com/yykkciwei/TArry.jpg" width="736" height="297"></p>
<p>c1=a1，c2=a1&#43;a2，c3=a3，c4=a1&#43;a2&#43;a3&#43;a4，c5=a5，c6=a5&#43;a6，c7=a7，c8=a1&#43;a2&#43;a3&#43;a4&#43;a5&#43;a6&#43;a7&#43;a8，c9=a9，c10=a9&#43;a10，c11=a11........c16=a1&#43;a2&#43;a3&#43;a4&#43;a5&#43;.......&#43;a16。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析上面的几组式子可知：</p>
<ol>
<ol>
<li><span style="color:#009900">当 i 为奇数时，ci=ai ；</span></li><li><span style="color:#009900">当 i 为偶数时，就要看 i 的因子中最多有二的多少次幂，例如，6 的因子中有 2 的一次幂，等于 2 ，所以 c6=a5&#43;a6（由六向前数两个数的和），4 的因子中有 2 的两次幂，等于 4 ，所以 c4=a1&#43;a2&#43;a3&#43;a4（由四向前数四个数的和）。</span></li></ol>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有公式：cn =&nbsp; a(n-2^k&#43;1)&#43;.........&#43;an（其中 k 为 n 的二进制表示中从右往左数的 0 的个数，2^k则是n的因子中最大的2的次幂）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;那么，如何<span style="color:#000099">求 2^k</span> 呢？求法如下：</p>
<pre class="cpp" name="code">int lowbit(int i)
{  // 返回i的因子中含有 2的最大幂,如6的因子中最大2的幂是2^1 = 2 ，8的因子最大2次幂 2^3 = 8；
	return i&amp;(-i);
}</pre>
<p>lowbit（）的返回&#20540;就是 2^k 次方的&#20540;。</p>
<p>&nbsp;</p>
<p><strong>（一）创建树状数组</strong></p>
<pre class="cpp" name="code">for(i=1;i&lt;=n;i++)
	{
		scanf(&quot;%d&quot;,&amp;e);
		a[i] = e;
		if(i&amp;1)//奇数,树状数组与原始位置数据一样
			Tree_a[i] = a[i];
		else //偶数，树状数组对应位置存的为几项的和
		{
			int sum = 0;
			for(j=i+1-lowbit(i);j&lt;=i;j++)	sum += a[j];//求出从a[i]与前 lowbit(i) 项的和
			Tree_a[i] = sum;
		}
	}//建好树状数组Tree_a[] ,  原始数组a[]</pre>
<p><br>
<strong>（二）当数组中的元素有变更时，树状数组就发挥它的优势了，算法如下（修改为给某个节点x加上&nbsp;y，数组长度n ）：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<pre class="cpp" name="code">void change(int x, int y,int n)
{//给x位置增加y，则x到n之间需要调整
	while(x&lt;=n)
	{
		Tree_a[x] += y;
		x += lowbit(x);//只调整个别的
	}
}</pre>
<p><br>
<strong>（三）求x到y之间的数据的和（根据数组数组求）</strong></p>
<p><span style="color:#000099">SUM = f_sum(y) - f_sum(x-1);</span></p>
<pre class="cpp" name="code">int f_sum(int x)
{//返回前x个数的和
	if(x==0) return 0;
	int sum = 0;
	while( x&gt;0 )
	{
		sum += Tree_a[x]; //求前x数的和
		x -= lowbit(x);
	}
	return sum;
}</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/1970/01/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html">Server</a><br>
      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  

  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/15/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span>
    </nav>
  


</section>
      </div>
      <footer id="footer">
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      &copy; 2017 <a href="https://github.com/hanks-zyh"> Hanks</a>
	  </div>
  </div>
 <div id="share">
  <a id="totop" title="" style="display: block;">返回顶部</a>
 </div>
</footer>

    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
