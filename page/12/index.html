<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hanks&#39; Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="android,web,node,python">
<meta property="og:type" content="website">
<meta property="og:title" content="Hanks' Blog">
<meta property="og:url" content="http://hanks.pub/page/12/index.html">
<meta property="og:site_name" content="Hanks' Blog">
<meta property="og:description" content="android,web,node,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hanks' Blog">
<meta name="twitter:description" content="android,web,node,python">
  
  
    <link rel="icon" href="/images/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'> -->
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo"></a>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      
        <a class="main-nav-link" href="/archives">归档</a>
      
        <a class="main-nav-link" href="/daily">日报</a>
      
        <a class="main-nav-link" href="/eye-video">开眼</a>
      
        <a class="main-nav-link" href="/joke">joke</a>
      
        <a class="main-nav-link" href="/picture-fight">斗图</a>
      
        <a class="main-nav-link" href="/atom.xml">RSS</a>
      
    </nav>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/daily" class="mobile-nav-link">日报</a>
  
    <a href="/eye-video" class="mobile-nav-link">开眼</a>
  
    <a href="/joke" class="mobile-nav-link">joke</a>
  
    <a href="/picture-fight" class="mobile-nav-link">斗图</a>
  
    <a href="/atom.xml" class="mobile-nav-link">RSS</a>
  
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="info">
     <div class="content">
       <div>
         <a href="https://github.com/hanks-zyh"><img class="avatar" src="https://avatars2.githubusercontent.com/u/6268322?v=3&s=460" alt="" /></a>
       </div>
       <div class="name">
         <h2 >Hanks</h2>
       </div>
       <p>‭100100011101‬</p>
       <div class="account">
         <div class="account-item">
           <a href="http://weibo.com/u/2359002991"><img src="http://ww1.sinaimg.cn/large/8c9b876fjw1f3ik9y4q7hj205k05kdfx.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
              <a href="http://www.zhihu.com/people/yuhan-zhang-36"><img src="http://ww2.sinaimg.cn/large/8c9b876fjw1f3ik7sv63wj205k05k3yg.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
         <div class="account-item">
           <a href="https://github.com/hanks-zyh"> <img src="http://ww1.sinaimg.cn/large/8c9b876fly1fe196fbtiqj205k05ka9u.jpg" style="width:40px;height:40px;border-radius: 50%;"></a>
         </div>
       </div>
     </div>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">最新发布</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/11/android-night-mode/">Android 夜间模式</a>
          </li>
        
          <li>
            <a href="/2017/09/28/lua-into-android/">Lua 嵌入 Android 原理</a>
          </li>
        
          <li>
            <a href="/2017/04/28/lua-in-android/">探究 lua 在 Android 中的应用</a>
          </li>
        
          <li>
            <a href="/2017/03/26/node-image-recognition/">Node 识别图片中的文字</a>
          </li>
        
          <li>
            <a href="/2017/03/22/proxy-test/">请求代理</a>
          </li>
        
          <li>
            <a href="/2017/02/16/android-customview-inputmethod/">Android 自定义 view 连接输入法</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-lua/">Android 与 Lua</a>
          </li>
        
          <li>
            <a href="/2017/01/10/android-markdown-render/">Android 下 Markdown 渲染</a>
          </li>
        
          <li>
            <a href="/2017/01/09/android-webview-font/">Android 中 webview 自定义字体</a>
          </li>
        
          <li>
            <a href="/2016/09/25/slack-bot/">slack bot</a>
          </li>
        
          <li>
            <a href="/2016/09/19/webapp/">让网页更适配移动设备</a>
          </li>
        
          <li>
            <a href="/2016/09/05/weex-2333/">体验 weex —— 写一个表情包应用</a>
          </li>
        
          <li>
            <a href="/2016/08/31/nestedscrollchild/">WebView 实现 NestedScrollingChild</a>
          </li>
        
          <li>
            <a href="/2016/08/29/nestedchildparent/">NestedScrollingParent 实现复杂交互效果</a>
          </li>
        
          <li>
            <a href="/2016/08/04/telegram-bot/">写一个福利 Telegram 机器人</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Activity/" style="font-size: 10px;">Activity</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Atom/" style="font-size: 10px;">Atom</a> <a href="/tags/Dagger2/" style="font-size: 10px;">Dagger2</a> <a href="/tags/EditText/" style="font-size: 10px;">EditText</a> <a href="/tags/Express/" style="font-size: 11.67px;">Express</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/Framework/" style="font-size: 11.67px;">Framework</a> <a href="/tags/HTML-CSS/" style="font-size: 10px;">HTML/CSS</a> <a href="/tags/Jade/" style="font-size: 10px;">Jade</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/LAMP/" style="font-size: 10px;">LAMP</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Lua/" style="font-size: 13.33px;">Lua</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/NestedScrolling/" style="font-size: 13.33px;">NestedScrolling</a> <a href="/tags/Node-js/" style="font-size: 13.33px;">Node.js</a> <a href="/tags/OS-X/" style="font-size: 10px;">OS X</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Python/" style="font-size: 11.67px;">Python</a> <a href="/tags/React-Native/" style="font-size: 18.33px;">React-Native</a> <a href="/tags/Refactoring/" style="font-size: 10px;">Refactoring</a> <a href="/tags/Rx/" style="font-size: 10px;">Rx</a> <a href="/tags/RxJava/" style="font-size: 13.33px;">RxJava</a> <a href="/tags/Rxandroid/" style="font-size: 10px;">Rxandroid</a> <a href="/tags/Rxjava/" style="font-size: 11.67px;">Rxjava</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Scrapy/" style="font-size: 11.67px;">Scrapy</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/SwipeRefreshLayout/" style="font-size: 10px;">SwipeRefreshLayout</a> <a href="/tags/Telegram/" style="font-size: 10px;">Telegram</a> <a href="/tags/TextView/" style="font-size: 10px;">TextView</a> <a href="/tags/Ubuntu/" style="font-size: 16.67px;">Ubuntu</a> <a href="/tags/VPS/" style="font-size: 10px;">VPS</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Vue-js/" style="font-size: 10px;">Vue.js</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/WebView/" style="font-size: 11.67px;">WebView</a> <a href="/tags/bot/" style="font-size: 10px;">bot</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/interpolator/" style="font-size: 10px;">interpolator</a> <a href="/tags/leancloud/" style="font-size: 10px;">leancloud</a> <a href="/tags/mac-os/" style="font-size: 10px;">mac os</a> <a href="/tags/slack/" style="font-size: 10px;">slack</a> <a href="/tags/virtualBox/" style="font-size: 10px;">virtualBox</a> <a href="/tags/weex/" style="font-size: 10px;">weex</a> <a href="/tags/代理/" style="font-size: 10px;">代理</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/学习/" style="font-size: 10px;">学习</a> <a href="/tags/必备知识/" style="font-size: 10px;">必备知识</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/热修复/" style="font-size: 11.67px;">热修复</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/自动化/" style="font-size: 10px;">自动化</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/hanks-zyh">hanks-zyh</a>
          </li>
        
          <li>
            <a href="http://kiya.space">Kiya‘s space</a>
          </li>
        
          <li>
            <a href="http://rocko.xyz/">Rocko&#39;s blog</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="wx">
      <h3 class="widget-title">微信公众号</h3>
      <img src='http://ww1.sinaimg.cn/large/8c9b876fly1fe0nnlvokpj20by0bywfi.jpg' height="100%" width="100%" >
      <p>搜索公众号: CodeProvider</p>
    </div>
  </div>


  
</aside>
        
        <section id="main" class="mdl-shadow--2dp">
  
    <article id="post-NYOJ题目585_取石子（六）hdu_题目1850Being_a_Good_Boy_in_Spring_Festival_尼姆博奕（Nimm_Game）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/25/NYOJ题目585_取石子（六）hdu_题目1850Being_a_Good_Boy_in_Spring_Festival_尼姆博奕（Nimm_Game）/">NYOJ题目585 取石子（六）hdu 题目1850Being a Good Boy in Spring Festival 尼姆博奕（Nimm Game）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<div class="problem-display" style="font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<h2 style="margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体">
取石子（六）</h2>
<div class="problem-ins" style="text-align:center">时间限制：<span class="editable highlight" id="problem[time_limit]" style="color:rgb(113,32,21)">1000</span>&nbsp;ms &nbsp;|&nbsp; 内存限制：<span class="editable highlight" id="problem[memory_limit]" style="color:rgb(113,32,21)">65535</span>&nbsp;KB</div>
<div class="problem-ins" style="text-align:center">难度：<span class="editable highlight" style="color:rgb(113,32,21)">3</span></div>
</div>
<div class="clr" style="clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19px">
</div>
<dl class="problem-display" style="margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
描述</dt><dd style="margin:0px; padding:0px"><span style="font-family:宋体; color:rgb(34,34,34)">最近</span><span lang="EN-US" style="font-family:Verdana,sans-serif; color:rgb(34,34,34)">TopCoder</span><span style="font-family:宋体; color:rgb(34,34,34)">的</span><span lang="EN-US" style="font-family:Verdana,sans-serif; color:rgb(34,34,34)">PIAOYI</span><span style="font-family:宋体; color:rgb(34,34,34)">和</span><span lang="EN-US" style="font-family:Verdana,sans-serif; color:rgb(34,34,34)">HRDV</span><span style="font-family:宋体; color:rgb(34,34,34)">很无聊，于是就想了一个游戏，游戏是这样的：有</span><span lang="EN-US" style="font-family:Verdana,sans-serif; color:rgb(34,34,34)">n</span><span style="font-family:宋体; color:rgb(34,34,34)">堆石子</span><span lang="EN-US" style="font-family:Verdana,sans-serif; color:rgb(34,34,34)">,</span><span style="font-family:宋体; color:rgb(34,34,34)">两个人轮流从其中某一堆中任意取走一定的石子</span><span lang="EN-US" style="font-family:Verdana,sans-serif; color:rgb(34,34,34)">,</span><span style="font-family:宋体; color:rgb(34,34,34)">最后不能取的为输家，注意：</span><span style="font-family:Verdana,sans-serif; color:rgb(34,34,34)">&nbsp;</span><span style="font-family:宋体; color:rgb(34,34,34)">每次只能从一堆取任意个，可以取完这堆，但不能不取。假设</span><span lang="EN-US" style="font-family:Verdana,sans-serif; color:rgb(34,34,34)">PIAOYI</span><span style="font-family:宋体; color:rgb(34,34,34)">先取石子，请你帮他判断他是否能赢（假设他们取的过程中不发生失误</span><span lang="EN-US" style="font-family:Verdana,sans-serif; color:rgb(34,34,34)">,</span><span style="font-family:宋体; color:rgb(34,34,34)">他们足够聪明<img src="http://acm.nyist.net/JudgeOnline/admin/kind/plugins/emoticons/6.gif" border="0" alt="" style="border:0px none"></span><span style="font-family:宋体; color:rgb(34,34,34)">）。</span>
<div class="clr" style="clear:both"></div>
<dl class="others" style="margin:0px; padding:0px"><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输入</dt><dd style="margin:0px; padding:0px">第一行输入n，代表有n组测试数据(n&lt;=10000)<br>
以下每组测试数据包含两行：第一行：包含一个整数m，代表本组测试数据有m（m&lt;=1000）堆石子；<br>
：第二行：包含m个整数Ai(Ai&lt;=100)，分别代表第i堆石子的数量。<br>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输出</dt><dd style="margin:0px; padding:0px">若PIAOYI赢输出“PIAOYI”，否则输出“HRDV”注意每组结果占一行。。<br>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输入</dt><dd style="margin:0px; padding:0px">
<pre id="sample_input" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">3
2
1 1
3
3 8 11
2
5 10</pre>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输出</dt><dd style="margin:0px; padding:0px">
<pre id="sample_output" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">HRDV
HRDV
PIAOYI</pre>
</dd></dl>
</dd></dl>
<br>
<p></p>
<p><br>
</p>
<p>各堆石子异或和为0，奇异局势，先取者必败</p>
<p><br>
</p>
<p><pre name="code" class="cpp"> 
/***************************
# 2013-8-25 18:30:46
# Time: 788MS   Memory: 232KB
# Author: zyh
# Status: Accepted
***************************/ 


#include&lt;stdio.h&gt;

int main()
{
	int n,m,i,sum,tmp;
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		scanf(&quot;%d&quot;,&amp;m);
		sum=0;
		for(i=0;i&lt;m;i++){
			scanf(&quot;%d&quot;,&amp;tmp);
			sum ^= tmp;
		}
		if(sum==0) printf(&quot;HRDV\n&quot;);	
		else printf(&quot;PIAOYI\n&quot;);	
	}
	return 0;
}         </pre></p>
<h1 style="text-align:center; color:rgb(26,92,200)">Being a Good Boy in Spring Festival</h1>
<span size="&#43;0" style=""></span>
<div style="text-align:center"><span style="color:green; font-family:Arial; font-weight:bold">Time Limit: 1000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)</span></div>
<strong></strong>
<div style="text-align:center"><span style="color:green; font-family:Arial">Total Submission(s): 3274&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1909</span></div>
<br>
<br>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">一年在外 父母时刻牵挂<br>
春节回家 你能做几天好孩子吗<br>
寒假里尝试做做下面的事情吧<br>
<br>
陪妈妈逛一次菜场<br>
悄悄给爸爸买个小&#31036;物<br>
主动地 强烈地 要求洗一次碗<br>
某一天早起 给爸妈用心地做回早餐<br>
<br>
如果愿意 你还可以和爸妈说<br>
咱们玩个小游戏吧 ACM课上学的呢～<br>
<br>
下面是一个二人小游戏：桌子上有M堆扑克牌；每堆牌的数量分别为Ni(i=1…M)；两人轮流进行；每走一步可以任意选择一堆并取走其中的任意张牌；桌子上的扑克全部取光，则游戏结束；最后一次取牌的人为胜者。<br>
现在我们不想研究到底先手为胜还是为负，我只想问大家：<br>
——“先手的人如果想赢，第一步有几种选择呢？”<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">输入数据包含多个测试用例，每个测试用例占2行，首先一行包含一个整数M(1&lt;M&lt;=100)，表示扑克牌的堆数，紧接着一行包含M个整数Ni(1&lt;=Ni&lt;=1000000，i=1…M)，分别表示M堆扑克的数量。M为0则表示输入数据的结束。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">如果先手的人能赢，请输出他第一步可行的方案数，否则请输出0，每个实例的输出占一行。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">3
5 7 9
0</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">1</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<span style="font-size:14px">求第一步取纸牌方案，可先求出是否为奇异局势<span style="font-family:SimHei; background-color:rgb(248,248,248); line-height:32px; text-indent:28px">如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设&nbsp;a &lt; b&nbsp;&lt; c,我们只要将&nbsp;c&nbsp;变为&nbsp;a（&#43;）b,即可,因为有如下的运算结果: a（&#43;）b（&#43;）(a（&#43;）b)=(a（&#43;）a)（&#43;）(b（&#43;）b)=0（&#43;）0=0。要将c&nbsp;变为a（&#43;）b，只要从&nbsp;c中减去&nbsp;c-（a（&#43;）b）即可。</span></span>
<p></p>
<p><span style="font-size:14px"><span style="font-family:SimHei; background-color:rgb(248,248,248); line-height:32px; text-indent:28px">所以 c- a（&#43;）b 即为一种取法， 即 c &gt; a(&#43;)b 为一种方案，</span></span></p>
<p><br>
</p>
<p><br>
<pre name="code" class="cpp">#include&lt;stdio.h&gt;

int main()
{
    int n,sum,cnt,i,a[102];
    while(scanf(&quot;%d&quot;,&amp;n),n)
    {
        sum = cnt = 0;
        for(i=0;i&lt;n;i++){
            scanf(&quot;%d&quot;,&amp;a[i]);
            sum ^= a[i];
        }
        for(i=0;i&lt;n;i++){
            if(a[i] &gt; (sum^a[i])) cnt++; //注意异或的优先级 
        }
        printf(&quot;%d\n&quot;,cnt);
    }
    return 0;
} </pre><br>
<br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ题目358_取石子（五）hdu题目2516_取石子游戏_Fibonacci’s_Game（斐波那契博弈）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/25/NYOJ题目358_取石子（五）hdu题目2516_取石子游戏_Fibonacci’s_Game（斐波那契博弈）/">NYOJ题目358 取石子（五）hdu题目2516 取石子游戏 Fibonacci’s Game（斐波那契博弈）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<div class="problem-display" style="font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<h2 style="margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体">
取石子(五）</h2>
<div class="problem-ins" style="text-align:center">时间限制：<span class="editable highlight" id="problem[time_limit]" style="color:rgb(113,32,21)">1000</span>&nbsp;ms &nbsp;|&nbsp; 内存限制：<span class="editable highlight" id="problem[memory_limit]" style="color:rgb(113,32,21)">65535</span>&nbsp;KB</div>
<div class="problem-ins" style="text-align:center">难度：<span class="editable highlight" style="color:rgb(113,32,21)">4</span></div>
</div>
<div class="clr" style="clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19px">
</div>
<dl class="problem-display" style="margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
描述</dt><dd style="margin:0px; padding:0px"><span style="color:rgb(34,34,34); font-family:Verdana,Arial,Tahoma; line-height:21px">himdd最近很想玩游戏，于是他找到acmj和他一起玩，游戏是这样的：有一堆石子,两个人轮流从其中取走一定的石子,取走最后所有石子的人为赢家,不过得遵循如下规则:<br>
1.第一次取不能取完,至少取1颗.<br>
</span>
<p style="margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px">
<span style="color:rgb(34,34,34); font-family:Verdana,Arial,Tahoma; line-height:21px">2.从第二次开始,每个人取的石子数至少为1,至多为对手刚取的石子数的两倍。</span></p>
<p style="margin-top:1em; margin-bottom:1em; padding-top:0px; padding-bottom:0px">
<span style="color:rgb(34,34,34); font-family:Verdana,Arial,Tahoma; line-height:21px">himdd事先想知道自己会不会赢，你能帮帮他吗？（每次himdd先手）</span></p>
<div class="clr" style="clear:both"></div>
<dl class="others" style="margin:0px; padding:0px"><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输入</dt><dd style="margin:0px; padding:0px">有多组测试数据，每组有一个整数n(2&lt;=n&lt;2^64);<br>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输出</dt><dd style="margin:0px; padding:0px">himdd会赢输出Yes,否则输出No;</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输入</dt><dd style="margin:0px; padding:0px">
<pre id="sample_input" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">2
5
6</pre>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输出</dt><dd style="margin:0px; padding:0px">
<pre id="sample_output" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">No
No
Yes</pre>
</dd></dl>
</dd></dl>
<br>
<p></p>
<p><br>
</p>
<p>先取者 ：斐波纳契数列为必败点</p>
<p></p>
<pre name="code" class="cpp"> 
/***************************
# 2013-8-25 11:33:04 
# Time: 8MS   Memory: 232KB
# Author: zyh
# Status: Accepted
***************************/ 

#include&lt;stdio.h&gt;

long long n,f[100];
int main()
{

	f[0] = 2; f[1] = 3;
	for(int i=2;i&lt;100;i++){
		f[i] = f[i-1] + f[i-2];
	}
	
	while(scanf(&quot;%lld&quot;,&amp;n)!=EOF)
	{
		int flag = 1;
		for(int i=0;i&lt;100;i++){
			if(f[i]==n) {
				flag =0;
				break;
			}
		}
		printf(&quot;%s\n&quot;,!flag?&quot;No&quot;:&quot;Yes&quot;);
	}
	return 0;
}         </pre><br>
<br>
<p></p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p></p>
<h1 style="text-align:center; color:rgb(26,92,200)">取石子游戏</h1>
<span size="&#43;0" style=""></span>
<div style="text-align:center"><span style="color:green; font-family:Arial"><strong>Time Limit: 2000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)</strong></span></div>
<strong></strong>
<div style="text-align:center"><span style="color:green; font-family:Arial">Total Submission(s): 2069&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1193</span></div>
<br>
<br>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出&quot;Second win&quot;.先取者胜输出&quot;First win&quot;.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">输入有多组.每组第1行是2&lt;=n&lt;2^31. n=0退出.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">先取者负输出&quot;Second win&quot;. 先取者胜输出&quot;First win&quot;. <br>
参看Sample Output.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">2
13
10000
0</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">Second win
Second win
First win</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<pre name="code" class="cpp">/***************************
# 2013-8-25 11:33:04 
# Time: 0MS   Memory: 228KB
# Author: zyh
# Status: Accepted
***************************/ 

#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;

using namespace std;

long long n,f[50];
int main()
{

    f[0] = 2; f[1] = 3;
    for(int i=2;i&lt;45;i++){
        f[i] = f[i-1] + f[i-2];
    }
    
    while(scanf(&quot;%lld&quot;,&amp;n),n)
    {
        int flag = 1;
        for(int i=0;i&lt;45;i++){
            if(f[i]==n) {
                flag =0;
                break;
            }
        }
        printf(&quot;%s\n&quot;,!flag?&quot;Second win&quot;:&quot;First win&quot;);
    }
    return 0;
} </pre><br>
<br>
<br>
<p></p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目161_取石子（四）_威佐夫博奕（Wythoff_Game）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/25/NYOJ_题目161_取石子（四）_威佐夫博奕（Wythoff_Game）/">NYOJ 题目161 取石子（四） 威佐夫博奕（Wythoff Game）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<div class="problem-display" style="font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<h2 style="margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体">
取石子 (四）</h2>
<div class="problem-ins" style="text-align:center">时间限制：<span class="editable highlight" id="problem[time_limit]" style="color:rgb(113,32,21)">1000</span>&nbsp;ms &nbsp;|&nbsp; 内存限制：<span class="editable highlight" id="problem[memory_limit]" style="color:rgb(113,32,21)">65535</span>&nbsp;KB</div>
<div class="problem-ins" style="text-align:center">难度：<span class="editable highlight" style="color:rgb(113,32,21)">4</span></div>
</div>
<div class="clr" style="clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19px">
</div>
<dl class="problem-display" style="margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
描述</dt><dd style="margin:0px; padding:0px"><span style="font-family:'Times New Roman',Times,serif; font-size:16px; border-spacing:2px">有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。</span>
<div class="clr" style="clear:both"></div>
<dl class="others" style="margin:0px; padding:0px"><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输入</dt><dd style="margin:0px; padding:0px">输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输出</dt><dd style="margin:0px; padding:0px">输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输入</dt><dd style="margin:0px; padding:0px">
<pre id="sample_input" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">2 1
8 4
4 7</pre>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输出</dt><dd style="margin:0px; padding:0px">
<pre id="sample_output" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">0
1
0</pre>
</dd></dl>
</dd></dl>
<br>
<p></p>
<p><br>
</p>
<p></p>
<pre name="code" class="cpp"> 
/***************************
# 2013-08-23 10:39:17
# Time: 0MS   Memory: 232KB
# Author: zyh
# Status: Accepted
***************************/ 
#include&lt;math.h&gt;
#include&lt;stdio.h&gt;

int main()
{
	int n,m,tmp,k;
	
	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
	{
		if(n&gt;m){tmp =n; n=m; m =tmp;}	
		k = m-n;
		if( fabs(floor((3.2360679774998/2.0)*k)- n)&lt;0.0000000000001) printf(&quot;0\n&quot;);
		else printf(&quot;1\n&quot;);
	}
	return 0;
}         </pre><br>
<br>
<p></p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目23_取石子（一），hdu_题目1846_Brave_Game_巴什博奕（Bash_Game）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/25/NYOJ_题目23_取石子（一），hdu_题目1846_Brave_Game_巴什博奕（Bash_Game）/">NYOJ 题目23 取石子（一），hdu 题目1846 Brave Game 巴什博奕（Bash Game）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p><br>
</p>
<p></p>
<div class="problem-display" style="font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<h2 style="margin:0px; padding:0px; font-size:18px; text-align:center; color:rgb(113,32,21); font-family:微软雅黑,黑体">
取石子（一）</h2>
<div class="problem-ins" style="text-align:center">时间限制：<span class="editable highlight" id="problem[time_limit]" style="color:rgb(113,32,21)">3000</span>&nbsp;ms &nbsp;|&nbsp; 内存限制：<span class="editable highlight" id="problem[memory_limit]" style="color:rgb(113,32,21)">65535</span>&nbsp;KB</div>
<div class="problem-ins" style="text-align:center">难度：<span class="editable highlight" style="color:rgb(113,32,21)">2</span></div>
</div>
<div class="clr" style="clear:both; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun; font-size:13px; line-height:19px">
</div>
<dl class="problem-display" style="margin:0px; padding:0px; font-size:14px; color:rgb(70,70,70); font-family:Tahoma,Arial,sans-serif,simsun">
<dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
描述</dt><dd style="margin:0px; padding:0px">一天，TT在寝室闲着无聊，和同寝的人玩起了取石子游戏，而由于条件有限，他/她们是用旺仔小馒头当作石子。游戏的规则是这样的。设有一堆石子，数量为N（1&lt;=N&lt;=1000000），两个人轮番取出其中的若干个，每次最多取M个（1&lt;=M&lt;=1000000），最先把石子取完者胜利。我们知道，TT和他/她的室友都十分的聪明，那么如果是TT先取，他/她会取得游戏的胜利么？
<div class="clr" style="clear:both"></div>
<dl class="others" style="margin:0px; padding:0px"><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输入</dt><dd style="margin:0px; padding:0px">第一行是一个正整数n表示有n组测试数据<br>
输入有不到1000组数据，每组数据一行，有两个数N和M,之间用空&#26684;分隔。</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
输出</dt><dd style="margin:0px; padding:0px">对于每组数据，输出一行。如果先取的TT可以赢得游戏，则输出“Win”，否则输出“Lose”（引号不用输出）</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输入</dt><dd style="margin:0px; padding:0px">
<pre id="sample_input" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">2
1000 1
1 100</pre>
</dd><dt style="margin:1em 0px 0.2em; padding:0px; color:rgb(113,32,21); font-size:16px; font-weight:bold">
样例输出</dt><dd style="margin:0px; padding:0px">
<pre id="sample_output" style="margin-top:0px; margin-bottom:0px; padding:5px 10px; font-family:Consolas,'Courier New','DejaVu Sans Mono','Droid Sans Mono',monospace; background-color:rgb(239,239,239); border:1px solid rgb(204,204,204); min-height:20px; line-height:1.5em">Lose
Win</pre>
</dd></dl>
</dd></dl>
<br>
<p></p>
<p><br>
</p>
<p><pre name="code" class="cpp"> 
#include&lt;stdio.h&gt;
int main()
{
	int t,m,n;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		if(n%(m+1)!=0)
		printf(&quot;Win\n&quot;);
		else
		printf(&quot;Lose\n&quot;);
	}
	return 0;
}
        </pre></p>
<p><br>
</p>
<p><br>
</p>
<h1 style="text-align:center; color:rgb(26,92,200)">Brave Game</h1>
<span size="&#43;0" style=""></span>
<div style="text-align:center"><span style="color:green; font-family:Arial; font-weight:bold">Time Limit: 1000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)</span></div>
<strong></strong>
<div style="text-align:center"><span style="color:green; font-family:Arial">Total Submission(s): 4852&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 3198</span></div>
<br>
<br>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">十年前读大学的时候，中国每年都要从国外引进一些电影大片，其中有一部电影就叫《勇敢者的游戏》（英文名称：Zathura），一直到现在，我依然对于电影中的部分电脑特技印象深刻。<br>
今天，大家选择上机考试，就是一种勇敢（brave）的选择；这个短学期，我们讲的是博弈（game）专题；所以，大家现在玩的也是“勇敢者的游戏”，这也是我命名这个题目的原因。<br>
当然，除了“勇敢”，我还希望看到“诚信”，无论考试成绩如何，希望看到的都是一个真实的结果，我也相信大家一定能做到的~<br>
<br>
各位勇敢者要玩的第一个游戏是什么呢？很简单，它是这样定义的：<br>
1、&nbsp;&nbsp;本游戏是一个二人游戏;<br>
2、&nbsp;&nbsp;有一堆石子一共有n个；<br>
3、&nbsp;&nbsp;两人轮流进行;<br>
4、&nbsp;&nbsp;每走一步可以取走1…m个石子；<br>
5、&nbsp;&nbsp;最先取光石子的一方为胜；<br>
<br>
如果游戏的双方使用的都是最优策略，请输出哪个人能赢。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">输入数据首先包含一个正整数C(C&lt;=100)，表示有C组测试数据。<br>
每组测试数据占一行，包含两个整数n和m（1&lt;=n,m&lt;=1000），n和m的含义见题目描述。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">2
23 2
4 3</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">first
second</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<br>
<pre name="code" class="cpp">/***************************
# 2013-8-23 16:58:15 
# Time: MS   Memory: KB
# Author: zyh
# Status: Accepted
***************************/ 

#include&lt;stdio.h&gt;
int main()
{
    int n,m,c;
    scanf(&quot;%d&quot;,&amp;c);
    while(c--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        printf(&quot;%s\n&quot;,n%(m+1)?&quot;first&quot;:&quot;second&quot;); 
    }
    return 0;
} </pre><br>
<br>
<br>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-博弈论_入门总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/25/博弈论_入门总结/">博弈论 入门总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="color:rgb(202,0,0); text-decoration:none; font-size:14px"><strong>（收集于网络）</strong></span></p>
<p style="font-size:14px; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Arial; color:rgb(202,0,0); text-decoration:none; font-size:14px"><strong><span style="color:rgb(51,204,204)"><a target="_blank" href="http://blog.csdn.net/zhangxiang0125/article/details/view/18930.htm" style="color:rgb(202,0,0); text-decoration:none">博弈论</a></span></strong></span><span style="font-size:14px"><span style="font-family:Arial"><strong><span style="color:rgb(51,204,204)">：</span></strong></span><span style="font-family:FangSong_GB2312">是二人或多人在平等的对局中各自利用对方的策略变换自己的对抗策略，达到取胜目标的理论。博弈论是研究互动决策的理论。博弈可以分析自己与对手的利弊关系，从而确立自己在博弈中的优势，因此有不少博弈理论，可以帮助对弈者分析局势，从而采取相应策略，最终达到取胜的目的。</span></span><span style="font-family:FangSong_GB2312; font-size:14px">（摘自百度百科）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">（一）<strong><span style="color:rgb(255,0,0)"><span style="text-decoration:underline">巴什博奕（Bash Game）</span></span></strong></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><span style="color:#008000">只有</span><strong><span style="color:#3333ff">一堆</span></strong><span style="color:#008000">n个物品，两个人轮流从这堆物品中取物，规定每次</span><strong><span style="color:#3333ff">至少取一个</span></strong><span style="color:#008000">，</span><strong><span style="color:#3333ff">最多取m个</span></strong><span style="color:#008000">。最后</span><strong><span style="color:#3333ff">取光者得胜</span></strong><span style="color:#008000">。</span></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><br>
</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">显然，如果n=m&#43;1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：</span><span style="font-size:14px">每个回合时m&#43;1个，</span><span style="font-size:14px">如果</span><span style="font-size:14px; color:rgb(0,128,0)">n=（m&#43;1)*r&#43;s</span><span style="font-size:14px">，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m&#43;1-k个，结果剩下（m&#43;1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m&#43;1）的倍数，就能最后获胜。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十<br>
个，谁能报到100者胜。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><br>
巴什博弈博弈论里面最简单的一种形式。以下题目利用巴什博弈可以轻松解决：</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">1.&nbsp;<a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=1846" style="color:rgb(202,0,0); text-decoration:none">http://acm.hdu.edu.cn/showproblem.php?pid=1846</a>&nbsp;（brave game）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">2.&nbsp;<a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=2147" style="color:rgb(202,0,0); text-decoration:none">http://acm.hdu.edu.cn/showproblem.php?pid=2147</a>&nbsp;（kiki's game）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">3.&nbsp;<a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=2149" style="color:rgb(202,0,0); text-decoration:none">http://acm.hdu.edu.cn/showproblem.php?pid=2149</a>&nbsp;（public sale）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">4.&nbsp;<a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=2188" style="color:rgb(202,0,0); text-decoration:none">http://acm.hdu.edu.cn/showproblem.php?pid=2188</a>&nbsp;（选拔志愿者）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><br>
</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">下面介绍分析此类题目的通用方法：P/N分析：</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">P点： 即必败点，某玩家位于此点，只要对方无失误，则必败；</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">N点： 即必胜点，某玩家位于此点，只要自己无失误，则必胜。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">三个定理：</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">定理：</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp; 一、 所有终结点都是必败点P（上游戏中，轮到谁拿牌，还剩0张牌的时候，此人就输了，因为无牌可取）；</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp;&nbsp;&nbsp; 二、所有一步能走到必败点P的就是N点；</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp;&nbsp;&nbsp; 三、通过一步操作只能到N点的就是P点；</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">如：</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"></span></p>
<div>
<div>Subtraction Games:</div>
<div>subtraction set S = {1, 3, 4}</div>
</div>
<p></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"></span></p>
<div>
<div><span style="color:red">x </span><span style="color:red">:&nbsp;&nbsp; </span><span style="color:red">0 1</span><span style="color:red">&nbsp;</span><span style="color:red">2 3 4</span><span style="color:red">&nbsp;</span><span style="color:red">5 6 7 8</span><span style="color:red">&nbsp;</span><span style="color:red">9
 10 11 12 13 14</span><span style="color:red">…</span></div>
<div><span style="color:red">Pos</span><span style="color:red">:</span><span style="color:red"> P N P N N N N P N P</span><span style="color:red">&nbsp;</span><span style="color:red">N</span><span style="color:red">&nbsp;</span><span style="color:red">N</span><span style="color:red">&nbsp;&nbsp;</span><span style="color:red">N</span><span style="color:red">&nbsp;</span><span style="color:red">N</span><span style="color:red">&nbsp;</span><span style="color:red">P</span><span style="color:red">…</span></div>
</div>
<br>
<p></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">以上题目均可以通过P/N分析法来解决。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">这几个题目都非常的简单。下面仅对2149做简单分析：（P/N分析也可以）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先明确使用巴什博弈有个前提（特点）每次拿的数量是从1-m的不间断整数开始的。注意这一点很重要。无此条件巴什博弈不成立！</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实这个题目稍微动动脑就可以把它转换为巴什博弈（特点明显）。你就假设两人拍卖的时候是从给定的最高价开始—谁先拍卖到0谁就就是胜者。需要注意的是我们对特殊情况的考虑。</span></p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"><strong><span style="font-size:18px; color:#ff0000"><u>（二）Fibonacci’s Game（斐波那契博弈）</u></span></strong></span><br>
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"><strong><span style="font-size:18px; color:#ff0000"><u><br>
</u></span></strong></span></p>
<blockquote style="margin:0 0 0 40px; border:none; padding:0px">
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px"><span style="color:#009900">有</span><strong><span style="color:#3333ff">一堆</span></strong><span style="color:#009900">个数为n的石子，游戏双方轮流取石子，满足：</span></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px; color:#009900">1)先手不能在第一次把所有的石子取完；</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px"><span style="color:#009900">2)</span><strong><span style="color:#3333ff">之后每次</span></strong><span style="color:#009900">可以取的石子数介于</span><span style="color:#3333ff"><strong>1到对手刚取的石子数的2倍之间</strong></span><span style="color:#009900">（包含1和对手刚取的石子数的2倍）。</span></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px"><span style="color:#009900"><br>
</span></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">约定取走最后一个石子的人为赢家，求必败态。</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">这个和之前的Wythoff’s Game 和取石子游戏 有一个很大的不同点，就是游戏规则的动态化。之前的规则中，每次可以取的石子的策略集合是基本固定的，但是这次有规则2：一方每次可以取的石子数依赖于对手刚才取的石子数。</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">这个游戏叫做Fibonacci Nim，肯定和Fibonacci数列：f[n]：1,2,3,5,8,13,21,34,55,89,…&nbsp;有密切的关系。如果试验一番之后，可以猜测：先手胜当且仅当n不是Fibonacci数。换句话说，必败态构成Fibonacci数列。</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">就像“Wythoff博弈”需要“Beatty定理”来帮忙一样，这里需要借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。定理的证明可以在<a target="_blank" href="http://zh.wikipedia.org/wiki/%E9%BD%8A%E8%82%AF%E5%A4%9A%E5%A4%AB%E5%AE%9A%E7%90%86">这里</a>&nbsp;看到，不过我觉得更重要的是自己动手分解一下。</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">比如，我们要分解83，注意到83被夹在55和89之间，于是把83可以写成83=55&#43;28；然后再想办法分解28，28被夹在21和34之间，于是28=21&#43;7；依此类推 7=5&#43;2，故<img alt="" src="http://latex.codecogs.com/gif.latex?83%20=%2055%20&#43;%2021%20&#43;%205%20&#43;%202" style="border:none; max-width:100%">&nbsp;；</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">如果n=83，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，如果猜测正确的话，（面临这5颗的先手实际上是整个游戏的后手）那么一定是先手取走这5颗石子中的最后一颗，而这个我们可以通过第二类归纳法来绕过，同样的道理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">反过来如果n是Fibonacci数，比如n=89：记先手一开始所取的石子数为y，若y&gt;=34颗（也就是89的向前两项），那么一定后手赢，因为89-34=55=34&#43;21&lt;2*34，所以只需要考虑先手第一次取得石子数y&lt;34的情况即可，所以现在剩下的石子数x介于55到89之间，它一定不是一个Fibonacci数，于是我们把x分解成Fibonacci数：x=55&#43;f[i]&#43;…&#43;f[j]，若，如果f[j]&lt;=2y，那么对B就是面临x局面的先手，所以根据之前的分析，B只要先取f[j]个即可，以后再按之前的分析就可保证必胜。</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">下证：f[j]&lt;=2y</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">反证法：假设f[j]&gt;2y，则 y &lt; f[j]/2 = (f[j-1] &#43; f[j-2])/2 &lt; f[j-1]</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"></span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px">而最初的石子数是个斐波那契数，即 f[k]=x&#43;y &lt; f[k-1]&#43;f[i]&#43;…&#43;f[j]&#43;f[j-1] &lt;= f[k-1]&#43;f[i]&#43;f[i-1] &lt;= f[k-1]&#43;f[k-2] &lt;= f[k] （注意第一个不等号是严&#26684;的，矛盾！）</span></p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<a target="_blank" href="http://acm.nyist.net/JudgeOnline/problem.php?pid=135"><span style="font-size:12px">http://acm.nyist.net/JudgeOnline/problem.php?pid=135</span></a><br>
</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=2516">http://acm.hdu.edu.cn/showproblem.php?pid=2516</a><br>
</p>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; line-height:26px">
<span style="font-size:14px"><span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">（转）分析：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;n = 2时输出second；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;n = 3时也是输出second；&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;n = 4时，第一个人想获胜就必须先拿1个，这时剩余的石子数为3，此时无论第二个人如何取，第一个人都能赢，输出first；&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;n = 5时，first不可能获胜，因为他取2时，second直接取掉剩下的3个就会获胜，当他取1时，这样就变成了n为4的情形，所以输出的是second；&nbsp;&nbsp;&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;n = 6时，first只要去掉1个，就可以让局势变成n为5的情形，所以输出的是first；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;n = 7时，first取掉2个，局势变成n为5的情形，故first赢，所以输出的是first；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;n = 8时，当first取1的时候，局势变为7的情形，第二个人可赢，first取2的时候，局势变成n为6得到情形，也是第二个人赢，取3的时候，second直接取掉剩下的5个，所以n = 8时，输出的是second；&nbsp;&nbsp;&nbsp;&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;…………&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;从上面的分析可以看出，n为2、3、5、8时，这些都是输出second，即必败点，仔细的人会发现这些满足斐波那契数的规律，可以推断13也是一个必败点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">&nbsp;借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。n=12时，只要谁能使石子剩下8且此次取子没超过3就能获胜。因此可以把12看成8&#43;4，把8看成一个站，等价与对4进行&quot;气喘操作&quot;。又如13，13=8&#43;5，5本来就是必败态，得出13也是必败态。也就是说，只要是斐波那契数，都是必败点。</span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:13px; line-height:19px; background-color:rgb(254,254,242)">所以我们可以利用斐波那契数的公式：fib[i] = fib[i-1] &#43; fib[i-2]，只要n是斐波那契数就输出second。</span><br>
</span></p>
</blockquote>
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<p style="font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-family:Verdana,Arial,Helvetica,sans-serif; line-height:19px; background-color:rgb(254,254,242)"><br>
</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px; color:rgb(255,0,0)"><strong><br>
</strong></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px; color:rgb(255,0,0)"><strong>（三）威佐夫博奕（Wythoff Game）</strong></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:10px"><span style="font-size:14px"><span style="color:#008000">有</span><strong><span style="color:#3333ff">两堆</span></strong><span style="color:#008000">各若干个物品，两个人轮流从</span><strong><span style="color:#3333ff">某一堆或同</span></strong></span></span><span style="font-size:14px"><strong><span style="color:#3333ff">时从两堆中取同样多的物品</span></strong><span style="color:#008000">，规定每次</span><span style="color:#3333ff">至少取一个，多者不限</span><span style="color:#008000">，最后</span><span style="color:#3333ff"><strong>取光者得胜。</strong></span></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><span style="font-size:10px"><span style="font-size:14px"><br>
&nbsp; &nbsp; 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为<strong>局势</strong>，如果甲面对（0，0），那么甲已经输了，这种局势我们称为<strong>奇异局势</strong>。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。</span></span></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak &#43; k，奇异局势有<br>
如下三条性质：</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 1。任何自然数都包含在一个且仅有一个奇异局势中。<br>
&nbsp; &nbsp; 由于ak是未在前面出现过的最小自然数，所以有ak &gt; ak-1 ，而 bk= ak &#43; k &gt; ak-1 &#43; k-1 = bk-1 &gt; ak-1 。所以性质1。成立。<br>
&nbsp; &nbsp; 2。任意操作都可将奇异局势变为非奇异局势。<br>
&nbsp; &nbsp; 事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。<br>
&nbsp; &nbsp; 3。采用适当的方法，可以将非奇异局势变为奇异局势。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果a = ak ，b &gt; bk，那么，取走b&nbsp; – bk个物体，即变为奇异局势；如果 a = ak ，&nbsp; b &lt; bk ,则同时从两堆中拿走 ak – ab – ak个物体,变为奇异局势（ ab – ak , ab – ak&#43; b – ak）；如果a &gt; ak ，b= ak &#43; k,则从第一堆中拿走多余的数量a – ak 即可；如果a &lt;
 ak ，b= ak &#43; k,分两种情况，第一种，a=aj （j &lt; k）,从第二堆里面拿走 b – bj 即可；第二种，a=bj （j &lt; k）,从第二堆里面拿走 b – aj 即可。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp;&nbsp;</span><span style="font-size:14px"><span style="color:rgb(0,128,0)">ak =[k（1&#43;√5）/2]，bk= ak &#43; k&nbsp; （k=0，1，2，…,n 方括号表示取整函数)<br>
</span>奇妙的是其中出现了黄金分割数（1&#43;√5）/2 = 1。618…,因此,由ak，bk组成的矩形近&#20284;为黄金矩形，由于2/（1&#43;√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a=[（1&#43;√5）/2]，那么a = aj，bj = aj &#43; j，若不等于，那么a = aj&#43;1，bj&#43;1 = aj&#43;1&#43; j &#43; 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><a target="_blank" href="http://acm.nyist.net/JudgeOnline/problem.php?pid=161">http://acm.nyist.net/JudgeOnline/problem.php?pid=161</a><br>
</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><br>
</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><br>
</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp;</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">（三）<span style="color:rgb(255,0,0)"><strong><span style="text-decoration:underline">&#23612;姆博奕（Nimm Game）</span></strong></span></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><span style="color:#008000">有</span><strong><span style="color:#3333ff">三堆</span></strong><span style="color:#008000">各若干个物品，两个人轮流从</span><span style="color:#3333ff"><strong>某一堆取任意多</strong></span><span style="color:#008000">的物品，规定每次</span><span style="color:#3333ff">至少取一个，多者不限</span><span style="color:#008000">，最后</span><strong><span style="color:#3333ff">取光者得胜</span></strong><span style="color:#008000">。</span></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（&#43;）表示这种运算。这种运算和一般加法不同的一点是1&#43;1=0。先看（1，2，3）的按位模2加的结果：</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">1 =二进制01<br>
2 =二进制10<br>
3 =二进制11 （&#43;）<br>
———————<br>
0 =二进制00 （注意不进位）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 对于奇异局势（0，n，n）也一样，结果也是0。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 任何奇异局势（a，b，c）都有a（&#43;）b（&#43;）c =0。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">如果我们面对的是一个非奇异局势（a，b，c），要如何变为奇异局势呢？假设 a &lt; b&lt; c,我们只要将 c 变为 a（&#43;）b,即可,因为有如下的运算结果: a（&#43;）b（&#43;）(a（&#43;）b)=(a（&#43;）a)（&#43;）(b（&#43;）b)=0（&#43;）0=0。要将c 变为a（&#43;）b，</span><span style="font-size:14px"><span style="color:rgb(0,128,0)">只要从 c中减去 c-（a（&#43;）b）即可。<br>
</span><br>
&nbsp; &nbsp; 例1。（14，21，39），14（&#43;）21=27，39-27=12，所以从39中拿走12个物体即可达到奇异局势（14，21，27）。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 例2。（55，81，121），55（&#43;）81=102，121-102=19，所以从121中拿走19个物品<br>
就形成了奇异局势（55，81，102）。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp; &nbsp; 例3。（29，45，58），29（&#43;）45=48，58-48=10，从58中拿走10个，变为（29，4<br>
5，48）。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">下面先是一道简单的&#23612;姆博弈题目</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=1850" style="color:rgb(202,0,0); text-decoration:none"><span style="font-size:14px">http://acm.hdu.edu.cn/showproblem.php?pid=1850</span></a></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">只要运用上面的知识即可解决（具体细节见代码）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<br>
<br>
</p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">&nbsp;</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">然而这并不是博弈的重点，LCY老师讲到博弈之王道乃是SG&#20540;（具体见</span><a target="_blank" id="url_5" href="http://acm.hdu.edu.cn/forum/read.php?tid=6875" style="color:rgb(202,0,0); text-decoration:none"><span style="color:rgb(49,52,40)"><span style="font-size:14px">&nbsp;http://acm.hdu.edu.cn/forum/read.php?tid=6875</span></span></a><span style="font-size:14px">）。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">SG&#20540;：一个点的SG&#20540;就是一个不等于它的后继点的SG的且大于等于零的最小整数。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">我的理解：在步骤允许的情况下，与前面一个必败点的差（也就是说这个差是规定的、能走的、其中一个步数）！<br>
后继点：也就是按照题目要求的走法（比如取石子可以取的数量，方法）能够走一步达到的那个点。（sg&#20540;的理解很抽象。我的队友mo、xi说多画画就可以了）<br>
现在我们拿</span><a target="_blank" href="http://acm.hdu.edu.cn/showproblem.php?pid=1847" style="color:rgb(202,0,0); text-decoration:none"><span style="font-size:14px">http://acm.hdu.edu.cn/showproblem.php?pid=1847</span></a><span style="font-size:14px">这道题分析一下。</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">我们枚举下牌数为2-10的sg&#20540;：（SG(x)=mex{SG(x-S[i])}。）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">num： 2&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">sg&#20540;： 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">具体的代码如下：（当然这题用P/N分析要简单得多，这里仅理解sg&#20540;）</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
</p>
<div class="dp-highlighter bg_cpp" style="font-size:14px; font-family:Consolas,'Courier New',Courier,mono,serif; background-color:rgb(231,229,220); width:918.7166748046875px; overflow:auto; padding-top:1px; margin:18px 0px!important">
<div class="bar" style="padding-left:45px">
<div class="tools" style="padding:3px 8px 10px 10px; font-size:9px; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left-width:3px; border-left-style:solid; border-left-color:rgb(108,226,108)">
<strong>[cpp]</strong>&nbsp;<a target="_blank" href="http://blog.csdn.net/zhangxiang0125/article/details/6174639#" class="ViewSource" title="view plain" style="color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px">view
 plain</a><a target="_blank" href="http://blog.csdn.net/zhangxiang0125/article/details/6174639#" class="CopyToClipboard" title="copy" style="color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px">copy</a>
<div style="position:absolute; left:377px; top:3927px; width:18px; height:18px; z-index:99">
</div>
</div>
</div>
<ol start="1" class="dp-cpp" style="margin:0px 0px 1px 45px!important; padding:0px; border:none; list-style-position:initial; background-color:rgb(255,255,255); color:rgb(92,92,92)">
<li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span class="preprocessor" style="margin:0px; padding:0px; border:none; color:gray; background-color:inherit">#include&lt;cstdio&gt;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span class="preprocessor" style="margin:0px; padding:0px; border:none; color:gray; background-color:inherit">#include&lt;algorithm&gt;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">using</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;</span><span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">namespace</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;std;&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span class="preprocessor" style="margin:0px; padding:0px; border:none; color:gray; background-color:inherit">#define&nbsp;N&nbsp;1000&#43;10</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;arr[11],sg[N];&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;pre()</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//把1000以内的所有的可能一次拿的牌都算出来！&nbsp;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">{&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;arr[0]=1;&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">for</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;i=1;i&lt;=10;i&#43;&#43;)&nbsp;arr[i]=arr[i-1]*2;&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">return</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">}&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;mex(</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;x)</span><span class="comment" style="margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit">//这是求解改点的sg&#20540;的算法函数（采用记忆化搜索）&nbsp;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">{&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">if</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(sg[x]!=-1)&nbsp;</span><span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">return</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;sg[x];&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">bool</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;vis[N];&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;memset(vis,<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">false</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">,</span><span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">sizeof</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(vis));&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">for</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;i=0;i&lt;10;i&#43;&#43;)&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;temp=x-arr[i];&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">if</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(temp&lt;0)&nbsp;</span><span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">break</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">;&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg[temp]=mex(temp);&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vis[sg[temp]]=<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">true</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">;&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">for</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(</span><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;i=0;;i&#43;&#43;)&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">if</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(!vis[i])&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sg[x]=i;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">break</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">;&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">return</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;sg[x];&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">}&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit"><span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;main()&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">{&nbsp;&nbsp;</span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;freopen(<span class="string" style="margin:0px; padding:0px; border:none; color:blue; background-color:inherit">&quot;game.in&quot;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">,</span><span class="string" style="margin:0px; padding:0px; border:none; color:blue; background-color:inherit">&quot;r&quot;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">,stdin);&nbsp;freopen(</span><span class="string" style="margin:0px; padding:0px; border:none; color:blue; background-color:inherit">&quot;game.out&quot;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">,</span><span class="string" style="margin:0px; padding:0px; border:none; color:blue; background-color:inherit">&quot;w&quot;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">,stdout);&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="margin:0px; padding:0px; border:none; color:rgb(46,139,87); background-color:inherit; font-weight:bold">int</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;num;&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;pre();&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">while</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(scanf(</span><span class="string" style="margin:0px; padding:0px; border:none; color:blue; background-color:inherit">&quot;%d&quot;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">,&amp;num)!=EOF)&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(sg,-1,<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">sizeof</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(sg));&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">if</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">(mex(num))&nbsp;printf(</span><span class="string" style="margin:0px; padding:0px; border:none; color:blue; background-color:inherit">&quot;Kiki/n&quot;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">else</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;printf(</span><span class="string" style="margin:0px; padding:0px; border:none; color:blue; background-color:inherit">&quot;Cici/n&quot;</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">);&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold">return</span><span style="margin:0px; padding:0px; border:none; background-color:inherit">&nbsp;0;&nbsp;&nbsp;</span></span></li><li class="alt" style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">}&nbsp;&nbsp;</span></li><li style="margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:18px">
<span style="margin:0px; padding:0px; border:none; color:black; background-color:inherit">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li></ol>
</div>
<span style="font-family:Arial; font-size:14px"><span style="font-size:14px"></span></span>
<p style="font-size:14px; font-family:Arial"></p>
<div style="text-align:left; line-height:25px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248)">
<span style="line-height:38px; text-indent:2em"><span style="font-size:18px; color:#ff0000"><strong><u>（五）取火柴游戏</u></strong></span></span></div>
<p><span style="font-size:12px"><span style="line-height:32px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248)">题目1：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根，可将一堆全取走，但不可不取，<span style="color:#3333ff">最后取完者为胜</span>，求必胜的方法。&nbsp;</span></span></p>
<p><span style="font-size:12px"><span style="line-height:32px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248)">题目2：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根，可将一堆全取走，但不可不取，<span style="color:#3333ff">最后取完者为负</span>，求必胜的方法。</span></span></p>
<p><span style="line-height:32px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248)"><span style="font-size:12px">题目1 ：</span><span style="font-family:Arial; line-height:26px"><strong><span style="font-size:18px; color:#3333ff">&#23612;姆博奕（Nimm
 Game）</span></strong></span></span></p>
<p>题目2 : &nbsp;<strong><span style="font-size:18px"><span style="color:#3333ff">先者必败条件</span>：
<span style="color:#ff0000">奇异局势&amp;&amp; 充裕堆数目&gt;=2</span>&nbsp; &nbsp;或者 &nbsp;<span style="color:#ff0000">非奇异局势&amp;&amp; 孤单堆数目==n</span></span></strong></p>
<p><br>
</p>
<p>详解：点击<a target="_blank" href="http://qianmacao.blog.163.com/blog/static/20339718020122247154761/">博弈知识汇总</a></p>
<p><br>
</p>
<p><span style="font-size:12px; line-height:32px; background-color:rgb(248,248,248); font-family:Arial,Helvetica,simsun,u5b8bu4f53; text-indent:2em">推荐HDOJ题目</span></p>
<p><a target="_blank" rel="nofollow" href="http://acm.hdu.edu.cn/showproblem.php?pid=1907" style="font-size:12px; line-height:32px; background-color:rgb(248,248,248); font-family:Arial,Helvetica,simsun,u5b8bu4f53; text-indent:2em; text-decoration:none">http://acm.hdu.edu.cn/showproblem.php?pid=1907</a></p>
<p><a target="_blank" rel="nofollow" href="http://acm.hdu.edu.cn/showproblem.php?pid=2509" style="font-size:12px; line-height:32px; background-color:rgb(248,248,248); font-family:Arial,Helvetica,simsun,u5b8bu4f53; text-indent:2em; text-decoration:none">http://acm.hdu.edu.cn/showproblem.php?pid=2509</a></p>
<p style="line-height:25px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248); text-indent:2em">
<span style="line-height:32px"><span style="font-size:12px"><br>
</span></span></p>
<p style="line-height:25px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248); text-indent:2em">
<br>
</p>
<p style="line-height:25px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248); text-indent:2em">
<span style="line-height:32px"><span style="font-size:12px"><br>
主要是后继点和SG&#20540;的问题:<br>
SG&#20540;：一个点的SG&#20540;就是一个不等于它的后继点的SG的且大于等于零的最小整数。<br>
后继点：也就是按照题目要求的走法（比如取石子可以取的数量，方法）能够走一步达到的那个点。<br>
具体的有关SG&#20540;是怎么运用的希望大家自己多想想。<br>
课件后面有一个1536的代码。可以放在后面做做<br>
看到这里推荐大家做几道题：1846（最简单的博弈水题）<br>
1847（求SG&#20540;）</span></span></p>
<p style="line-height:25px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248); text-indent:2em">
<span style="font-size:12px; line-height:32px; text-indent:2em">有了上面的知识接下来我们来看看组合博弈（n堆石子）</span></p>
<p style="line-height:25px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248); text-indent:2em">
<span style="line-height:32px"><span style="font-size:12px">推荐大家看个资料：<br>
博弈-取石子游戏(推荐等级五星级)<br>
<a target="_blank" rel="nofollow" href="http://acm.hdu.edu.cn/forum/read.php?fid=20&amp;tid=5748" style="text-decoration:none">http://acm.hdu.edu.cn/forum/read.php?fid=20&amp;tid=5748</a><br>
<a target="_blank" rel="nofollow" href="http://hi.baidu.com/netnode/blog/item/30932c2edc7384514fc226ea.html" style="text-decoration:none">http://hi.baidu.com/netnode/blog/item/30932c2edc7384514fc226ea.html</a><br>
这里提出了一个奇异状态的问题。看了这篇文章你会发现异或运算在博弈中使用的妙处。当然这里指出的只是组合博弈中一种特殊情况。<br>
王道还是对SG&#20540;的求解，但是知道这么一种思路无疑对思维的广度和深度扩展是很有帮助的。<br>
ZZ博弈<br>
<a target="_blank" rel="nofollow" href="http://acm.hdu.edu.cn/forum/read.php?fid=9&amp;tid=10617" style="text-decoration:none">http://acm.hdu.edu.cn/forum/read.php?fid=9&amp;tid=10617</a><br>
这里介绍了组和博弈的两种大的类型，一种是最后取的是N状态一种是最后取的是P状态，两个状态的解题方法能看懂很有帮助。当然，能够把推导过程理解，吃透无疑是大牛级的做法~小子也佩服的紧~&nbsp; &nbsp;<br>
&nbsp; &nbsp; 1536题推荐做做这题，这题前面提醒大家是一个求SG&#20540;的题目，题目前面是对异或运算运用在组合博弈问题中的很好的解释。当然题目本身是有所不同的。因为在这里面对取法有所要求。那么这样就回归到了解决博弈问题的王道算法——求SG&#20540;上。<br>
&nbsp; &nbsp;&nbsp;有关运用求SG&#20540;的博弈题目有：&nbsp;1850（也可基于奇异状态异或）<br>
1848（中和的大斐波那契数列的典型求SG&#20540;题）<br>
1517（个人认为有点猥琐的题目。。。。在此题上困扰很久。当然搞出来很开心。小子是用比较规矩的求SG&#20540;的方法求出来的，但是论坛有人对其推出来了规律，这里佩服一下，大家可以学习一下）<br>
1079（更猥琐的题目，对新手要求较高，因为按传统方法需要比较细致的模拟加对边角状态的考虑，同样有人推出来了公式）<br>
当你全部看完以上的东西。做完以上的题目的话。。。小子恭喜你~你博弈入门了~~~~<br>
&nbsp; &nbsp;&nbsp;这里小子告诉大家。博弈很强大。学习要耐心~谢谢<br>
Current System Time : 2008-12-11 19:16:03</span></span></p>
<p style="line-height:25px; margin-top:0px; margin-bottom:10px; padding-top:0px; padding-bottom:0px; font-family:Arial,Helvetica,simsun,u5b8bu4f53; background-color:rgb(248,248,248); text-indent:2em">
<span style="line-height:32px"><span style="font-size:12px">ACM课作业：<br>
1001 Brave Game<br>
1002 Good Luck in CET-4 Everybody!<br>
1003 Fibonacci again and again<br>
1004 Rabbit and Grass<br>
1005 Being a Good Boy in Spring Festival<br>
1006 Public Sale&nbsp;<br>
1007&nbsp;悼念512汶川大地震遇难同胞——选拔志愿者&nbsp;<br>
1008 kiki’s game&nbsp;<br>
1009 Calendar Game&nbsp;<br>
1010 A Multiplication Game&nbsp;<br>
1011 Digital Deletions&nbsp;<br>
1012 S-Nim<br>
<a target="_blank" rel="nofollow" href="http://acm.hdu.edu.cn/forum/read.php?tid=11339&amp;fpage=0&amp;toread=&amp;page=1" style="text-decoration:none">http://acm.hdu.edu.cn/forum/read.php?tid=11339&amp;fpage=0&amp;toread=&amp;page=1</a></span></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="color:rgb(255,0,0)"><strong><span style="font-size:14px">（四）<span style="text-decoration:underline">最后我们来看组合博弈：（博弈的精华）</span></span></strong></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">博弈-取石子游戏</span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<a target="_blank" id="url_6" href="http://acm.hdu.edu.cn/forum/read.php?fid=20&amp;tid=5748" style="color:rgb(202,0,0); text-decoration:none"><span style="color:rgb(49,52,40)"><span style="font-size:14px">http://acm.hdu.edu.cn/forum/read.php?fid=20&amp;tid=5748</span></span></a><br>
<a target="_blank" id="url_7" href="http://hi.baidu.com/netnode/blog/item/30932c2edc7384514fc226ea.html" style="color:rgb(202,0,0); text-decoration:none"><span style="color:rgb(49,52,40)"><span style="font-size:14px">http://hi.baidu.com/netnode/blog/item/30932c2edc7384514fc226ea.html</span></span></a></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px">组合博弈无疑是对sg&#20540;的熟练操作例如：<span style="font-family:宋体">有</span><span lang="EN-US" style="font-family:'Times New Roman',serif">n</span><span style="font-family:宋体">堆石子，每次可以从第</span><span lang="EN-US" style="font-family:'Times New Roman',serif">1</span><span style="font-family:宋体">堆石子里取</span><span lang="EN-US" style="font-family:'Times New Roman',serif">1</span><span style="font-family:宋体">颗、</span><span lang="EN-US" style="font-family:'Times New Roman',serif">2</span><span style="font-family:宋体">颗或</span><span lang="EN-US" style="font-family:'Times New Roman',serif">3</span><span style="font-family:宋体">颗，可以从第</span><span lang="EN-US" style="font-family:'Times New Roman',serif">2</span><span style="font-family:宋体">堆石子里取奇数颗，可以从第</span><span lang="EN-US" style="font-family:'Times New Roman',serif">3</span><span style="font-family:宋体">堆及以后石子里取任意颗</span><span lang="EN-US" style="font-family:'Times New Roman',serif">……&nbsp;</span><span style="font-family:宋体">我们可以把它看作</span><span lang="EN-US" style="font-family:'Times New Roman',serif">3</span><span style="font-family:宋体">个子游戏，第</span><span lang="EN-US" style="font-family:'Times New Roman',serif">1</span><span style="font-family:宋体">个子游戏只有一堆石子，每次可以取</span><span lang="EN-US" style="font-family:'Times New Roman',serif">1</span><span style="font-family:宋体">、</span><span lang="EN-US" style="font-family:'Times New Roman',serif">2</span><span style="font-family:宋体">、</span><span lang="EN-US" style="font-family:'Times New Roman',serif">3</span><span style="font-family:宋体">颗，很容易看出</span><span lang="EN-US" style="font-family:'Times New Roman',serif">x</span><span style="font-family:宋体">颗石子的局面的</span><span lang="EN-US" style="font-family:'Times New Roman',serif">SG</span><span style="font-family:宋体">&#20540;是</span><span lang="EN-US" style="font-family:'Times New Roman',serif">x%4</span><span style="font-family:宋体">。第</span><span lang="EN-US" style="font-family:'Times New Roman',serif">2</span><span style="font-family:宋体">个子游戏也是只有一堆</span><span style="font-family:'Times New Roman',serif">&nbsp;</span><span style="font-family:宋体">石子，每次可以取奇数颗，经过简单的画图可以知道这个游戏有</span><span lang="EN-US" style="font-family:'Times New Roman',serif">x</span><span style="font-family:宋体">颗石子时的</span><span lang="EN-US" style="font-family:'Times New Roman',serif">SG</span><span style="font-family:宋体">&#20540;是</span><span lang="EN-US" style="font-family:'Times New Roman',serif">x%2</span><span style="font-family:宋体">。第</span><span lang="EN-US" style="font-family:'Times New Roman',serif">3</span><span style="font-family:宋体">个游戏有</span><span lang="EN-US" style="font-family:'Times New Roman',serif">n-2</span><span style="font-family:宋体">堆石子，就是一个</span><span lang="EN-US" style="font-family:'Times New Roman',serif">Nim</span><span style="font-family:宋体">游戏。对于原游戏的每</span><span style="font-family:'Times New Roman',serif">&nbsp;</span><span style="font-family:宋体">个局面，把三个子游戏的</span><span lang="EN-US" style="font-family:'Times New Roman',serif">SG</span><span style="font-family:宋体">&#20540;异或一下就得到了整个游戏的</span><span lang="EN-US" style="font-family:'Times New Roman',serif">SG</span><span style="font-family:宋体">&#20540;，然后就可以根据这个</span><span lang="EN-US" style="font-family:'Times New Roman',serif">SG</span><span style="font-family:宋体">&#20540;判断是否有必胜策略以及做出决策了。其实看作</span><span lang="EN-US" style="font-family:'Times New Roman',serif">3</span><span style="font-family:宋体">个子游戏还是保</span><span style="font-family:'Times New Roman',serif">&nbsp;</span><span style="font-family:宋体">守了些，干脆看作</span><span lang="EN-US" style="font-family:'Times New Roman',serif">n</span><span style="font-family:宋体">个子游戏，其中第</span><span lang="EN-US" style="font-family:'Times New Roman',serif">1</span><span style="font-family:宋体">、</span><span lang="EN-US" style="font-family:'Times New Roman',serif">2</span><span style="font-family:宋体">个子游戏如上所述，第</span><span lang="EN-US" style="font-family:'Times New Roman',serif">3</span><span style="font-family:宋体">个及以后的子游戏都是</span><span lang="EN-US" style="font-family:'Times New Roman',serif">“1</span><span style="font-family:宋体">堆石子，每次取几颗都可以</span><span lang="EN-US" style="font-family:'Times New Roman',serif">”</span><span style="font-family:宋体">，称为</span><span lang="EN-US" style="font-family:'Times New Roman',serif">“</span><span style="font-family:宋体">任取石子游戏</span><span lang="EN-US" style="font-family:'Times New Roman',serif">”</span><span style="font-family:宋体">，这个超简</span><span style="font-family:宋体">单的游戏有</span><span lang="EN-US" style="font-family:'Times New Roman',serif">x</span><span style="font-family:宋体">颗石子的</span><span lang="EN-US" style="font-family:'Times New Roman',serif">SG</span><span style="font-family:宋体">&#20540;显然就是</span><span lang="EN-US" style="font-family:'Times New Roman',serif">x</span><span style="font-family:宋体">。</span></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><span style="font-family:宋体"><br>
</span></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><span style="font-family:宋体"><br>
</span></span></p>
<p style="font-size:14px; font-family:Arial; margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; line-height:26px">
<span style="font-size:14px"><span style="font-family:宋体"><br>
</span></span></p>
<br>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目42_一笔画问题（欧拉路，图的连通性）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/22/NYOJ_题目42_一笔画问题（欧拉路，图的连通性）/">NYOJ 题目42 一笔画问题（欧拉路，图的连通性）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h4 class="problem-display"></h4>
<h2 class="problem-display" align="center"><span style="color:#990000">一笔画问题</span></h2>
<div class="problem-ins" align="center"><span style="color:#990000">时间限制：<span id="problem[time_limit]" class="editable highlight">3000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB</span></div>
<div class="problem-ins" align="center"><span style="color:#990000">难度：<span class="editable highlight">4</span></span></div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>
<p><span style="font-family:SimSun">zyc从小就比较喜欢玩一些小游戏，其中就包括画一笔画，他想请你帮他写一个程序，判断一个图是否能够用一笔画下来。</span></p>
<p><span style="font-family:SimSun; font-size:14px; line-height:19px">规定，所有的边都只能画一次，不能重复画。</span></p>
<p>&nbsp;</p>
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>第一行只有一个正整数N(N&lt;=10)表示测试数据的组数。<br>
每组测试数据的第一行有两个正整数P,Q(P&lt;=1000,Q&lt;=2000)，分别表示这个画中有多少个顶点和多少条连线。（点的编号从1到P）<br>
随后的Q行，每行有两个正整数A,B(0&lt;A,B&lt;P)，表示编号为A和B的两点之间有连线。 </dd><dt>输出 </dt><dd>如果存在符合条件的连线，则输出&quot;Yes&quot;,<br>
如果不存在符合条件的连线，输出&quot;No&quot;。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">2
4 3
1 2
1 3
1 4
4 5
1 2
2 3
1 3
1 4
3 4</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">No
Yes</pre>
</dd></dl>
</dd></dl>
<p></p>
<dl></dl>
<p><span style="font-size:18px; color:#cc0000">邻接矩阵存储图，</span></p>
<p><span style="font-size:18px; color:#cc0000">1。将 1点入队</span></p>
<p><span style="font-size:18px; color:#cc0000">2。循环： 取队头，将与队头元素相连的点（并且未标记）都入队； num&#43;&#43;; 同时统计跟 对头相连的点的个数（即该点的度）</span></p>
<p><span style="font-size:18px; color:#cc0000">3。循环结束时如果num ！= n ，说明图不是连通的；&nbsp;</span></p>
<p><span style="font-size:18px; color:#cc0000">&nbsp;&nbsp; 如果 度为奇数 的点的个数为 0 或 2，同时图是连通的，那么YES；否则NO</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/***************************
# 2013-8-22 9:44:54 
# Time: 12MS   Memory: 4228K
# Author: zyh
# Status: Accepted
***************************/ 

#define N 1002
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

queue &lt;int&gt; Q;
bool vis[N];
int G[N][N];

void bfs(int n){

	int cnt,num,odd,i;
	memset(vis,0,sizeof(vis));
	Q.push(1);
	vis[1] = 1;
	cnt = 0; //队列中点的个数 
	odd = 0; //度为奇数的点的个数 
	while(!Q.empty()){
		int top = Q.front();
		Q.pop();	cnt++; //出对，点的个数++ 
		num = 0; 
		for(i=1;i&lt;=n;i++){		
			if(G[top][i]){			
				if(!vis[i]){ //没有标记过的需要入队 
					Q.push(i);
					vis[i] = 1;
				}		
				num++; //该点的度++ 
			}
		}
		if(num&amp;1) odd++;//奇数度数点 
	}
	if((odd==0 || odd==2) &amp;&amp; cnt==n) puts(&quot;Yes&quot;);
	else puts(&quot;No&quot;); 
}

int main()
{
	int n,p,q,a,b;
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		memset(G,0,sizeof(G));
		scanf(&quot;%d%d&quot;,&amp;p,&amp;q);
		while(q--){
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			G[a][b] = G[b][a] = 1;
		}		
		bfs(p); 
	}
	return 0;
} </pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-poj_题目1883_排列（STL----next_permutation）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/22/poj_题目1883_排列（STL----next_permutation）/">poj 题目1883 排列（STL----next_permutation）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div lang="en-US" class="ptt" align="center"><span style="font-size:24px; color:#3366ff">排列</span></div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><span style="color:#009900"><strong>Time Limit:</strong> 1000MS</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Memory Limit:</strong> 30000K</span></td>
</tr>
<tr>
<td><span style="color:#009900"><strong>Total Submissions:</strong> 14758</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Accepted:</strong> 5988</span></td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div lang="en-US" class="ptx">题目描述： <br>
大家知道，给出正整数n，则1到n这n个数可以构成n！种排列，把这些排列按照从小到大的顺序（字典顺序）列出，如n=3时，列出1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1六个排列。
<br>
<br>
任务描述： <br>
给出某个排列，求出这个排列的下k个排列，如果遇到最后一个排列，则下1排列为第1个排列，即排列1 2 3…n。 <br>
比如：n = 3，k=2 给出排列2 3 1，则它的下1个排列为3 1 2，下2个排列为3 2 1，因此答案为3 2 1。 <br>
</div>
<p class="pst">Input</p>
<div lang="en-US" class="ptx">第一行是一个正整数m，表示测试数据的个数，下面是m组测试数据，每组测试数据第一行是2个正整数n( 1 &lt;= n &lt; 1024 )和k(1&lt;=k&lt;=64)，第二行有n个正整数，是1，2 … n的一个排列。</div>
<p class="pst">Output</p>
<div lang="en-US" class="ptx">对于每组输入数据，输出一行，n个数，中间用空&#26684;隔开，表示输入排列的下k个排列。</div>
<p class="pst">Sample Input</p>
<pre class="sio">3
3 1
2 3 1
3 1
3 2 1
10 2	
1 2 3 4 5 6 7 8 9 10
</pre>
<p class="pst">Sample Output</p>
<pre class="sio">3 1 2
1 2 3
1 2 3 4 5 6 7 9 8 10
</pre>
<p>&nbsp;</p>
<p>STL 中 next_permutation（）的应用；</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/***************************
# 2013-8-22 20:39:21 
# Time: 500MS   Memory: 168KB
# Author: zyh
# Status: Accepted
***************************/ 

#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int a[1050];
int main()
{
	int m,t,cnt,i,flag,n;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		for(i=0;i&lt;n;i++) {
			scanf(&quot;%d&quot;,&amp;a[i]);
		}
		
		int cnt = 0;

		do{	
			//首先判断是不是最后一个排列 
			for(flag=1,i=0;i&lt;n;i++){
				if(a[i]!=n-i) flag=0;
			}
			if(flag){
				for(i=0;i&lt;n;i++) a[i] =i+1;
				cnt++;
			}
			cnt++; 
		}while(cnt&lt;=m &amp;&amp;next_permutation(a,a+n));	
							 
		for(i=0;i&lt;n-1;i++) printf(&quot;%d &quot;,a[i]); 
		printf(&quot;%d\n&quot;,a[n-1]); 
		
	}
	return 0;
} 
/*
3
3 1
2 3 1
3 2
3 2 1
10 2	
1 2 3 4 5 6 7 8 9 10
*/</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目685_查找字符串（STL----map）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/22/NYOJ_题目685_查找字符串（STL----map）/">NYOJ 题目685 查找字符串（STL----map）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h2 align="center"><span style="color:#3366ff">查找字符串</span></h2>
<div align="center"><span style="color:#009900">时间限制：<span id="problem[time_limit]">1000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]">65535</span> KB
</span></div>
<div align="center"><span style="color:#009900">难度：3</span></div>
<dl><dt>描述 </dt><dd>
<p align="left">小明得到了一张写有奇怪字符串的纸，他想知道一些字符串出现了多少次，但这些字符串太多了，他想找你帮忙，你能帮他吗？输入字符包括所有小写字母、‘@’、‘&#43;’。</p>
<dl><dt>输入 </dt><dd>第一行包含一个整数T（T&lt;=100).表示测试数据组数。<br>
接下来每组数据第一行包含两个整数n，m(n，m&lt;100000),分别表示有n个字符串，小明要问你m次。<br>
接下来n行，每行包含一个字符串，长度不大于15。<br>
接下来m行，每行包含一个字符串，表示小明要问该串出现的次数。<br>
</dd><dt>输出 </dt><dd>输出每组小明询问数串出现的次数。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">1
5 3
hello
<a target="_blank" href="mailto:it@is&#43;so@easy">it@is&#43;so@easy</a>
hello
ibelieveicanac
hello
hello
icannotacit
Giveup</pre>
</dd><dd>
<pre>&nbsp;</pre>
</dd><dd>
<pre>样例输出 </pre>
</dd><dd>
<pre id="sample_output">3</pre>
</dd><dd>
<pre>0</pre>
</dd><dd>
<pre>0</pre>
</dd></dl>
</dd><dd>&nbsp;</dd></dl>
<p></p>
<dl></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/***************************
# 2013-8-22 18:47:15 
# Time: 140MS   Memory: 308KB
# Author: zyh
# Status: Accepted
***************************/ 

#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;

using namespace std;

map&lt;string,int&gt; M;

int main()
{
	int n,m,t;
	char s[16];
	string str;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		getchar();
		while(n--){
			gets(s);
			str = s;
			M[str]++;
		}
		while(m--){
			gets(s);
			str = s;
			printf(&quot;%d\n&quot;,M[str]);
		}
		M.clear();		
	}
	return 0;
} </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目366_D的小L_（next_permutation）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/22/NYOJ_题目366_D的小L_（next_permutation）/">NYOJ 题目366 D的小L （next_permutation）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h4 class="problem-display"></h4>
<h2 class="problem-display" align="center"><span style="color:#3366ff; background-color:#ffffff">D的小L</span></h2>
<div class="problem-ins" align="center"><span style="color:#009900; background-color:#ffffff">时间限制：<span id="problem[time_limit]" class="editable highlight">4000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB</span></div>
<div class="problem-ins" align="center"><span style="background-color:#ffffff"><span style="color:#009900">难度：<span class="editable highlight">2</span></span></span></div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>&nbsp; &nbsp; &nbsp; 一天TC的匡匡找ACM的小L玩三国杀，但是这会小L忙着哩，不想和匡匡玩但又怕匡匡生气，这时小L给匡匡出了个题目想难倒匡匡(小L很D吧<img border="0" alt="" src="http://59.69.128.200/JudgeOnline/admin/kind/plugins/emoticons/44.gif">)，有一个数n(0&lt;n&lt;10),写出1到n的全排列，这时匡匡有点囧了<img border="0" alt="" src="http://59.69.128.200/JudgeOnline/admin/kind/plugins/emoticons/18.gif">，，，聪明的你能帮匡匡解围吗？
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>第一行输入一个数N（0&lt;N&lt;10）,表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个整数x(0&lt;x&lt;10) </dd><dt>输出 </dt><dd>按特定顺序输出所有组合。<br>
特定顺序：每一个组合中的&#20540;从小到大排列，组合之间按字典序排列。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">2
2
3</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">12
21
123
132
213
231
312
321</pre>
</dd></dl>
</dd></dl>
<p>先看一下全排列吧：<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/7370155">大牛空间全排列</a>，比较详细</p>
<dl></dl>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>代码一：简单STL 之 next_permutation();</p>
<p>&nbsp;</p>
<p><a target="_blank" href="http://shenan1984.blog.163.com/blog/static/2530851020081124954081/">next_permutation，prev_permutation详细</a></p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/***************************
# 2013-8-22 12:56:46 
# Time: 8MS   Memory: 232KB
# Author: zyh
# Status: Accepted
***************************/ 

#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int main()
{
	int n,x,i,j;char s[12];
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		scanf(&quot;%d&quot;,&amp;x);
		for(i=0;i&lt;x;i++) s[i]=i+'1';
		s[i]='\0';
		do{
			puts(s);
		}while(next_permutation(s,s+x));//全排列函数应用
	}
	return 0;
} </pre>
<p><br>
&nbsp;</p>
<p>代码二： 递归求全排列， 两个数组；</p>
<p>一个S[ ]存放原来的数， 另个 S1[ ]存放 排列, 从S1的0位置存放，存到长度输出一个全排列</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/***************************
# 2013-8-22 15:46:46 
# Time: 8MS   Memory: 232KB
# Author: zyh
# Status: Accepted
***************************/ 

#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int x;
bool vis[12];
char s[12],s1[12];

void permutation(int t)
{
	if(t==x){
		s1[x] = '\0'; //这里不要忘了，用字符数组存储字符串要注意末尾 '\0' 
		puts(s1);
	} 
	for(int i=0;i&lt;x;i++){
		if(!vis[s[i]-'1']){
			s1[t] = s[i];
			vis[s[i]-'1'] = 1;
			permutation(t+1); 
			vis[s[i]-'1'] = 0;
		}
	}
}
int main()
{
	int n,i;
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		memset(vis,0,sizeof(vis));
		scanf(&quot;%d&quot;,&amp;x);
		for(i=0;i&lt;x;i++) {
			s[i] = i+'1';
		}
		s[i] = '\0';
		permutation(0);
	}
	return 0;
} 
</pre>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目_55_懒省事的小明（priority_queue）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/22/NYOJ_题目_55_懒省事的小明（priority_queue）/">NYOJ 题目 55 懒省事的小明（priority_queue）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h4 class="problem-display"></h4>
<h2 class="problem-display" align="center"><span style="color:#3366ff">懒省事的小明</span></h2>
<div class="problem-ins" align="center"><span style="color:#009900">时间限制：<span id="problem[time_limit]" class="editable highlight">3000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB</span></div>
<div class="problem-ins" align="center"><span style="color:#009900">难度：<span class="editable highlight">3</span></span></div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 小明很想吃果子，正好果园果子熟了。在果园里，小明已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。小明决定把所有的果子合成一堆。 因为小明比较懒，为了省力气，小明开始想点子了:<br>
　　每一次合并，小明可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。小明在合并果子时总共消耗的体力等于每次合并所耗体力之和。<br>
　　因为还要花大力气把这些果子搬回家，所以小明在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使小明耗费的体力最少，并输出这个最小的体力耗费&#20540;。<br>
　　例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以小明总共耗费体力=3&#43;12=15。可以证明15为最小的体力耗费&#20540;。
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>第一行输入整数N(0&lt;N&lt;=10)表示测试数据组数。接下来每组测试数据输入包括两行，第一行是一个整数n(1&lt;＝n&lt;=12000)，表示果子的种类数。第二行包含n个整数，用空&#26684;分隔，第i个整数ai(1&lt;＝ai&lt;=20000)是第i种果子的数目。</dd><dt>输出 </dt><dd>每组测试数据输出包括一行，这一行只包含一个整数，也就是最小的体力耗费&#20540;。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">1
3 
1 2 9</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">15</pre>
</dd></dl>
</dd></dl>
<p></p>
<dl></dl>
<p>&nbsp;</p>
<p>优先队列的使用，，，</p>
<pre class="cpp" name="code">/***************************
# 2013-8-22 10:10:52 
# Time: 152MS   Memory: 440K
# Author: zyh
# Status: Accepted
***************************/ 
/*
采用优先队列priority_queue，采用struct重载比较方法，每次取头两个最小的元素，
再将和插进队列。直到队列只剩下一个元素，最后别忘了清空队列。
*/
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;

struct CMP{ //自己定义优先级 
	bool operator() (const long long &amp;a,const long long &amp;b){
		return a&gt;b;
	} 	
};
priority_queue &lt;long long ,vector&lt;long long&gt;,CMP&gt; Q; 



void solve(){
	long long  sum=0; //int型 WA 
	int q1,q2,m;
	while(Q.size()&gt;1){
		q1 = Q.top(); Q.pop();
		q2 = Q.top(); Q.pop(); 
		m = q1+q2;
		sum+= m;
		Q.push(m);
	}
	Q.pop();
	printf(&quot;%lld\n&quot;,sum);
} 

int main()
{
	int n,m,c;
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		scanf(&quot;%d&quot;,&amp;m);
		while(m--) {
			scanf(&quot;%d&quot;,&amp;c);
			Q.push(c);
		} 
		solve();
	}
	return 0;
} </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code"> /***************************
# 2013-8-22 10:10:52 
# Time: 136MS   Memory: 440K
# Author: zyh
# Status: Accepted
***************************/ 

#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;

priority_queue &lt;long long ,vector&lt;long long&gt;,greater&lt;long long&gt; &gt; Q; //优先队列，值小的元素优先 

void solve(){
	long long  sum=0; //int型 WA 
	int q1,q2,m;
	while(Q.size()&gt;1){
		q1 = Q.top(); Q.pop();
		q2 = Q.top(); Q.pop(); 
		m = q1+q2;
		sum+= m;
		Q.push(m);
	}
	Q.pop();
	printf(&quot;%lld\n&quot;,sum);
} 

int main()
{
	int n,m,c;
	scanf(&quot;%d&quot;,&amp;n);
	while(n--)
	{
		scanf(&quot;%d&quot;,&amp;m);
		while(m--) {
			scanf(&quot;%d&quot;,&amp;c);
			Q.push(c);
		} 
		solve();
	}
	return 0;
} </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-poj_题目1679_The_Unique_MST_（最小生成树，次小生成树_prim）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/21/poj_题目1679_The_Unique_MST_（最小生成树，次小生成树_prim）/">poj 题目1679 The Unique MST （最小生成树，次小生成树 prim）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<div lang="en-US" class="ptt" align="center"><span style="font-size:24px; color:#3366ff">The Unique MST</span></div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><span style="color:#009900"><strong>Time Limit:</strong> 1000MS</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Memory Limit:</strong> 10000K</span></td>
</tr>
<tr>
<td><span style="color:#009900"><strong>Total Submissions:</strong> 17881</span></td>
<td width="10"><span style="color:#009900"></span></td>
<td><span style="color:#009900"><strong>Accepted:</strong> 6204</span></td>
</tr>
</tbody>
</table>
</div>
<p class="pst"><span style="font-size:18px; color:#3366ff">Description</span></p>
<div lang="en-US" class="ptx">Given a connected undirected graph, tell if its minimum spanning tree is unique.<br>
<br>
Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V', E'), with the following properties:<br>
1. V' = V. <br>
2. T is connected and acyclic. <br>
<br>
Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E') of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all
 the edges in E'. <br>
</div>
<p class="pst"><span style="font-size:18px; color:#3366ff">Input</span></p>
<div lang="en-US" class="ptx">The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. Each case represents a graph. It begins with a line containing two integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the
 following m lines contains a triple (xi, yi, wi), indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them.</div>
<p class="pst"><span style="font-size:18px; color:#3366ff">Output</span></p>
<div lang="en-US" class="ptx">For each input, if the MST is unique, print the total cost of it, or otherwise print the string 'Not Unique!'.</div>
<p class="pst">Sample Input</p>
<pre class="sio">2
3 3
1 2 1
2 3 2
3 1 3
4 4
1 2 2
2 3 2
3 4 2
4 1 2
</pre>
<p class="pst">Sample Output</p>
<pre class="sio">3
Not Unique!
</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size:18px"><strong><span style="color:#3366ff">次小生成树</span></strong>：首先必须存在最小生成树，次小生成树的意思就是，除了最小生成树之外，存在一个生成树，权&#20540;仅大于最小生成树，也就是</span></p>
<div>&nbsp;<span style="font-size:18px">给出一个带边权的无向图G，设其最小生成树为T，求出图G的与T不完全相同的边权和最小的生成树（即G的次小生成树）。一个无向图的两棵生成树不完全相同，当且仅当这两棵树中至少有一条边不同。（注意，<span style="color:#ff0000">图G可能不连通，可能有平行边</span>）</span></div>
<p>&nbsp;</p>
<p><span style="font-size:18px">那么如何来求最小生成树？</span></p>
<div><span style="font-size:18px">定义生成树T的一个可行变换(-E1, &#43;E2)：将T中的边E1删除后，再加入边E2（满足边E2原来不在T中但在G中），若得到的仍然是图G的一棵生成树，则该变换为可行变换，该可行变换的代价为(E2权&#20540; - E1权&#20540;)。这样，很容易证明，G的次小生成树就是由G的最小生成树经过一个代价最小的可行变换得到。进一步可以发现，这个代价最小的可行变换中加入的边E2的两端点如果为V1和V2，那么E1一定是原来最小生成树中从V1到V2的路径上的权&#20540;最大的边。</span></div>
<p>&nbsp;</p>
<div>
<div><span style="font-size:18px"><span style="color:#8cadae">算法：</span></span></div>
<div><span style="font-size:24px"><span style="color:#ffffff; background-color:#000000">1.</span><span style="font-family:KaiTi_GB2312">设立数组F，<span style="color:#3366ff">F[x][y]</span>表示<span style="color:#3366ff">T中</span>从x到y路径上的最大边的权&#20540;。F数组可以在用Prim算法求最小生成树的过程中得出。</span></span></div>
<div><span style="font-family:KaiTi_GB2312; font-size:18px"><span style="font-size:24px"><span style="color:#ffcccc; background-color:#000000">2.</span>每次将<span style="color:#3333ff">边(i,j) G[i][j]</span>加入后（j是新加入的边的新端点），枚举树中原有的每个点k（包括i，但不包括j），则<span style="color:#3366ff; background-color:#ffffff">F[k][j]=max{F[k][i],G[i][j]}，</span>又由于F数组是对称的，可以得到F[j][k]=F[k][j]。</span></span></div>
<div><span style="font-family:KaiTi_GB2312; font-size:18px"><span style="font-size:24px"><span style="color:#ffffff; background-color:#000000">3.</span>将图G中的边(i, j)删除（就是将邻接矩阵中(i,j)边权&#20540;改为∞）！因为T中的边是不能被加入的。</span></span></div>
<div><span style="font-family:KaiTi_GB2312; font-size:18px"><span style="font-size:24px"><span style="color:#ffffff; background-color:#000000">4.</span>等T被求出后，所有的F&#20540;也求出了，然后，枚举点i、j，若邻接矩阵中边(i, j)权&#20540;不是无穷大（这说明i、j间存在不在T中的边），则求出{(i, j)边权&#20540; - F[i][j]}的&#20540;，即为加入边(i, j)的代价，求最小的总代价即可</span>。</span></div>
<div><span style="font-family:楷体_GB2312; font-size:18px"></span>&nbsp;</div>
<div><span style="font-size:18px">&nbsp;</span></div>
<div><span style="font-size:18px"><span style="color:#8cadae">!!!&nbsp;&nbsp;&nbsp;&nbsp; </span>另外注意三种特殊情况：</span></div>
<div><span style="font-size:18px">【1】<span style="color:#ff0000">图G不连通</span>，此时最小生成树和次小生成树均不存在。<span style="color:#ff0000">判定方法</span>：在扩展T的过程中找不到新的可以加入的边；【2】图<span style="color:#ff0000">G本身就是一棵树</span>，此时最小生成树存在（就是G本身）但次小生成树不存在。<span style="color:#ff6666">判定方法</span>：在成功求出T后，发现邻接矩阵中的&#20540;全部是无穷大；</span></div>
<div><span style="font-size:18px">【3】图<span style="color:#ff0000">G存在平行边</span>。这种情况最麻烦，因为这时代价最小的可行变换(-E1, &#43;E2)中，E1和E2可能是平行边！因此，只有建立两个邻接矩阵，分别存储每两点间权&#20540;最小的边和权&#20540;次小的边的权&#20540;，然后，每当一条新边(i, j)加入时，不是将邻接矩阵中边(i, j)权&#20540;改为无穷大，而是改为连接点i、j的权&#20540;次小的边的权&#20540;</span></div>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size:18px; color:#666600">int G[N][N] //邻接矩阵</span></p>
<p><span style="font-size:18px; color:#666600">int f[N][N]&nbsp; //最小生成树中每两点间的最大边的权&#20540;</span></p>
<p><span style="font-size:18px; color:#666600">bool vis[N]&nbsp; // 标记点</span></p>
<p><span style="font-size:18px; color:#666600">int p[N] //存放最小生成树过程的加入点集合</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/********************** 
# 2013-8-21 21:28:04 
# Time: 16MS   Memory: 260K
# Author: zyh
# Status: Accepted
**********************/ 
#define INF 99999999
#define N 110
#define MAX(a,b) (a)&gt;(b)?(a):(b)
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int n,G[N][N],f[N][N];

void prim()
{
	int p[N],vis[N],i,j,v,sum,k;
			
	memset(vis,0,sizeof(vis));
	memset(f,0,sizeof(f));
	
	k=0;
	p[k++] = 1;//存放最小生成树点集合 
	vis[1] = 1;

	sum = 0;
	
	for(int t=1;t&lt;n;t++){ // n个顶点，n-1条边，循环n-1次，每次加入一条新的边 
										
		int min = INF;
		int s,e; 
		
		for(j=0;j&lt;k;j++){//枚举书中已有的每个点 
			v = p[j];	
			for(i=1;i&lt;=n;i++){ //寻找点v相连的最小边； 
				if(!vis[i]&amp;&amp; G[v][i]&lt;min){
					min = G[v][i];
					s = v; e = i;//记录新加入边的两端点 
				}
			}
		}
		for(j=0; j&lt;k;j++){ //找到要新加入的边，
			v = p[j];
			f[e][v] = f[v][e] = MAX(f[v][s],G[s][e]);
		}
	
		G[s][e] = G[e][s] =  INF; //INF 代表该边已被删除 
		
		p[k++] = e;//加入新结点 
		vis[e] = 1; //标记 
		
		sum += min;	//求最小生成树的权值 
	}	


	/********判断是否存在次小生成树，或者最小生成树是否唯一 ********/ 
	 
	int flag = 1; //标记是否有次小生成树 
	int sign = 0; //标记是否所有的边都在最小生成树中 0代表是， 1代表不是 
	
	for(i=1;i&lt;=n;i++){ //枚举图中剩余的不在最小生成树的边 
		for(j=1;j&lt;=n;j++){
			if(G[i][j]!=INF){  //存在图中不在最小生成树的边
				sign = 1;  //标记还存在其他边 
				if(i!=j &amp;&amp; G[i][j]!=f[i][j]) { 
					flag = 0;						
				}			
			}		
		}
	}
	if(flag &amp;&amp; sign) printf(&quot;Not Unique!\n&quot;); // 
	else printf(&quot;%d\n&quot;,sum);
}

int main()
{
	int t,m,i,j,a,b,c;
	scanf(&quot;%d&quot;,&amp;t);
	while(t--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		for(i=1;i&lt;=n;i++){
			for(j=1;j&lt;=n;j++)
			G[i][j] = INF;
		}
		while(m--){
			scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
			G[a][b] = G[b][a] = c;
		}
		prim();
		
	}
	return 0;
}
/*
9
3 3
1 2 1
2 3 2
3 1 3
4 4
1 2 2
2 3 2
3 4 2
4 1 2
3 3
1 2 2
2 3 3
3 1 3
3 3
1 2 3
2 3 2
3 1 3
3 2
1 2 2
2 3 2
*/
 </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目_（最小生成树_prim算法）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/21/hdu_题目_（最小生成树_prim算法）/">hdu 题目 （最小生成树 prim算法）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">还是畅通工程</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 4000/2000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/32768 K (Java/Others)<br>
Total Submission(s): 20596&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 9149<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>
当N为0时，输入结束，该用例不被处理。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">对每个测试用例，在1行里输出最小的公路总长度。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">3
1 2 1
1 3 2
2 3 4
4
1 2 1
1 3 4
1 4 1
2 3 3
2 4 2
3 4 5
0</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">3
5

</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size:18px">最基本的prim 算法，直接求最小生成树权&#20540;</span></p>
<p><span style="font-size:18px">1. int p[]数组//存放生成树的点集</span></p>
<p><span style="font-size:18px">2. bool vis[] ;//标记是否已存在与生成树集合</span></p>
<p><span style="font-size:18px">3. 以此访问p[]数组元素，寻找与各个点相连的边中最小的边， 找到后 权&#20540;相加，将新的点加入p[]集合，再次循环</span></p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/********************** 
# 2013-8-21 12:35:31
# Time: 187MS   Memory: 276KB
# Author: zyh
# Status: Accepted
**********************/ 

#include&lt;stdio.h&gt;
#define INF 99999999
#define N 110
int n,G[N][N];

void prim()
{
	int p[N],vis[N],i,j,v,sum,m,last,k =0;
	p[k++] = 1;
	sum = 0;
	for(i=1;i&lt;=n;i++) vis[i]=0;
	vis[1] = 1;
	for(m=1;m&lt;n;m++){
		int min = INF; 
		for(j=0;j&lt;k;j++){
			v = p[j];	
			for(i=1;i&lt;=n;i++){
				if(!vis[i]&amp;&amp; G[v][i]&lt;min){
					min = G[v][i];
					last = i;
				}
			}
		}
		vis[last] = 1;
		p[k++] = last;
		sum += min;	
	}
	printf(&quot;%d\n&quot;,sum);

}

int main()
{
	int t,m,i,j,a,b,c;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		for(i=1;i&lt;=n;i++){
			for(j=1;j&lt;=n;j++)
			G[i][j] = INF;
		}
		m = n*(n-1)/2;
		while(m--){
			scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
			if( c&lt;G[a][b] || c&lt;G[b][a] )//去重边
				G[a][b] = G[b][a] = c;
		}
		prim();
	}
	return 0;
} </pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1385_Minimum_Transport_Cost_（最短路径，路径保存及筛选）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/20/hdu_题目1385_Minimum_Transport_Cost_（最短路径，路径保存及筛选）/">hdu 题目1385 Minimum Transport Cost （最短路径，路径保存及筛选）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center"><span style="color:#3366ff">Minimum Transport Cost </span></h1>
<h5 align="center"><span style="color:#009900">Time Limit : 2000/1000ms (Java/Other)&nbsp;&nbsp;&nbsp;Memory Limit : 65536/32768K (Java/Other)</span></h5>
<h5 align="center"><span style="color:#009900">Total Submission(s) : 19&nbsp;&nbsp;&nbsp;Accepted Submission(s) : 7</span></h5>
<h3 align="left">Problem Description</h3>
<div>These are N cities in Spring country. Between each pair of cities there may be one transportation track or none. Now there is some cargo that should be delivered from one city to another. The transportation fee consists of two parts:
<br>
The cost of the transportation on the path between these cities, and<br>
<br>
a certain tax which will be charged whenever any cargo passing through one city, except for the source and the destination cities.<br>
<br>
You must write a program to find the route which has the minimum cost.<br>
</div>
<h3>Input</h3>
<div id="proinput">First is N, number of cities. N = 0 indicates the end of input.<br>
<br>
The data of path cost, city tax, source and destination cities are given in the input, which is of the form:<br>
<br>
a11 a12 ... a1N<br>
a21 a22 ... a2N<br>
...............<br>
aN1 aN2 ... aNN<br>
b1 b2 ... bN<br>
<br>
c d<br>
e f<br>
...<br>
g h<br>
<br>
where aij is the transport cost from city i to city j, aij = -1 indicates there is no direct path between city i and city j. bi represents the tax of passing through city i. And the cargo is to be delivered from city c to city d, city e to city f, ..., and
 g = h = -1. You must output the sequence of cities passed by and the total cost which is of the form:<br>
</div>
<h3>Output</h3>
<div id="prooutput">From c to d :<br>
Path: c--&gt;c1--&gt;......--&gt;ck--&gt;d<br>
Total cost : ......<br>
......<br>
<br>
From e to f :<br>
Path: e--&gt;e1--&gt;..........--&gt;ek--&gt;f<br>
Total cost : ......<br>
<br>
Note: if there are more minimal paths, output the lexically smallest one. Print a blank line after each test case.<br>
<br>
</div>
<h3>Sample Input</h3>
<div id="prosamplein">
<pre>5
0 3 22 -1 4
3 0 5 -1 -1
22 5 0 9 20
-1 -1 9 0 4
4 -1 20 4 0
5 17 8 3 1
1 3
3 5
2 4
-1 -1
0
</pre>
</div>
<h3>Sample Output</h3>
<div id="prosampleout">
<pre>From 1 to 3 :
Path: 1--&gt;5--&gt;4--&gt;3
Total cost : 21

From 3 to 5 :
Path: 3--&gt;4--&gt;5
Total cost : 16

From 2 to 4 :
Path: 2--&gt;1--&gt;5--&gt;4
Total cost : 17
</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>需要注意保存路径时，当当有两个最短路径冲突时，要进行筛选路径</p>
<p>最短路径用的Dijkstra 算法，</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;
#define maxnum 10000
#define int_max 999999



using namespace std;
int dist[maxnum];
int prev[maxnum];
int b[maxnum];
int c[maxnum][maxnum];
int n,can;

int com(int cur,int v,int a,int b)//筛选路径
{
    int path1[maxnum];
    int path2[maxnum];
    path1[0]=cur;
    path2[0]=cur;
    int i=2,j=2;
    path1[1]=a;
    path2[1]=b;
    while(a!=v)
    {
        path1[i++]=prev[a];
        a = prev[a];
    }
    while(b!=v)
    {
        path2[j++]=prev[b];
        b= prev[b];
    }
    while(1)
    {
         i--,j--;
        if(i&lt;0) return path1[1];
        else if(j&lt;0) return path2[1];
        if(path1[i]&lt;path2[j])return path1[1];
        else if(path1[i]&gt;path2[j])
        return path2[1];
    }


}
void Dijkstra(int n,int v,int t,int *dist,int *prev,int c[maxnum][maxnum],int *b)
{
    bool s[maxnum];
    for(int i=1;i&lt;=n;i++)
    {
        s[i] = 0;
        dist[i] = c[v][i];
        if(dist[i]==int_max)
            prev[i]=0;
        else
            prev[i]=v;
    }
    dist[v] =0;
    s[v] =1;
    for(int i=1;i&lt;=n;i++)
    {
        int min = int_max;
        int u = v;
        for(int j=1;j&lt;=n;j++)
        {
            if(!s[j]&amp;&amp;dist[j]&lt;min)
                {
                    min = dist[j];
                    u = j;
                }
        }
        s[u]=1;
        for(int j=1;j&lt;=n;j++)
        {
            if(c[u][j]==int_max)continue;
            
            int newint=b[u]+dist[u]+c[u][j];
            if(!s[j]&amp;&amp;newint&lt;dist[j])
            {
                dist[j]=newint;
                prev[j]= u;
            }
            else if(!s[j]&amp;&amp;newint==dist[j])
                   prev[j]= com(j,v,prev[j],u);
        }
    }
    int path[maxnum];
   	int k = 1;
	path[k++]=t;
	int tmp = prev[t];
	
	while(tmp != v){
		
		path[k++] = tmp;	
		tmp = prev[tmp];
	}
	path[k] = v;
	for(int i=k ;i&gt;1;i--){
		printf(&quot;%d--&gt;&quot;,path[i]);
	}printf(&quot;%d\n&quot;,path[1]);
    
}

int main()
{
	int i,j,ss,t,r;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		for(i=1;i&lt;=n;i++){
			for(j=1;j&lt;=n;j++){		
				scanf(&quot;%d&quot;,&amp;r);
				if(r==-1){
					c[i][j] =int_max;
				}
				else c[i][j] = r;
			}
		}
		for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);
		while(scanf(&quot;%d%d&quot;,&amp;ss,&amp;t),(ss!=-1&amp;&amp;t!=-1)){
			printf(&quot;From %d to %d :\nPath: &quot;,ss,t);
			if(ss==t) {
				printf(&quot;%d\nTotal cost : 0\n\n&quot;,ss);
			}
			else{		
				Dijkstra(n,ss,t,dist,prev,c,b);
				printf(&quot;Total cost : %d\n\n&quot;,dist[t]);
			}
				
		}
	}
	return 0;
} 
</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目2122_HDU_Today_（最短路径，Dijkstra）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/20/hdu_题目2122_HDU_Today_（最短路径，Dijkstra）/">hdu 题目2122 HDU Today （最短路径，Dijkstra）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">HDU Today</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 15000/5000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 11027&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 2575<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left"><span style="font-size:18px; color:#3366ff">Problem Description</span></div>
<div class="panel_content">经过锦囊相助，海东集团终于度过了危机，从此，HDU的发展就一直顺风顺水，到了2050年，集团已经相当规模了，据说进入了钱江肉丝经济开发区500强。这时候，XHD夫妇也退居了二线，并在风景秀美的诸暨市浬浦镇陶姚村买了个房子，开始安度晚年了。<br>
这样住了一段时间，徐总对当地的交通还是不太了解。有时很郁闷，想去一个地方又不知道应该乘什么公交车，在什么地方转车，在什么地方下车（其实徐总自己有车，却一定要与民同乐，这就是徐总的性&#26684;）。<br>
徐总经常会问蹩脚的英文问路：“Can you help me?”。看着他那迷茫而又无助的&#30524;神，热心的你能帮帮他吗？<br>
请帮助他用最短的时间到达目的地（假设每一路公交车都只在起点站和终点站停，而且随时都会开）。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left"><span style="font-size:18px; color:#3366ff">Input</span></div>
<div class="panel_content">输入数据有多组，每组的第一行是公交车的总数N(0&lt;=N&lt;=10000)；<br>
第二行有徐总的所在地start，他的目的地end；<br>
接着有n行，每行有站名s，站名e，以及从s到e的时间整数t(0&lt;t&lt;100)(每个地名是一个长度不超过30的字符串)。<br>
note：一组数据中地名数不会超过150个。<br>
如果N==-1，表示输入结束。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left"><span style="font-size:18px; color:#3366ff">Output</span></div>
<div class="panel_content">如果徐总能到达目的地，输出最短的时间；否则，输出“-1”。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">6
xiasha westlake
xiasha station 60
xiasha ShoppingCenterofHangZhou 30
station westlake 20
ShoppingCenterofHangZhou supermarket 10
xiasha supermarket 50
supermarket westlake 10
-1</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">50


Hint:
The best route is:
xiasha-&gt;ShoppingCenterofHangZhou-&gt;supermarket-&gt;westlake

</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>存储各站点信息，最后Dijkstra</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/********************** 
# 2013-8-20 19:42:14 
# Time: 562MS   Memory: 396KB
# Author: zyh
# Status: Accepted
**********************/ 

#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define M 999999999

int map[200][200];
int dis[200];
char pl[200][35];
int k;
void dijkstra(int s,int n)
{
	int vis[200];
	int min = M,i,j;
	for(i=0;i&lt;n;i++){
		vis[i] = 0;
		dis[i] = map[s][i]; 
	}
	dis[s] = 0;
	vis[s] = 1;
	
	for(i=0;i&lt;n;i++)
	{
		int loc = s;
		min = M;
		for(j=0;j&lt;n;j++)
		{
			if(!vis[j] &amp;&amp; dis[j]&lt;min){
				min = dis[j];
				loc = j;
			}
		}
		vis[loc] = 1;
		for(j=0;j&lt;n;j++)
		{
			if(!vis[j] &amp;&amp; map[loc][j]&lt;M){
				int temp = dis[loc] + map[loc][j];
				if(dis[j] &gt; temp)	dis[j] = temp; 
			}
		}		
	}	
}

int getid(char * s){
	
	int j;
	for(j=0;j&lt;k;j++){		
		if(strcmp(pl[j],s)==0){
			return j;
		} 
	}
	strcpy(pl[k],s);
	return k++;
}
int main()
{
	int n,a,b,i,j,val;

	char s[35],e[35],t1[35],t2[35];
	while(scanf(&quot;%d&quot;,&amp;n),!(n==-1))
	{
		scanf(&quot;%s%s&quot;,s,e);
		k = 0;
		for(i=0;i&lt;199;i++){
			for(j=0;j&lt;199;j++)
				map[i][j] = M;
		}
		
		k =0;
		for(i=0;i&lt;n;i++){
			scanf(&quot;%s%s%d&quot;,t1,t2,&amp;val);	
			a = getid(t1);	b = getid(t2);
			if(map[a][b]&gt;val || map[b][a]&gt;val)	map[b][a] = map[a][b] = val;
		}
		int num = k;

		a = getid(s);
		b = getid(e);
				
		if(a&gt;=num || b&gt;=num){
			printf(&quot;-1\n&quot;);
			continue;
		}	
		else
		{
			dijkstra(a,num);
			if(dis[b]==M) printf(&quot;-1\n&quot;);
			else printf(&quot;%d\n&quot;,dis[b]);	
		}			
	}
	return 0;
} 

/*
6
x x
xiasha station 60
xiasha ShoppingCenterofHangZhou 30
station westlake 20
ShoppingCenterofHangZhou supermarket 10
xiasha supermarket 50
supermarket westlake 10
6
xiasha xiasha
xiasha station 60
xiasha ShoppingCenterofHangZhou 30
station westlake 20
ShoppingCenterofHangZhou supermarket 10
xiasha supermarket 50
supermarket westlake 10
3
x y
x z 5
y h 6
h z 1

*/

</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1596_find_the_safest_road_（最短路径_dijkstra）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/20/hdu_题目1596_find_the_safest_road_（最短路径_dijkstra）/">hdu 题目1596 find the safest road （最短路径 dijkstra）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center"><span style="color:#3366ff">find the safest road</span></h1>
<p align="center"><span style="color:#33cc00"><span><strong><span style="font-family:Arial; font-size:12px; font-weight:bold">Time Limit: 10000/5000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 4943&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 1797<br>
</span></strong></span><br>
</span><br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<p>&nbsp;</p>
<div class="panel_content">XX星球有很多城市，每个城市之间有一条或多条飞行通道，但是并不是所有的路都是很安全的，每一条路有一个安全系数s,s是在 0 和 1 间的实数(包括0，1)，一条从u 到 v 的通道P 的安全度为Safe(P) = s(e1)*s(e2)…*s(ek) e1,e2,ek是P 上的边 ，现在8600 想出去旅游，面对这这么多的路，他想找一条最安全的路。但是8600 的数学不好，想请你帮忙 ^_^</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Input</div>
<p>&nbsp;</p>
<div class="panel_content">输入包括多个测试实例，每个实例包括：<br>
第一行：n。n表示城市的个数n&lt;=1000;<br>
接着是一个n*n的矩阵表示两个城市之间的安全系数，(0可以理解为那两个城市之间没有直接的通道)<br>
接着是Q个8600要旅游的路线,每行有两个数字，表示8600所在的城市和要去的城市</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Output</div>
<p>&nbsp;</p>
<div class="panel_content">如果86无法达到他的目的地，输出&quot;What a pity!&quot;,<br>
其他的输出这两个城市之间的最安全道路的安全系数,保留三位小数。</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<p>&nbsp;</p>
<div class="panel_content">
<pre style="margin:0px; font-size:14px"><div style="font-family:'Courier New',Courier,monospace">3
1 0.5 0.5
0.5 1 0.4
0.5 0.4 1
3
1 2
2 3
1 3</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<p>&nbsp;</p>
<div class="panel_content">
<pre style="margin:0px; font-size:14px"><div style="font-family:'Courier New',Courier,monospace">0.500
0.400
0.500</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
<br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;最短路径问题。不过这道题是求最大&#20540;的，原理一样、、、</p>
<p>用G&#43;&#43;提交会出现，C&#43;&#43;AC，不过真耗时</p>
<pre class="cpp" name="code">/********************** 
2013-8-20 11:16:05 
Time: 1031 MS   Memory: 6664 KB
Author: zyh
Status: Accepted
**********************/ 
#define N 1005
#include&lt;stdio.h&gt;

double G[N][N],dis[N];
bool vis[N];
int n,t;

void dijkstra(int s){
	
	int i,j;	
	for(i=1;i&lt;=n;i++){//初始化
		vis[i]=0;
		dis[i] = G[s][i]*G[s][s];
	}
	vis[s] = 1;	dis[s] = G[s][s];
	for(i=1;i&lt;=n;i++){
		
		double max =0; //double 一开始忘了，花了大量时间找错误了 
		int last ;
		for(j=1;j&lt;=n;j++){//寻找当前最大安全系数
			if(!vis[j] &amp;&amp; dis[j]&gt;max){
				max = dis[j];
				last = j; 
			} 
		}
		vis[last] = 1;
		for(j=1;j&lt;=n;j++){	//跟新dis【】		
			if(!vis[j]){		
				double newdis = dis[last]*G[last][j];	//还有这里 d ouble	
				if(dis[j] &lt; newdis )	dis[j] = newdis;												
			}		
		}	
	}
	if(dis[t]&lt;0.00000000001) printf(&quot;What a pity!\n&quot;);
	else printf(&quot;%.3lf\n&quot;,dis[t]);
	
	
}

int main()
{
	int s,d,i,j,q;	
	while(scanf(&quot;%d&quot;,&amp;n)!=EOF)
	{
		for(i=1;i&lt;=n;i++){
			for(j=1;j&lt;=n;j++)
				scanf(&quot;%lf&quot;,&amp;G[i][j]);
		}	
		scanf(&quot;%d&quot;,&amp;q);
		while(q--){
			scanf(&quot;%d%d&quot;,&amp;s,&amp;t);
			dijkstra(s); 
		}		
	}
	return 0;
} 

/*
3
1 0.5 0.5
0.5 1 0.4
0.5 0.4 1
3
1 2
2 3
1 3
3
1 0.5 0
0.5 1 0
0 0 1
3
1 2
2 3
1 3
3
1 0.5 0
0.5 1 0.4
0 0.4 1
3
1 2
2 3
1 3
*/</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-NYOJ_题目119_士兵杀敌（三）（线段树，区间最值）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/19/NYOJ_题目119_士兵杀敌（三）（线段树，区间最值）/">NYOJ 题目119 士兵杀敌（三）（线段树，区间最值）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h4 class="problem-display"></h4>
<h2 class="problem-display" align="center"><span style="color:#3366ff">士兵杀敌（三）</span></h2>
<div class="problem-ins" align="center"><span style="color:#33cc00">时间限制：<span id="problem[time_limit]" class="editable highlight">2000</span> ms &nbsp;|&nbsp; 内存限制：<span id="problem[memory_limit]" class="editable highlight">65535</span> KB
</span></div>
<div class="problem-ins" align="center"><span style="color:#33cc00">难度：<span class="editable highlight">5</span></span></div>
<div class="clr"></div>
<dl class="problem-display"><dt>描述 </dt><dd>
<p>南将军统率着N个士兵，士兵分别编号为1~N,南将军经常爱拿某一段编号内杀敌数最高的人与杀敌数最低的人进行比较，计算出两个人的杀敌数差&#20540;，用这种方法一方面能鼓舞杀敌数高的人，另一方面也算是批评杀敌数低的人，起到了很好的效果。</p>
<p>所以，南将军经常问军师小工第i号士兵到第j号士兵中，杀敌数最高的人与杀敌数最低的人之间军功差&#20540;是多少。</p>
<p>现在，请你写一个程序，帮小工回答南将军每次的询问吧。</p>
<p>注意，南将军可能询问很多次。</p>
<div class="clr"></div>
<dl class="others"><dt>输入 </dt><dd>只有一组测试数据<br>
第一行是两个整数N,Q，其中N表示士兵的总数。Q表示南将军询问的次数。(1&lt;N&lt;=100000,1&lt;Q&lt;=1000000)<br>
随后的一行有N个整数Vi(0&lt;=Vi&lt;100000000)，分别表示每个人的杀敌数。<br>
再之后的Q行，每行有两个正正数m,n，表示南将军询问的是第m号士兵到第n号士兵。 </dd><dt>输出 </dt><dd>对于每次询问，输出第m号士兵到第n号士兵之间所有士兵杀敌数的最大&#20540;与最小&#20540;的差。 </dd><dt>样例输入 </dt><dd>
<pre id="sample_input">5 2
1 2 6 9 3
1 2
2 4</pre>
</dd><dt>样例输出 </dt><dd>
<pre id="sample_output">1
7</pre>
</dd></dl>
</dd></dl>
<p>还可以用RMQ（目前还不会），</p>
<p>这是线段树做的。。时间空间复杂度大，</p>
<dl></dl>
<p>注意求最大最小&#20540;。。。。</p>
<p>&nbsp;</p>
<pre class="cpp" name="code"> 
/********************** 
2013-8-19 18:35:49 
Time: 500MS  Memory: 7180K 
Author: zyh
Status: Accepted
**********************/ 
#define N 100010
#define MAX(a,b) (a)&gt;(b)?(a):(b)
#define MIN(a,b) (a)&lt;(b)?(a):(b)
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;

using namespace std;

struct IntervalTree{
	int  L,R;
	int  max,min;
}tree[N*4];

int aa[N];

void build(int p,int l,int r){
	
	tree[p].L = l; tree[p].R = r;
	tree[p].max = -1;
	tree[p].min = 100000010;
	if(l==r) {
		tree[p].max = aa[l];
		tree[p].min = aa[l];
		return ;
	}
	int mid = (l+r)&gt;&gt;1;
	
	build(p&lt;&lt;1,l,mid);
	build(p&lt;&lt;1|1,mid+1,r);

	tree[p].max = MAX(tree[p&lt;&lt;1].max,tree[p&lt;&lt;1|1].max);
	tree[p].min = MIN(tree[p&lt;&lt;1].min,tree[p&lt;&lt;1|1].min);
}



int Max,Min;
void query(int  p,int  l,int  r){
	
	if( l == tree[p].L &amp;&amp; r == tree[p].R ){
	
		if(tree[p].max&gt;Max) Max = tree[p].max;
		if(tree[p].min&lt;Min) Min = tree[p].min;
		return ;
	}

	int  mid = (tree[p].L + tree[p].R)&gt;&gt;1;
	
	if(r&lt;=mid)	 query(p&lt;&lt;1,l,r);
	else if(l&gt;mid)	query(p&lt;&lt;1|1,l,r);
	else{	
		query(p&lt;&lt;1,l,mid);
		query(p&lt;&lt;1|1,mid+1,r);	
	}
}

int main()
{
	int n,m,i,a,b;	
	char s[2];
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;aa[i]);
	build(1,1,n);

	while(m--){
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			Min = 100000010; Max = -1;
			query(1,a,b);
			printf(&quot;%d\n&quot;,Max-Min);//一开始用的longlong输出，“%lld”，后来忘改了，导致WA好几次不解
	}
	
	return 0;
}         </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-poj_题目3468_A_Simple_Problem_with_Integers_（线段树）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/19/poj_题目3468_A_Simple_Problem_with_Integers_（线段树）/">poj 题目3468 A Simple Problem with Integers （线段树）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<p>&nbsp;</p>
<div lang="en-US" class="ptt" align="center"><span style="font-size:24px; color:#3366ff">A Simple Problem with Integers</span></div>
<div lang="en-US" class="ptt" align="center"><span style="font-size:24px; color:#3366ff"></span>&nbsp;</div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><span style="color:#33cc00"><strong>Time Limit:</strong> 5000MS</span></td>
<td width="10"><span style="color:#33cc00"></span></td>
<td><span style="color:#33cc00"><strong>Memory Limit:</strong> 131072K</span></td>
</tr>
<tr>
<td><span style="color:#33cc00"><strong>Total Submissions:</strong> 47665</span></td>
<td width="10"><span style="color:#33cc00"></span></td>
<td><span style="color:#33cc00"><strong>Accepted:</strong> 14016</span></td>
</tr>
<tr>
<td colspan="3" align="middle" style="color:#0ead00"><span style="color:#33cc00"><strong>Case Time Limit:</strong> 2000MS</span></td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div lang="en-US" class="ptx">
<p>You have <em>N</em> integers, <em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, ... ,
<em>A<sub>N</sub></em>. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.</p>
</div>
<p class="pst">Input</p>
<div lang="en-US" class="ptx">
<p>The first line contains two numbers <em>N</em> and <em>Q</em>. 1 ≤ <em>N</em>,<em>Q</em> ≤ 100000.<br>
The second line contains <em>N</em> numbers, the initial values of <em>A</em><sub>1</sub>,
<em>A</em><sub>2</sub>, ... , <em>A<sub>N</sub></em>. -1000000000 ≤ <em>A<sub>i</sub></em> ≤ 1000000000.<br>
Each of the next <em>Q</em> lines represents an operation.<br>
&quot;C <em>a b c</em>&quot; means adding <em>c</em> to each of <em>A<sub>a</sub></em>, <em>
A<sub>a</sub></em><sub>&#43;1</sub>, ... , <em>A<sub>b</sub></em>. -10000 ≤ <em>c</em> ≤ 10000.<br>
&quot;Q <em>a b</em>&quot; means querying the sum of <em>A<sub>a</sub></em>, <em>A<sub>a</sub></em><sub>&#43;1</sub>, ... ,
<em>A<sub>b</sub></em>.</p>
</div>
<p class="pst">Output</p>
<div lang="en-US" class="ptx">
<p>You need to answer all <em>Q</em> commands in order. One answer in a line.</p>
</div>
<p class="pst">Sample Input</p>
<pre class="sio">10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
</pre>
<p class="pst">Sample Output</p>
<pre class="sio">4
55
9
15</pre>
<p class="pst">Hint</p>
<div lang="en-US" class="ptx"><span style="font-size:18px; color:#ff0000">The sums may exceed the range of 32-bit integers.</span></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code"><p>/********************** </p><p>Time: 1579MS&nbsp;&nbsp; Memory: 6724KB
Author: zyh
Status: Accepted
**********************/ </p></pre><pre class="cpp" name="code">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define N 100010
struct IntevalTree{
	int L,R;
	__int64 value,add;
}tree[N*4];

int k;
int a[N];
__int64 sum;

void build(int root,int l,int r){
	tree[root].L = l; tree[root].R = r;
	tree[root].add = 0;
	if(tree[root].L == tree[root].R){
		tree[root].value = a[k++];
		return;
	} 
	
	int mid = (l+r)&gt;&gt;1;	
	build(root&lt;&lt;1,l,mid);
	build(root&lt;&lt;1|1,mid+1,r);
	
	tree[root].value = tree[root&lt;&lt;1].value + tree[root&lt;&lt;1|1].value;
}

void change(int root,int l,int r,long long v){
	
	
	if( tree[root].L == l &amp;&amp; tree[root].R == r){	//最后一次不加了，最后结算时再加上	
		tree[root].add += v;			
		return;
	}
	tree[root].value += v*(r-l+1);
		
	int mid = (tree[root].L + tree[root].R)&gt;&gt;1;		
	if(r&lt;=mid)	change(root&lt;&lt;1,l,r,v);		
	else if(l&gt;mid)	change(root&lt;&lt;1|1,l,r,v);
	else {
		change(root&lt;&lt;1,l,mid,v);
		change(root&lt;&lt;1|1,mid+1,r,v);
	}
}
long long query(int p, int left, int right) {
    int mid,v;
    v=p&lt;&lt;1;
    mid=(tree[p].L+tree[p].R)&gt;&gt;1;
    
    if(tree[p].L==left&amp;&amp;tree[p].R==right) {
        return (tree[p].value+tree[p].add*(tree[p].R-tree[p].L+1));
    }
    else{//可能区间有增量，需要计算并下移
    	tree[v].add+=tree[p].add;
        tree[v+1].add+=tree[p].add;//增量下移 
        tree[p].value+=(tree[p].R-tree[p].L+1)*tree[p].add;
        tree[p].add=0;
    }
    if(right&lt;=mid)
        return query(v,left,right);
    else if(left&gt;=mid+1)
        return query(v+1,left,right);
    else
        return query(v,left,mid)+query(v+1,mid+1,right);
}

int main()
{
	int n,q,i,aa,b,c;
	char s[2];
	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;q)!=EOF){

		for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
		
		k=0;	build(1,1,n);
		
		while(q--){
			scanf(&quot;%s&quot;,&amp;s);
			if(s[0]=='C'){
				scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;b,&amp;c);
				change(1,aa,b,c);
			}
			else{
				scanf(&quot;%d%d&quot;,&amp;aa,&amp;b);			
					
				printf(&quot;%I64d\n&quot;,query(1,aa,b));
			}
		}
	}
	return 0;
}


/*
10 20
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
Q 1 6
Q 1 9
C 1 4 2
C 2 4 2
Q 1 1
Q 2 2
Q 3 3
Q 4 4
Q 5 5
Q 6 6
Q 7 7
Q 1 3

*/


</pre>
<p><br>
&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目1754_I_Hate_It_（线段树，区间最大值）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/19/hdu_题目1754_I_Hate_It_（线段树，区间最大值）/">hdu 题目1754 I Hate It （线段树，区间最大值）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">I Hate It</h1>
<h1 align="center"><span style="background-color:#ffffff"><span style="color:#33cc00"><span size="&#43;0"><span style="font-size:14px">Time Limit: 9000/3000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 27989&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 11104<br>
</span></span><br>
</span></span><br>
</h1>
<div class="panel_title" align="left"><span style="font-size:18px; color:#3366ff">Problem Description</span></div>
<div class="panel_content">很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。<br>
这让很多学生很反感。<br>
<br>
不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left"><span style="font-size:18px; color:#3366ff">Input</span></div>
<div class="panel_content">本题目包含多组测试，请处理到文件结束。<br>
在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。<br>
学生ID编号分别从1编到N。<br>
第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。<br>
接下来有M行。每一行有一个字符 C (只取'Q'或'U') ，和两个正整数A，B。<br>
当C为'Q'的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。<br>
当C为'U'的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left"><span style="font-size:18px; color:#3366ff">Output</span></div>
<div class="panel_content">对于每一次询问操作，在一行里面输出最高成绩。</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">5 6
1 2 3 4 5
Q 1 5
U 3 6
Q 3 4
Q 4 5
U 2 9
Q 1 5</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">5
6
5
9

<div style="border-bottom:#b7cbff 1px dashed; border-left:#b7cbff 1px dashed; padding-bottom:6px; background-color:#f4fbff; padding-left:6px; padding-right:6px; font-family:Times New Roman; font-size:14px; border-top:#b7cbff 1px dashed; border-right:#b7cbff 1px dashed; padding-top:6px"><div style="border-bottom:#b7cbff 1px dashed; font-family:Arial; color:#7ca9ed; font-weight:bold"><em>Hint</em></div>Huge input,the C function scanf() will work better than cin</div><em style="font-size:1px"> </em></div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>记录区间最&#20540;，注意3中方向，向左子树，向右子树，分开两边的</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/********************** 
2013-8-19 18:35:49  
Time: 500MS  Memory: 7180K 
Author: zyh
Status: Accepted
**********************/ 
#define N 200010
#define MAX(a,b) (a)&gt;(b)?(a):(b)
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;

using namespace std;

struct IntervalTree{
	int L,R,max;
}tree[N*3];

int aa[N];

void build(int p,int l,int r){
	
	tree[p].L = l; tree[p].R = r;

	if(l==r) {
		tree[p].max = aa[l];
		return ;
	}
	int mid = (l+r)&gt;&gt;1;
	
	build(p&lt;&lt;1,l,mid);
	build(p&lt;&lt;1|1,mid+1,r);

	tree[p].max = MAX(tree[p&lt;&lt;1].max,tree[p&lt;&lt;1|1].max);
}


void change(int p,int a,int b){
	
	if(tree[p].L ==a &amp;&amp;  tree[p].R==a ){
		tree[p].max = b;
		return;
	}
	if(a&lt;tree[p&lt;&lt;1|1].L)	change(p&lt;&lt;1,a,b);
	else	change(p&lt;&lt;1|1,a,b);
	tree[p].max = MAX(tree[p&lt;&lt;1].max,tree[p&lt;&lt;1|1].max); 
}

int query(int p,int l,int r){
	
	if( l == tree[p].L &amp;&amp; r == tree[p].R )	return tree[p].max;

	int mid = (tree[p].L + tree[p].R)&gt;&gt;1;
	if(r&lt;=mid)	return query(p&lt;&lt;1,l,r);
	else if(l&gt;mid)	return query(p&lt;&lt;1|1,l,r);
	else{
		int tmp1 = query(p&lt;&lt;1,l,mid); // 这里不能直接放在宏定义函数中，不然超时 
		int tmp2 = query(p&lt;&lt;1|1,mid+1,r);	
		return MAX(tmp1,tmp2);
	}	
	
}


int main()
{
	int n,m,i,a,b;
	char s[2];
	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
	{
		for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;aa[i]);
		build(1,1,n);
	
		while(m--){
			scanf(&quot;%s&quot;,s);
			if(s[0]=='Q'){
				scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
				printf(&quot;%d\n&quot;,query(1,a,b));
			}
			else{
				scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
				change(1,a,b);	
			}
		}
	}
	return 0;
} </pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目4217_Data_Structure_（线段树，单点更新）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/19/hdu_题目4217_Data_Structure_（线段树，单点更新）/">hdu 题目4217 Data Structure?（线段树，单点更新）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 align="center" style="color:#1a5cc8">Data Structure?</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 10000/5000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 65536/65536 K (Java/Others)<br>
Total Submission(s): 2133&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 682<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left"><span style="font-size:18px; color:#3366ff; background-color:#ffffff">Problem Description</span></div>
<div class="panel_content">Data structure is one of the basic skills for Computer Science students, which is a particular way of storing and organizing data in a computer so that it can be used efficiently. Today let me introduce a data-structure-like problem
 for you.<br>
Original, there are N numbers, namely 1, 2, 3...N. Each round, iSea find out the Ki-th smallest number and take it away, your task is reporting him the total sum of the numbers he has taken away.<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left"><span style="font-size:18px; color:#3366ff; background-color:#ffffff"><strong>Input</strong></span></div>
<div class="panel_content">The first line contains a single integer T, indicating the number of test cases.<br>
Each test case includes two integers N, K, K indicates the round numbers. Then a line with K numbers following, indicating in i (1-based) round, iSea take away the Ki-th smallest away.<br>
<br>
<strong>Technical Specification</strong><br>
1. 1 &lt;= T &lt;= 128<br>
2. 1 &lt;= K &lt;= N &lt;= 262 144<br>
3. 1 &lt;= Ki &lt;= N - i &#43; 1<br>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left"><span style="font-size:18px; color:#3366ff">Output</span></div>
<div class="panel_content">For each test case, output the case number first, then the sum.</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">2
3 2
1 1
10 3
3 9 1</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
&nbsp;</p>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">Case 1: 3
Case 2: 14</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<p><br>
单点更新，</p>
<p>找到该点，路径上个区间的len--；</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre class="cpp" name="code">/*
2013-8-19 15:13:47
Time: 562MS    Memory: 6392K
Author: zyh 
*/
#define N 262200
#include&lt;stdio.h&gt;

struct IntervalTree{
	int L,R,len;
}tree[N*4];

__int64 sum; //这里又错了一次，，注意要64位 

void build(int p,int l,int r){
	
	tree[p].L = l;
	tree[p].R = r;
	tree[p].len = r-l+1;
	if(l==r) return;

	int mid = (l+r)&gt;&gt;1;
	
	build(p&lt;&lt;1,l,mid);
	build(p&lt;&lt;1|1,mid+1,r);
	
}

void change(int p,int cnt){

	tree[p].len--;
	
	if(tree[p].L==tree[p].R) {
		sum+=tree[p].L;
		return ;
	}

	if(cnt &lt;= tree[p&lt;&lt;1].len){
		change(p&lt;&lt;1,cnt);		
	}
	else if(cnt&gt;tree[p&lt;&lt;1].len){
		change(p&lt;&lt;1|1,cnt-tree[p&lt;&lt;1].len);
	}
}
int main()
{
	int t,n,k,i,tmp,j;
	scanf(&quot;%d\n&quot;,&amp;t);
	for(j=1;j&lt;=t;j++)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
		build(1,1,n);
		sum=0;
		for(i=0;i&lt;k;i++){
			scanf(&quot;%d&quot;,&amp;tmp);
			change(1,tmp);
		}
		printf(&quot;Case %d: %I64d\n&quot;,j,sum);		
	} 
	return 0;
} 

</pre>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  
    <article id="post-hdu_题目2531_Catch_him（BFS）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/17/hdu_题目2531_Catch_him（BFS）/">hdu 题目2531 Catch him（BFS）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p></p>
<h1 style="color:rgb(26,92,200); text-align:center; font-family:'Times New Roman'">
Catch him</h1>
<span style="font-family:'Times New Roman'; font-size:14px"><strong><span style="font-family:Arial; font-size:12px; color:green">Time Limit: 5000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 465&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 216<br>
</span></strong></span><br style="font-family:'Times New Roman'; font-size:14px">
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Problem Description</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
在美式足球中，四分卫负责指挥整只球队的进攻战术和跑位，以及给接球员传球的任务。四分卫是一只球队进攻组最重要的球员，而且一般身体都相对比较弱小，所以通常球队会安排5-7名大汉来保护他，其中站在四分卫前方、排成一线的5名球员称为进攻锋线，他们通常都是135公斤左右的壮汉。<br>
<img src="http://acm.hdu.edu.cn/data/images/2531-1.jpg" alt="" style="border:none"><br>
对防守方来说，攻击对手的四分卫当然是最直接的限制对手进攻的方法。如果效果好，就可以在对方四分卫传球之前将其按翻在地，称之为擒杀。擒杀是最好的鼓舞防守队士气的方法，因为对方连传球的机会都没有，进攻就结束了，还必须倒退一些距离开球。凶狠的擒杀甚至能够将对方的四分卫弄伤，从而迫使对方更换这个进攻核心。<br>
在本题中，输入给出准备擒杀四分卫的防守球员的位置、对方每个进攻锋线球员的位置以及对方四分卫的位置，你的任务是求出这名准备擒杀的防守球员至少要移动多少步，才能够擒杀对方四分卫。<br>
假设对方进攻锋线和四分卫在这个过程中都不会移动。只有1名防守球员，防守球员只要碰到对方四分卫就算擒杀。<br>
所有的球员都是一块连续的、不中空的2维区域。防守球员不可以从进攻锋线的身体上穿过，也不可以从界外穿过(只能走空地)。<br>
防守队员不可以转动身体，只能平移。防守队员的身体所有部分向同一个方向(上、下、左、右)移动1&#26684;的过程叫做1步。<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
输入包含多组数据。每组数据第一行都是两个整数H，W(0&lt;H,W&lt;=100)，表示整个区域的高度和宽度，H=W=0表示输入结束。接下来有H行，每行W个字符。每个字符如果是’.’，表示这里是空地，如果是’O’，表示是进攻锋线队员的身体，如果是’D’，表示是准备擒杀的防守球员的身体，如果是’Q’，表示是四分卫的身体。<br>
输入保证符合上面的条件。防守球员的身体总共不超过20&#26684;。<br>
<br>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
对每组数据，输出包含擒杀所需最少步数的一行。如果不能擒杀，输出带’Impossible’的一行。</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Input</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">6 6
.Q....
QQ..OO
.OO..O
...O.O
OO.O..
....DD
7 7
.Q.....
QQ.OOO.
...O...
O......
OO..OO.
.O.....
.....DD
0 0</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<br style="font-family:'Times New Roman'; font-size:14px">
<div class="panel_title" align="left" style="height:38px; background-color:transparent; padding:0px 14px; color:rgb(124,169,237); font-size:18px; font-family:Arial; font-weight:bold">
Sample Output</div>
<div class="panel_content" style="height:auto; margin:0px; padding:0px 20px; font-size:14px; font-family:'Times New Roman'">
<pre style="margin-top:0px; margin-bottom:0px"><div style="font-family:'Courier New',Courier,monospace">Impossible
9</div></pre>
</div>
<div class="panel_bottom" style="height:auto; margin:0px; font-family:'Times New Roman'; font-size:14px">
&nbsp;</div>
<div><br>
</div>
将防守队员看做一个整体，每次移动都做整体移动
<p></p>
<p><br>
</p>
<p><pre name="code" class="cpp">#include&lt;stdio.h&gt;
#include&lt;queue&gt;
#include&lt;string.h&gt;
using namespace std;
int k,h,w;	

struct body{
	int x[22],y[22],step;
}s;

int sx[22],sy[22];
char a[110][110];
bool vis[110][110];
int dir[4][2] = {1,0,-1,0,0,1,0,-1};


bool catchhim(body tmp){
	for(int i=0;i&lt;k;i++){
		if(a[tmp.x[i]][tmp.y[i]]=='Q')
			return 1;
	}
	return 0;
}
bool place(body tmp){

	for(int i=0;i&lt;k;i++){
		if(tmp.x[i]&lt;0 || tmp.x[i]&gt;=h || tmp.y[i]&lt;0 || tmp.y[i]&gt;=w || a[tmp.x[i]][tmp.y[i]]=='O')
			return 0;
	}
	return 1;
}

void bfs(){
	
	queue&lt;body&gt;q;
	body tmp,cur;
	int i,j;
	memset(vis,0,sizeof(vis));

	for(i=0;i&lt;k;i++){
		tmp.x[i] = sx[i];
		tmp.y[i] = sy[i];
	}	
	tmp.step = 0;
	
	q.push(tmp);
	
	vis[tmp.x[0]][tmp.y[0]] = 1;
	
	while(!q.empty()){
		
		tmp = q.front();
		q.pop();
		
		if(catchhim(tmp)){
			printf(&quot;%d\n&quot;,tmp.step);
			return ;
		}
		
		for(j=0;j&lt;4;j++){
			
			for(i=0;i&lt;k;i++){
				cur.x[i] = tmp.x[i] + dir[j][0];
				cur.y[i] = tmp.y[i] + dir[j][1];		
			}
			
			cur.step = tmp.step + 1;
			
			if(place(cur) &amp;&amp; !vis[cur.x[0]][cur.y[0]]){
				vis[cur.x[0]][cur.y[0]] = 1;
				q.push(cur);
			}
		}
	}
	printf(&quot;Impossible\n&quot;);
}
int main(){
	while(scanf(&quot;%d%d&quot;,&amp;h,&amp;w),h&amp;&amp;w){
		getchar();
		k=0;
		for(int i=0;i&lt;h;i++){
			for(int j=0;j&lt;w;j++){
				scanf(&quot;%c&quot;,&amp;a[i][j]);
				if(a[i][j]=='D'){
					sx[k] = i;
					sy[k++] = j;
				}
			}
			getchar();
		}

		bfs();	
	}	
	return 0;
}</pre><br>
<br>
</p>
<p><br>
</p>

      
    </div>
</article>
 
 <!-- 上一页 下一页 -->


<!-- 相关文章 -->




  

  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/11/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/13/">Next &raquo;</a>
    </nav>
  


</section>
      </div>
      <footer id="footer">
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      &copy; 2017 <a href="https://github.com/hanks-zyh"> Hanks</a>
	  </div>
  </div>
 <div id="share">
  <a id="totop" title="" style="display: block;">返回顶部</a>
 </div>
</footer>

    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
